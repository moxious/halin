{
  "id": "e5862706-1a80-4d1e-ba38-f93a3a69150e",
  "generated": "2019-03-03T01:17:34.990Z",
  "halin": {
    "cluster": true,
    "enterprise": true,
    "nativeAuth": true,
    "pollRate": 1000,
    "user": {
      "username": "neo4j",
      "roles": [
        "admin"
      ],
      "flags": []
    },
    "debug": false,
    "eventLog": [
      {
        "type": "halin",
        "message": "Halin monitoring started",
        "date": "2019-03-03T01:17:30.883Z",
        "payload": null,
        "id": "d68459dc-aa46-4d19-8bb5-2a8b078bda90"
      }
    ],
    "drivers": [
      {
        "node": "bolt://node1.cluster.graph.center:7687",
        "_config": {
          "encrypted": true,
          "connectionTimeout": 10000,
          "trust": "TRUST_CUSTOM_CA_SIGNED_CERTIFICATES",
          "maxConnectionLifetime": 3600000,
          "maxConnectionPoolSize": 100,
          "connectionAcquisitionTimeout": 60000
        }
      },
      {
        "node": "bolt://node2.cluster.graph.center:7687",
        "_config": {
          "encrypted": true,
          "connectionTimeout": 10000,
          "trust": "TRUST_CUSTOM_CA_SIGNED_CERTIFICATES",
          "maxConnectionLifetime": 3600000,
          "maxConnectionPoolSize": 100,
          "connectionAcquisitionTimeout": 60000
        }
      },
      {
        "node": "bolt://node3.cluster.graph.center:7687",
        "_config": {
          "encrypted": true,
          "connectionTimeout": 10000,
          "trust": "TRUST_CUSTOM_CA_SIGNED_CERTIFICATES",
          "maxConnectionLifetime": 3600000,
          "maxConnectionPoolSize": 100,
          "connectionAcquisitionTimeout": 60000
        }
      }
    ],
    "activeProject": {
      "name": "shim",
      "graphs": [
        {
          "name": "shim",
          "status": "ACTIVE",
          "databaseStatus": "RUNNING",
          "databaseType": "neo4j",
          "id": "19034ebb-49c3-4c65-93b4-025230d7e66c",
          "connection": {
            "configuration": {
              "path": ".",
              "protocols": {
                "bolt": {
                  "host": "node1.cluster.graph.center",
                  "port": 7687,
                  "username": "neo4j",
                  "password": "********",
                  "enabled": true,
                  "tlsLevel": "REQUIRED"
                }
              }
            }
          }
        }
      ]
    },
    "activeGraph": {
      "name": "shim",
      "status": "ACTIVE",
      "databaseStatus": "RUNNING",
      "databaseType": "neo4j",
      "id": "19034ebb-49c3-4c65-93b4-025230d7e66c",
      "connection": {
        "configuration": {
          "path": ".",
          "protocols": {
            "bolt": {
              "host": "node1.cluster.graph.center",
              "port": 7687,
              "username": "neo4j",
              "password": "********",
              "enabled": true,
              "tlsLevel": "REQUIRED"
            }
          }
        }
      }
    },
    "dataFeeds": [
      {
        "name": "bolt://node1.cluster.graph.center:7687-CALL dbms.cluster.role()-[{\"Header\":\"Role\",\"accessor\":\"role\"}]}",
        "label": "CLUSTER_ROLE",
        "address": "bolt://node1.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 46,
          "role": "FOLLOWER"
        },
        "query": "CALL dbms.cluster.role()",
        "packets": 2,
        "stdev": 4.242640687119285,
        "mean": 49,
        "median": 49,
        "mode": [
          52,
          46
        ],
        "min": 46,
        "max": 52,
        "listeners": 1,
        "augFns": 0,
        "aliases": 0,
        "timings": [
          52,
          46
        ]
      },
      {
        "name": "bolt://node2.cluster.graph.center:7687-CALL dbms.cluster.role()-[{\"Header\":\"Role\",\"accessor\":\"role\"}]}",
        "label": "CLUSTER_ROLE",
        "address": "bolt://node2.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 543,
          "role": "FOLLOWER"
        },
        "query": "CALL dbms.cluster.role()",
        "packets": 1,
        "stdev": 0,
        "mean": 543,
        "median": 543,
        "mode": [
          543
        ],
        "min": 543,
        "max": 543,
        "listeners": 1,
        "augFns": 0,
        "aliases": 0,
        "timings": [
          543
        ]
      },
      {
        "name": "bolt://node3.cluster.graph.center:7687-CALL dbms.cluster.role()-[{\"Header\":\"Role\",\"accessor\":\"role\"}]}",
        "label": "CLUSTER_ROLE",
        "address": "bolt://node3.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 665,
          "role": "LEADER"
        },
        "query": "CALL dbms.cluster.role()",
        "packets": 1,
        "stdev": 0,
        "mean": 665,
        "median": 665,
        "mode": [
          665
        ],
        "min": 665,
        "max": 665,
        "listeners": 1,
        "augFns": 0,
        "aliases": 0,
        "timings": [
          665
        ]
      },
      {
        "name": "bolt://node1.cluster.graph.center:7687-RETURN true AS value-[{\"Header\":\"Value\",\"accessor\":\"value\"}]}",
        "label": "PING",
        "address": "bolt://node1.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 45,
          "value": true
        },
        "query": "RETURN true AS value",
        "packets": 4,
        "stdev": 5.852349955359813,
        "mean": 48.25,
        "median": 45.5,
        "mode": [
          45
        ],
        "min": 45,
        "max": 57,
        "listeners": 2,
        "augFns": 0,
        "aliases": 0,
        "timings": [
          57,
          45,
          46,
          45
        ]
      },
      {
        "name": "bolt://node2.cluster.graph.center:7687-RETURN true AS value-[{\"Header\":\"Value\",\"accessor\":\"value\"}]}",
        "label": "PING",
        "address": "bolt://node2.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 52,
          "value": true
        },
        "query": "RETURN true AS value",
        "packets": 4,
        "stdev": 22.045407685048602,
        "mean": 61,
        "median": 50.5,
        "mode": [
          49
        ],
        "min": 49,
        "max": 94,
        "listeners": 2,
        "augFns": 0,
        "aliases": 0,
        "timings": [
          94,
          49,
          49,
          52
        ]
      },
      {
        "name": "bolt://node3.cluster.graph.center:7687-RETURN true AS value-[{\"Header\":\"Value\",\"accessor\":\"value\"}]}",
        "label": "PING",
        "address": "bolt://node3.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 46,
          "value": true
        },
        "query": "RETURN true AS value",
        "packets": 4,
        "stdev": 22.544400635190993,
        "mean": 58.25,
        "median": 47.5,
        "mode": [
          46
        ],
        "min": 46,
        "max": 92,
        "listeners": 2,
        "augFns": 0,
        "aliases": 0,
        "timings": [
          92,
          49,
          46,
          46
        ]
      },
      {
        "name": "bolt://node1.cluster.graph.center:7687- CALL dbms.queryJmx('java.lang:type=Memory') yield attributes WITH attributes.HeapMemoryUsage as heap, attributes.NonHeapMemoryUsage as nonHeap WITH heap.value.properties as heapProps, nonHeap.value.properties as nonHeapProps return heapProps.init as heapInit, heapProps.committed as heapCommitted, heapProps.used as heapUsed, heapProps.max as heapMax, nonHeapProps.init as nonHeapInit, nonHeapProps.committed as nonHeapCommitted, nonHeapProps.used as nonHeapUsed, nonHeapProps.max as nonHeapMax, heapProps.used + nonHeapProps.used as totalMem-[{\"Header\":\"heapUsed\",\"accessor\":\"heapUsed\"}]}",
        "label": "JMX_MEMORY_STATS",
        "address": "bolt://node1.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 47,
          "heapUsed": 1994512176,
          "boltnode1clustergraphcenter7687heapUsed": 1994512176
        },
        "query": "\n        CALL dbms.queryJmx('java.lang:type=Memory') yield attributes \n        WITH \n            attributes.HeapMemoryUsage as heap, \n            attributes.NonHeapMemoryUsage as nonHeap\n\n        WITH \n            heap.value.properties as heapProps,\n            nonHeap.value.properties as nonHeapProps\n        \n        return \n            heapProps.init as heapInit, \n            heapProps.committed as heapCommitted,\n            heapProps.used as heapUsed, \n            heapProps.max as heapMax,\n            nonHeapProps.init as nonHeapInit,\n            nonHeapProps.committed as nonHeapCommitted,\n            nonHeapProps.used as nonHeapUsed,\n            nonHeapProps.max as nonHeapMax,\n            heapProps.used + nonHeapProps.used as totalMem",
        "packets": 4,
        "stdev": 16.194134740701646,
        "mean": 55.75,
        "median": 48,
        "mode": [
          47
        ],
        "min": 47,
        "max": 80,
        "listeners": 1,
        "augFns": 0,
        "aliases": 1,
        "timings": [
          80,
          47,
          49,
          47
        ]
      },
      {
        "name": "bolt://node2.cluster.graph.center:7687- CALL dbms.queryJmx('java.lang:type=Memory') yield attributes WITH attributes.HeapMemoryUsage as heap, attributes.NonHeapMemoryUsage as nonHeap WITH heap.value.properties as heapProps, nonHeap.value.properties as nonHeapProps return heapProps.init as heapInit, heapProps.committed as heapCommitted, heapProps.used as heapUsed, heapProps.max as heapMax, nonHeapProps.init as nonHeapInit, nonHeapProps.committed as nonHeapCommitted, nonHeapProps.used as nonHeapUsed, nonHeapProps.max as nonHeapMax, heapProps.used + nonHeapProps.used as totalMem-[{\"Header\":\"heapUsed\",\"accessor\":\"heapUsed\"}]}",
        "label": "JMX_MEMORY_STATS",
        "address": "bolt://node2.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 50,
          "heapUsed": 3309509680,
          "boltnode2clustergraphcenter7687heapUsed": 3309509680
        },
        "query": "\n        CALL dbms.queryJmx('java.lang:type=Memory') yield attributes \n        WITH \n            attributes.HeapMemoryUsage as heap, \n            attributes.NonHeapMemoryUsage as nonHeap\n\n        WITH \n            heap.value.properties as heapProps,\n            nonHeap.value.properties as nonHeapProps\n        \n        return \n            heapProps.init as heapInit, \n            heapProps.committed as heapCommitted,\n            heapProps.used as heapUsed, \n            heapProps.max as heapMax,\n            nonHeapProps.init as nonHeapInit,\n            nonHeapProps.committed as nonHeapCommitted,\n            nonHeapProps.used as nonHeapUsed,\n            nonHeapProps.max as nonHeapMax,\n            heapProps.used + nonHeapProps.used as totalMem",
        "packets": 4,
        "stdev": 26.196373794859472,
        "mean": 64.75,
        "median": 52.5,
        "mode": [
          104,
          52,
          53,
          50
        ],
        "min": 50,
        "max": 104,
        "listeners": 1,
        "augFns": 0,
        "aliases": 1,
        "timings": [
          104,
          52,
          53,
          50
        ]
      },
      {
        "name": "bolt://node3.cluster.graph.center:7687- CALL dbms.queryJmx('java.lang:type=Memory') yield attributes WITH attributes.HeapMemoryUsage as heap, attributes.NonHeapMemoryUsage as nonHeap WITH heap.value.properties as heapProps, nonHeap.value.properties as nonHeapProps return heapProps.init as heapInit, heapProps.committed as heapCommitted, heapProps.used as heapUsed, heapProps.max as heapMax, nonHeapProps.init as nonHeapInit, nonHeapProps.committed as nonHeapCommitted, nonHeapProps.used as nonHeapUsed, nonHeapProps.max as nonHeapMax, heapProps.used + nonHeapProps.used as totalMem-[{\"Header\":\"heapUsed\",\"accessor\":\"heapUsed\"}]}",
        "label": "JMX_MEMORY_STATS",
        "address": "bolt://node3.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 47,
          "heapUsed": 1651164168,
          "boltnode3clustergraphcenter7687heapUsed": 1651164168
        },
        "query": "\n        CALL dbms.queryJmx('java.lang:type=Memory') yield attributes \n        WITH \n            attributes.HeapMemoryUsage as heap, \n            attributes.NonHeapMemoryUsage as nonHeap\n\n        WITH \n            heap.value.properties as heapProps,\n            nonHeap.value.properties as nonHeapProps\n        \n        return \n            heapProps.init as heapInit, \n            heapProps.committed as heapCommitted,\n            heapProps.used as heapUsed, \n            heapProps.max as heapMax,\n            nonHeapProps.init as nonHeapInit,\n            nonHeapProps.committed as nonHeapCommitted,\n            nonHeapProps.used as nonHeapUsed,\n            nonHeapProps.max as nonHeapMax,\n            heapProps.used + nonHeapProps.used as totalMem",
        "packets": 4,
        "stdev": 24.013884872437167,
        "mean": 58,
        "median": 46.5,
        "mode": [
          94,
          46,
          45,
          47
        ],
        "min": 45,
        "max": 94,
        "listeners": 1,
        "augFns": 0,
        "aliases": 1,
        "timings": [
          94,
          46,
          45,
          47
        ]
      },
      {
        "name": "bolt://node1.cluster.graph.center:7687- CALL dbms.queryJmx(\"java.lang:type=OperatingSystem\") YIELD attributes WITH attributes.OpenFileDescriptorCount.value as fdOpen, attributes.MaxFileDescriptorCount.value as fdMax, attributes.FreePhysicalMemorySize.value as physFree, attributes.TotalPhysicalMemorySize.value as physTotal, attributes.CommittedVirtualMemorySize.value as virtCommitted, attributes.FreeSwapSpaceSize.value as swapFree, attributes.TotalSwapSpaceSize.value as swapTotal, attributes.Name.value as osName, attributes.Version.value as osVersion, attributes.Arch.value as arch, attributes.AvailableProcessors.value as processors RETURN fdOpen, fdMax, physFree, physTotal, virtCommitted, swapFree, swapTotal, osName, osVersion, arch, processors-[{\"Header\":\"Open FDs\",\"accessor\":\"fdOpen\"},{\"Header\":\"Max FDs\",\"accessor\":\"fdMax\"},{\"Header\":\"Physical Memory (Free)\",\"accessor\":\"physFree\"},{\"Header\":\"Physical Memory (Total)\",\"accessor\":\"physTotal\"},{\"Header\":\"Virtual Memory (Committed)\",\"accessor\":\"virtCommitted\"},{\"Header\":\"Swap memory (Free)\",\"accessor\":\"swapFree\"},{\"Header\":\"Swap memory (Total)\",\"accessor\":\"swapTotal\"},{\"Header\":\"OS Name\",\"accessor\":\"osName\"},{\"Header\":\"OS Version\",\"accessor\":\"osVersion\"},{\"Header\":\"Arch\",\"accessor\":\"arch\"},{\"Header\":\"Processors\",\"accessor\":\"processors\"}]}",
        "label": "OS_MEMORY_STATS",
        "address": "bolt://node1.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 114,
          "fdOpen": 948,
          "fdMax": 60000,
          "physFree": 249769984,
          "physTotal": 15762874368,
          "virtCommitted": 10467692544,
          "swapFree": 0,
          "swapTotal": 0,
          "osName": "Linux",
          "osVersion": "4.15.0-1017-gcp",
          "arch": "amd64",
          "processors": 4,
          "physUsed": 15513104384,
          "boltnode1clustergraphcenter7687physUsed": 15513104384
        },
        "query": "\n            CALL dbms.queryJmx(\"java.lang:type=OperatingSystem\") \n            YIELD attributes \n            WITH\n                attributes.OpenFileDescriptorCount.value as fdOpen,\n                attributes.MaxFileDescriptorCount.value as fdMax,\n\n                attributes.FreePhysicalMemorySize.value as physFree,\n                attributes.TotalPhysicalMemorySize.value as physTotal,\n\n                attributes.CommittedVirtualMemorySize.value as virtCommitted,\n                attributes.FreeSwapSpaceSize.value as swapFree,\n                attributes.TotalSwapSpaceSize.value as swapTotal,\n\n                attributes.Name.value as osName,\n                attributes.Version.value as osVersion,\n                attributes.Arch.value as arch,\n                attributes.AvailableProcessors.value as processors\n            RETURN \n                fdOpen, fdMax,\n                physFree, physTotal,\n                virtCommitted, swapFree, swapTotal,\n                osName, osVersion, arch, processors",
        "packets": 4,
        "stdev": 15.88500340992514,
        "mean": 119.5,
        "median": 113.5,
        "mode": [
          143,
          113,
          108,
          114
        ],
        "min": 108,
        "max": 143,
        "listeners": 1,
        "augFns": 1,
        "aliases": 1,
        "timings": [
          143,
          113,
          108,
          114
        ]
      },
      {
        "name": "bolt://node2.cluster.graph.center:7687- CALL dbms.queryJmx(\"java.lang:type=OperatingSystem\") YIELD attributes WITH attributes.OpenFileDescriptorCount.value as fdOpen, attributes.MaxFileDescriptorCount.value as fdMax, attributes.FreePhysicalMemorySize.value as physFree, attributes.TotalPhysicalMemorySize.value as physTotal, attributes.CommittedVirtualMemorySize.value as virtCommitted, attributes.FreeSwapSpaceSize.value as swapFree, attributes.TotalSwapSpaceSize.value as swapTotal, attributes.Name.value as osName, attributes.Version.value as osVersion, attributes.Arch.value as arch, attributes.AvailableProcessors.value as processors RETURN fdOpen, fdMax, physFree, physTotal, virtCommitted, swapFree, swapTotal, osName, osVersion, arch, processors-[{\"Header\":\"Open FDs\",\"accessor\":\"fdOpen\"},{\"Header\":\"Max FDs\",\"accessor\":\"fdMax\"},{\"Header\":\"Physical Memory (Free)\",\"accessor\":\"physFree\"},{\"Header\":\"Physical Memory (Total)\",\"accessor\":\"physTotal\"},{\"Header\":\"Virtual Memory (Committed)\",\"accessor\":\"virtCommitted\"},{\"Header\":\"Swap memory (Free)\",\"accessor\":\"swapFree\"},{\"Header\":\"Swap memory (Total)\",\"accessor\":\"swapTotal\"},{\"Header\":\"OS Name\",\"accessor\":\"osName\"},{\"Header\":\"OS Version\",\"accessor\":\"osVersion\"},{\"Header\":\"Arch\",\"accessor\":\"arch\"},{\"Header\":\"Processors\",\"accessor\":\"processors\"}]}",
        "label": "OS_MEMORY_STATS",
        "address": "bolt://node2.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 116,
          "fdOpen": 951,
          "fdMax": 60000,
          "physFree": 174215168,
          "physTotal": 15762874368,
          "virtCommitted": 13951463424,
          "swapFree": 0,
          "swapTotal": 0,
          "osName": "Linux",
          "osVersion": "4.15.0-1017-gcp",
          "arch": "amd64",
          "processors": 4,
          "physUsed": 15588659200,
          "boltnode2clustergraphcenter7687physUsed": 15588659200
        },
        "query": "\n            CALL dbms.queryJmx(\"java.lang:type=OperatingSystem\") \n            YIELD attributes \n            WITH\n                attributes.OpenFileDescriptorCount.value as fdOpen,\n                attributes.MaxFileDescriptorCount.value as fdMax,\n\n                attributes.FreePhysicalMemorySize.value as physFree,\n                attributes.TotalPhysicalMemorySize.value as physTotal,\n\n                attributes.CommittedVirtualMemorySize.value as virtCommitted,\n                attributes.FreeSwapSpaceSize.value as swapFree,\n                attributes.TotalSwapSpaceSize.value as swapTotal,\n\n                attributes.Name.value as osName,\n                attributes.Version.value as osVersion,\n                attributes.Arch.value as arch,\n                attributes.AvailableProcessors.value as processors\n            RETURN \n                fdOpen, fdMax,\n                physFree, physTotal,\n                virtCommitted, swapFree, swapTotal,\n                osName, osVersion, arch, processors",
        "packets": 4,
        "stdev": 22.045407685048602,
        "mean": 126,
        "median": 116,
        "mode": [
          116
        ],
        "min": 113,
        "max": 159,
        "listeners": 1,
        "augFns": 1,
        "aliases": 1,
        "timings": [
          159,
          113,
          116,
          116
        ]
      },
      {
        "name": "bolt://node3.cluster.graph.center:7687- CALL dbms.queryJmx(\"java.lang:type=OperatingSystem\") YIELD attributes WITH attributes.OpenFileDescriptorCount.value as fdOpen, attributes.MaxFileDescriptorCount.value as fdMax, attributes.FreePhysicalMemorySize.value as physFree, attributes.TotalPhysicalMemorySize.value as physTotal, attributes.CommittedVirtualMemorySize.value as virtCommitted, attributes.FreeSwapSpaceSize.value as swapFree, attributes.TotalSwapSpaceSize.value as swapTotal, attributes.Name.value as osName, attributes.Version.value as osVersion, attributes.Arch.value as arch, attributes.AvailableProcessors.value as processors RETURN fdOpen, fdMax, physFree, physTotal, virtCommitted, swapFree, swapTotal, osName, osVersion, arch, processors-[{\"Header\":\"Open FDs\",\"accessor\":\"fdOpen\"},{\"Header\":\"Max FDs\",\"accessor\":\"fdMax\"},{\"Header\":\"Physical Memory (Free)\",\"accessor\":\"physFree\"},{\"Header\":\"Physical Memory (Total)\",\"accessor\":\"physTotal\"},{\"Header\":\"Virtual Memory (Committed)\",\"accessor\":\"virtCommitted\"},{\"Header\":\"Swap memory (Free)\",\"accessor\":\"swapFree\"},{\"Header\":\"Swap memory (Total)\",\"accessor\":\"swapTotal\"},{\"Header\":\"OS Name\",\"accessor\":\"osName\"},{\"Header\":\"OS Version\",\"accessor\":\"osVersion\"},{\"Header\":\"Arch\",\"accessor\":\"arch\"},{\"Header\":\"Processors\",\"accessor\":\"processors\"}]}",
        "label": "OS_MEMORY_STATS",
        "address": "bolt://node3.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 114,
          "fdOpen": 954,
          "fdMax": 60000,
          "physFree": 298070016,
          "physTotal": 15762874368,
          "virtCommitted": 17097699328,
          "swapFree": 0,
          "swapTotal": 0,
          "osName": "Linux",
          "osVersion": "4.15.0-1017-gcp",
          "arch": "amd64",
          "processors": 4,
          "physUsed": 15464804352,
          "boltnode3clustergraphcenter7687physUsed": 15464804352
        },
        "query": "\n            CALL dbms.queryJmx(\"java.lang:type=OperatingSystem\") \n            YIELD attributes \n            WITH\n                attributes.OpenFileDescriptorCount.value as fdOpen,\n                attributes.MaxFileDescriptorCount.value as fdMax,\n\n                attributes.FreePhysicalMemorySize.value as physFree,\n                attributes.TotalPhysicalMemorySize.value as physTotal,\n\n                attributes.CommittedVirtualMemorySize.value as virtCommitted,\n                attributes.FreeSwapSpaceSize.value as swapFree,\n                attributes.TotalSwapSpaceSize.value as swapTotal,\n\n                attributes.Name.value as osName,\n                attributes.Version.value as osVersion,\n                attributes.Arch.value as arch,\n                attributes.AvailableProcessors.value as processors\n            RETURN \n                fdOpen, fdMax,\n                physFree, physTotal,\n                virtCommitted, swapFree, swapTotal,\n                osName, osVersion, arch, processors",
        "packets": 4,
        "stdev": 23.45207879911715,
        "mean": 124,
        "median": 114,
        "mode": [
          114
        ],
        "min": 109,
        "max": 159,
        "listeners": 1,
        "augFns": 1,
        "aliases": 1,
        "timings": [
          159,
          109,
          114,
          114
        ]
      },
      {
        "name": "bolt://node1.cluster.graph.center:7687- CALL dbms.queryJmx('java.lang:name=G1 Young Generation,type=GarbageCollector') YIELD name, attributes WHERE name =~ '(?i).*garbage.*' WITH attributes.LastGcInfo.value.properties as lastGC RETURN lastGC.startTime as startTime, lastGC.duration as duration, lastGC.GcThreadCount as threadCount LIMIT 1-[{\"Header\":\"duration\",\"accessor\":\"duration\"}]}",
        "label": "JMX_GARBAGE_COLLECTOR",
        "address": "bolt://node1.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 43,
          "duration": 53,
          "boltnode1clustergraphcenter7687duration": 53
        },
        "query": "\n        CALL dbms.queryJmx('java.lang:name=G1 Young Generation,type=GarbageCollector') \n        YIELD name, attributes \n        WHERE name =~ '(?i).*garbage.*' \n        WITH attributes.LastGcInfo.value.properties as lastGC \n        \n        RETURN \n            lastGC.startTime as startTime,\n            lastGC.duration as duration,\n            lastGC.GcThreadCount as threadCount\n        LIMIT 1",
        "packets": 4,
        "stdev": 99.16778710851624,
        "mean": 93.25,
        "median": 44,
        "mode": [
          44
        ],
        "min": 43,
        "max": 242,
        "listeners": 1,
        "augFns": 0,
        "aliases": 1,
        "timings": [
          242,
          44,
          44,
          43
        ]
      },
      {
        "name": "bolt://node2.cluster.graph.center:7687- CALL dbms.queryJmx('java.lang:name=G1 Young Generation,type=GarbageCollector') YIELD name, attributes WHERE name =~ '(?i).*garbage.*' WITH attributes.LastGcInfo.value.properties as lastGC RETURN lastGC.startTime as startTime, lastGC.duration as duration, lastGC.GcThreadCount as threadCount LIMIT 1-[{\"Header\":\"duration\",\"accessor\":\"duration\"}]}",
        "label": "JMX_GARBAGE_COLLECTOR",
        "address": "bolt://node2.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 49,
          "duration": 52,
          "boltnode2clustergraphcenter7687duration": 52
        },
        "query": "\n        CALL dbms.queryJmx('java.lang:name=G1 Young Generation,type=GarbageCollector') \n        YIELD name, attributes \n        WHERE name =~ '(?i).*garbage.*' \n        WITH attributes.LastGcInfo.value.properties as lastGC \n        \n        RETURN \n            lastGC.startTime as startTime,\n            lastGC.duration as duration,\n            lastGC.GcThreadCount as threadCount\n        LIMIT 1",
        "packets": 4,
        "stdev": 109.67983710175115,
        "mean": 104.5,
        "median": 50.5,
        "mode": [
          269,
          48,
          52,
          49
        ],
        "min": 48,
        "max": 269,
        "listeners": 1,
        "augFns": 0,
        "aliases": 1,
        "timings": [
          269,
          48,
          52,
          49
        ]
      },
      {
        "name": "bolt://node3.cluster.graph.center:7687- CALL dbms.queryJmx('java.lang:name=G1 Young Generation,type=GarbageCollector') YIELD name, attributes WHERE name =~ '(?i).*garbage.*' WITH attributes.LastGcInfo.value.properties as lastGC RETURN lastGC.startTime as startTime, lastGC.duration as duration, lastGC.GcThreadCount as threadCount LIMIT 1-[{\"Header\":\"duration\",\"accessor\":\"duration\"}]}",
        "label": "JMX_GARBAGE_COLLECTOR",
        "address": "bolt://node3.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 46,
          "duration": 93,
          "boltnode3clustergraphcenter7687duration": 93
        },
        "query": "\n        CALL dbms.queryJmx('java.lang:name=G1 Young Generation,type=GarbageCollector') \n        YIELD name, attributes \n        WHERE name =~ '(?i).*garbage.*' \n        WITH attributes.LastGcInfo.value.properties as lastGC \n        \n        RETURN \n            lastGC.startTime as startTime,\n            lastGC.duration as duration,\n            lastGC.GcThreadCount as threadCount\n        LIMIT 1",
        "packets": 4,
        "stdev": 105.84068215955527,
        "mean": 99.25,
        "median": 47,
        "mode": [
          258,
          45,
          48,
          46
        ],
        "min": 45,
        "max": 258,
        "listeners": 1,
        "augFns": 0,
        "aliases": 1,
        "timings": [
          258,
          45,
          48,
          46
        ]
      },
      {
        "name": "bolt://node1.cluster.graph.center:7687- CALL dbms.queryJmx('org.neo4j:instance=kernel#0,name=Page cache') YIELD attributes WITH attributes.Faults.value as faults, attributes.EvictionExceptions.value as evictionExceptions, attributes.BytesWritten.value as bytesWritten, attributes.Flushes.value as flushes, attributes.UsageRatio.value as usageRatio, attributes.Evictions.value as evictions, attributes.FileUnmappings.value as fileUnmappings, attributes.BytesRead.value as bytesRead, attributes.FileMappings.value as fileMappings, attributes.HitRatio.value as hitRatio RETURN hitRatio, bytesRead, fileMappings, fileUnmappings, flushes, usageRatio, bytesWritten, faults, evictions, evictionExceptions-[{\"Header\":\"Usage Ratio\",\"accessor\":\"usageRatio\"},{\"Header\":\"Hit Ratio\",\"accessor\":\"hitRatio\"},{\"Header\":\"Read\",\"accessor\":\"bytesRead\"},{\"Header\":\"Written\",\"accessor\":\"bytesWritten\"},{\"Header\":\"Faults\",\"accessor\":\"faults\"},{\"Header\":\"Flushes\",\"accessor\":\"flushes\",\"show\":false},{\"Header\":\"Evictions\",\"accessor\":\"evictions\",\"show\":false},{\"Header\":\"Eviction Except.\",\"accessor\":\"evictionExceptions\",\"show\":false},{\"Header\":\"File Mappings\",\"accessor\":\"fileMappings\",\"show\":false},{\"Header\":\"File Unmappings\",\"accessor\":\"fileUnmappings\",\"show\":false}]}",
        "label": "JMX_PAGE_CACHE",
        "address": "bolt://node1.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 45,
          "usageRatio": 0.9966146092631031,
          "hitRatio": 0.999950430490999,
          "bytesRead": 1517259834,
          "bytesWritten": 3130982711,
          "faults": 484983,
          "flushes": 111632,
          "evictions": 354864,
          "evictionExceptions": 0,
          "fileMappings": 271,
          "fileUnmappings": 172,
          "faultsPerSecond": 0,
          "flushesPerSecond": 0,
          "boltnode1clustergraphcenter7687faultsPerSecond": 0,
          "boltnode1clustergraphcenter7687flushesPerSecond": 0,
          "boltnode1clustergraphcenter7687hitRatio": 0.999950430490999,
          "boltnode1clustergraphcenter7687usageRatio": 0.9966146092631031
        },
        "query": "\n        CALL dbms.queryJmx('org.neo4j:instance=kernel#0,name=Page cache')\n        YIELD attributes \n        WITH \n            attributes.Faults.value as faults, \n            attributes.EvictionExceptions.value as evictionExceptions, \n            attributes.BytesWritten.value as bytesWritten, \n            attributes.Flushes.value as flushes, \n            attributes.UsageRatio.value as usageRatio, \n            attributes.Evictions.value as evictions, \n            attributes.FileUnmappings.value as fileUnmappings, \n            attributes.BytesRead.value as bytesRead, \n            attributes.FileMappings.value as fileMappings, \n            attributes.HitRatio.value as hitRatio \n        RETURN \n            hitRatio, bytesRead, fileMappings, fileUnmappings,\n            flushes, usageRatio, bytesWritten, \n            faults, evictions, evictionExceptions",
        "packets": 2,
        "stdev": 241.83051916579925,
        "mean": 216,
        "median": 216,
        "mode": [
          387,
          45
        ],
        "min": 45,
        "max": 387,
        "listeners": 1,
        "augFns": 1,
        "aliases": 1,
        "timings": [
          387,
          45
        ]
      },
      {
        "name": "bolt://node2.cluster.graph.center:7687- CALL dbms.queryJmx('org.neo4j:instance=kernel#0,name=Page cache') YIELD attributes WITH attributes.Faults.value as faults, attributes.EvictionExceptions.value as evictionExceptions, attributes.BytesWritten.value as bytesWritten, attributes.Flushes.value as flushes, attributes.UsageRatio.value as usageRatio, attributes.Evictions.value as evictions, attributes.FileUnmappings.value as fileUnmappings, attributes.BytesRead.value as bytesRead, attributes.FileMappings.value as fileMappings, attributes.HitRatio.value as hitRatio RETURN hitRatio, bytesRead, fileMappings, fileUnmappings, flushes, usageRatio, bytesWritten, faults, evictions, evictionExceptions-[{\"Header\":\"Usage Ratio\",\"accessor\":\"usageRatio\"},{\"Header\":\"Hit Ratio\",\"accessor\":\"hitRatio\"},{\"Header\":\"Read\",\"accessor\":\"bytesRead\"},{\"Header\":\"Written\",\"accessor\":\"bytesWritten\"},{\"Header\":\"Faults\",\"accessor\":\"faults\"},{\"Header\":\"Flushes\",\"accessor\":\"flushes\",\"show\":false},{\"Header\":\"Evictions\",\"accessor\":\"evictions\",\"show\":false},{\"Header\":\"Eviction Except.\",\"accessor\":\"evictionExceptions\",\"show\":false},{\"Header\":\"File Mappings\",\"accessor\":\"fileMappings\",\"show\":false},{\"Header\":\"File Unmappings\",\"accessor\":\"fileUnmappings\",\"show\":false}]}",
        "label": "JMX_PAGE_CACHE",
        "address": "bolt://node2.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 49,
          "usageRatio": 0.999504621216127,
          "hitRatio": 0.9999824971585151,
          "bytesRead": 5948771461,
          "bytesWritten": 2204912478,
          "faults": 931851,
          "flushes": 20097,
          "evictions": 213565,
          "evictionExceptions": 0,
          "fileMappings": 269,
          "fileUnmappings": 170,
          "faultsPerSecond": 0,
          "flushesPerSecond": 0,
          "boltnode2clustergraphcenter7687faultsPerSecond": 0,
          "boltnode2clustergraphcenter7687flushesPerSecond": 0,
          "boltnode2clustergraphcenter7687hitRatio": 0.9999824971585151,
          "boltnode2clustergraphcenter7687usageRatio": 0.999504621216127
        },
        "query": "\n        CALL dbms.queryJmx('org.neo4j:instance=kernel#0,name=Page cache')\n        YIELD attributes \n        WITH \n            attributes.Faults.value as faults, \n            attributes.EvictionExceptions.value as evictionExceptions, \n            attributes.BytesWritten.value as bytesWritten, \n            attributes.Flushes.value as flushes, \n            attributes.UsageRatio.value as usageRatio, \n            attributes.Evictions.value as evictions, \n            attributes.FileUnmappings.value as fileUnmappings, \n            attributes.BytesRead.value as bytesRead, \n            attributes.FileMappings.value as fileMappings, \n            attributes.HitRatio.value as hitRatio \n        RETURN \n            hitRatio, bytesRead, fileMappings, fileUnmappings,\n            flushes, usageRatio, bytesWritten, \n            faults, evictions, evictionExceptions",
        "packets": 2,
        "stdev": 259.50818869546293,
        "mean": 232.5,
        "median": 232.5,
        "mode": [
          416,
          49
        ],
        "min": 49,
        "max": 416,
        "listeners": 1,
        "augFns": 1,
        "aliases": 1,
        "timings": [
          416,
          49
        ]
      },
      {
        "name": "bolt://node3.cluster.graph.center:7687- CALL dbms.queryJmx('org.neo4j:instance=kernel#0,name=Page cache') YIELD attributes WITH attributes.Faults.value as faults, attributes.EvictionExceptions.value as evictionExceptions, attributes.BytesWritten.value as bytesWritten, attributes.Flushes.value as flushes, attributes.UsageRatio.value as usageRatio, attributes.Evictions.value as evictions, attributes.FileUnmappings.value as fileUnmappings, attributes.BytesRead.value as bytesRead, attributes.FileMappings.value as fileMappings, attributes.HitRatio.value as hitRatio RETURN hitRatio, bytesRead, fileMappings, fileUnmappings, flushes, usageRatio, bytesWritten, faults, evictions, evictionExceptions-[{\"Header\":\"Usage Ratio\",\"accessor\":\"usageRatio\"},{\"Header\":\"Hit Ratio\",\"accessor\":\"hitRatio\"},{\"Header\":\"Read\",\"accessor\":\"bytesRead\"},{\"Header\":\"Written\",\"accessor\":\"bytesWritten\"},{\"Header\":\"Faults\",\"accessor\":\"faults\"},{\"Header\":\"Flushes\",\"accessor\":\"flushes\",\"show\":false},{\"Header\":\"Evictions\",\"accessor\":\"evictions\",\"show\":false},{\"Header\":\"Eviction Except.\",\"accessor\":\"evictionExceptions\",\"show\":false},{\"Header\":\"File Mappings\",\"accessor\":\"fileMappings\",\"show\":false},{\"Header\":\"File Unmappings\",\"accessor\":\"fileUnmappings\",\"show\":false}]}",
        "label": "JMX_PAGE_CACHE",
        "address": "bolt://node3.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 44,
          "usageRatio": 0.9997185242629213,
          "hitRatio": 0.9999860590808174,
          "bytesRead": 8073894993,
          "bytesWritten": 5017963416,
          "faults": 1501813,
          "flushes": 44731,
          "evictions": 457612,
          "evictionExceptions": 0,
          "fileMappings": 276,
          "fileUnmappings": 177,
          "faultsPerSecond": 0,
          "flushesPerSecond": 0,
          "boltnode3clustergraphcenter7687faultsPerSecond": 0,
          "boltnode3clustergraphcenter7687flushesPerSecond": 0,
          "boltnode3clustergraphcenter7687hitRatio": 0.9999860590808174,
          "boltnode3clustergraphcenter7687usageRatio": 0.9997185242629213
        },
        "query": "\n        CALL dbms.queryJmx('org.neo4j:instance=kernel#0,name=Page cache')\n        YIELD attributes \n        WITH \n            attributes.Faults.value as faults, \n            attributes.EvictionExceptions.value as evictionExceptions, \n            attributes.BytesWritten.value as bytesWritten, \n            attributes.Flushes.value as flushes, \n            attributes.UsageRatio.value as usageRatio, \n            attributes.Evictions.value as evictions, \n            attributes.FileUnmappings.value as fileUnmappings, \n            attributes.BytesRead.value as bytesRead, \n            attributes.FileMappings.value as fileMappings, \n            attributes.HitRatio.value as hitRatio \n        RETURN \n            hitRatio, bytesRead, fileMappings, fileUnmappings,\n            flushes, usageRatio, bytesWritten, \n            faults, evictions, evictionExceptions",
        "packets": 2,
        "stdev": 248.19448019647817,
        "mean": 219.5,
        "median": 219.5,
        "mode": [
          395,
          44
        ],
        "min": 44,
        "max": 395,
        "listeners": 1,
        "augFns": 1,
        "aliases": 1,
        "timings": [
          395,
          44
        ]
      },
      {
        "name": "bolt://node1.cluster.graph.center:7687- CALL dbms.queryJmx(\"org.neo4j:instance=kernel#0,name=Transactions\") YIELD attributes WITH attributes as a RETURN a.NumberOfRolledBackTransactions.value as rolledBack, a.NumberOfOpenTransactions.value as open, a.LastCommittedTxId.value as lastCommittedId, a.NumberOfOpenedTransactions.value as opened, a.PeakNumberOfConcurrentTransactions.value as concurrent, a.NumberOfCommittedTransactions.value as committed-[{\"Header\":\"Rolled Back\",\"accessor\":\"rolledBack\"},{\"Header\":\"Open\",\"accessor\":\"open\"},{\"Header\":\"Peak Concurrent\",\"accessor\":\"concurrent\"},{\"Header\":\"Opened\",\"accessor\":\"opened\"},{\"Header\":\"Committed\",\"accessor\":\"committed\"},{\"Header\":\"Last Committed\",\"accessor\":\"lastCommittedId\"}]}",
        "label": "JMX_TRANSACTIONS",
        "address": "bolt://node1.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 65,
          "rolledBack": 116,
          "open": 1,
          "concurrent": 101,
          "opened": 3899555,
          "committed": 3899438,
          "lastCommittedId": 541593,
          "boltnode1clustergraphcenter7687open": 1,
          "boltnode1clustergraphcenter7687committed": 3899438,
          "boltnode1clustergraphcenter7687rolledBack": 116,
          "boltnode1clustergraphcenter7687concurrent": 101
        },
        "query": "\n        CALL dbms.queryJmx(\"org.neo4j:instance=kernel#0,name=Transactions\") \n        YIELD attributes WITH attributes as a \n        RETURN \n            a.NumberOfRolledBackTransactions.value as rolledBack, \n            a.NumberOfOpenTransactions.value as open, \n            a.LastCommittedTxId.value as lastCommittedId, \n            a.NumberOfOpenedTransactions.value as opened, \n            a.PeakNumberOfConcurrentTransactions.value as concurrent, \n            a.NumberOfCommittedTransactions.value as committed",
        "packets": 2,
        "stdev": 331.6330803764908,
        "mean": 299.5,
        "median": 299.5,
        "mode": [
          534,
          65
        ],
        "min": 65,
        "max": 534,
        "listeners": 1,
        "augFns": 1,
        "aliases": 1,
        "timings": [
          534,
          65
        ]
      },
      {
        "name": "bolt://node2.cluster.graph.center:7687- CALL dbms.queryJmx(\"org.neo4j:instance=kernel#0,name=Transactions\") YIELD attributes WITH attributes as a RETURN a.NumberOfRolledBackTransactions.value as rolledBack, a.NumberOfOpenTransactions.value as open, a.LastCommittedTxId.value as lastCommittedId, a.NumberOfOpenedTransactions.value as opened, a.PeakNumberOfConcurrentTransactions.value as concurrent, a.NumberOfCommittedTransactions.value as committed-[{\"Header\":\"Rolled Back\",\"accessor\":\"rolledBack\"},{\"Header\":\"Open\",\"accessor\":\"open\"},{\"Header\":\"Peak Concurrent\",\"accessor\":\"concurrent\"},{\"Header\":\"Opened\",\"accessor\":\"opened\"},{\"Header\":\"Committed\",\"accessor\":\"committed\"},{\"Header\":\"Last Committed\",\"accessor\":\"lastCommittedId\"}]}",
        "label": "JMX_TRANSACTIONS",
        "address": "bolt://node2.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 68,
          "rolledBack": 48,
          "open": 1,
          "concurrent": 102,
          "opened": 3771214,
          "committed": 3771165,
          "lastCommittedId": 541593,
          "boltnode2clustergraphcenter7687open": 1,
          "boltnode2clustergraphcenter7687committed": 3771165,
          "boltnode2clustergraphcenter7687rolledBack": 48,
          "boltnode2clustergraphcenter7687concurrent": 102
        },
        "query": "\n        CALL dbms.queryJmx(\"org.neo4j:instance=kernel#0,name=Transactions\") \n        YIELD attributes WITH attributes as a \n        RETURN \n            a.NumberOfRolledBackTransactions.value as rolledBack, \n            a.NumberOfOpenTransactions.value as open, \n            a.LastCommittedTxId.value as lastCommittedId, \n            a.NumberOfOpenedTransactions.value as opened, \n            a.PeakNumberOfConcurrentTransactions.value as concurrent, \n            a.NumberOfCommittedTransactions.value as committed",
        "packets": 2,
        "stdev": 346.4823227814083,
        "mean": 313,
        "median": 313,
        "mode": [
          558,
          68
        ],
        "min": 68,
        "max": 558,
        "listeners": 1,
        "augFns": 1,
        "aliases": 1,
        "timings": [
          558,
          68
        ]
      },
      {
        "name": "bolt://node3.cluster.graph.center:7687- CALL dbms.queryJmx(\"org.neo4j:instance=kernel#0,name=Transactions\") YIELD attributes WITH attributes as a RETURN a.NumberOfRolledBackTransactions.value as rolledBack, a.NumberOfOpenTransactions.value as open, a.LastCommittedTxId.value as lastCommittedId, a.NumberOfOpenedTransactions.value as opened, a.PeakNumberOfConcurrentTransactions.value as concurrent, a.NumberOfCommittedTransactions.value as committed-[{\"Header\":\"Rolled Back\",\"accessor\":\"rolledBack\"},{\"Header\":\"Open\",\"accessor\":\"open\"},{\"Header\":\"Peak Concurrent\",\"accessor\":\"concurrent\"},{\"Header\":\"Opened\",\"accessor\":\"opened\"},{\"Header\":\"Committed\",\"accessor\":\"committed\"},{\"Header\":\"Last Committed\",\"accessor\":\"lastCommittedId\"}]}",
        "label": "JMX_TRANSACTIONS",
        "address": "bolt://node3.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 68,
          "rolledBack": 126,
          "open": 1,
          "concurrent": 97,
          "opened": 3945436,
          "committed": 3945309,
          "lastCommittedId": 541593,
          "boltnode3clustergraphcenter7687open": 1,
          "boltnode3clustergraphcenter7687committed": 3945309,
          "boltnode3clustergraphcenter7687rolledBack": 126,
          "boltnode3clustergraphcenter7687concurrent": 97
        },
        "query": "\n        CALL dbms.queryJmx(\"org.neo4j:instance=kernel#0,name=Transactions\") \n        YIELD attributes WITH attributes as a \n        RETURN \n            a.NumberOfRolledBackTransactions.value as rolledBack, \n            a.NumberOfOpenTransactions.value as open, \n            a.LastCommittedTxId.value as lastCommittedId, \n            a.NumberOfOpenedTransactions.value as opened, \n            a.PeakNumberOfConcurrentTransactions.value as concurrent, \n            a.NumberOfCommittedTransactions.value as committed",
        "packets": 2,
        "stdev": 344.36100243784864,
        "mean": 311.5,
        "median": 311.5,
        "mode": [
          555,
          68
        ],
        "min": 68,
        "max": 555,
        "listeners": 1,
        "augFns": 1,
        "aliases": 1,
        "timings": [
          555,
          68
        ]
      },
      {
        "name": "bolt://node1.cluster.graph.center:7687- CALL dbms.queryJmx(\"java.lang:type=OperatingSystem\") YIELD attributes WITH attributes.OpenFileDescriptorCount.value as fdOpen, attributes.MaxFileDescriptorCount.value as fdMax RETURN fdOpen, fdMax -[{\"Header\":\"fdOpen\",\"accessor\":\"fdOpen\"},{\"Header\":\"fdMax\",\"accessor\":\"fdMax\"}]}",
        "label": "OS_OPEN_FDS",
        "address": "bolt://node1.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 47,
          "fdOpen": 948,
          "fdMax": 60000,
          "fdUsed": 59052,
          "boltnode1clustergraphcenter7687fdUsed": 59052,
          "boltnode1clustergraphcenter7687fdOpen": 948,
          "boltnode1clustergraphcenter7687fdMax": 60000
        },
        "query": "\n        CALL dbms.queryJmx(\"java.lang:type=OperatingSystem\") \n        YIELD attributes \n        WITH\n            attributes.OpenFileDescriptorCount.value as fdOpen,\n            attributes.MaxFileDescriptorCount.value as fdMax\n        RETURN \n            fdOpen, fdMax\n        ",
        "packets": 2,
        "stdev": 420.72853480599576,
        "mean": 344.5,
        "median": 344.5,
        "mode": [
          642,
          47
        ],
        "min": 47,
        "max": 642,
        "listeners": 1,
        "augFns": 1,
        "aliases": 1,
        "timings": [
          642,
          47
        ]
      },
      {
        "name": "bolt://node2.cluster.graph.center:7687- CALL dbms.queryJmx(\"java.lang:type=OperatingSystem\") YIELD attributes WITH attributes.OpenFileDescriptorCount.value as fdOpen, attributes.MaxFileDescriptorCount.value as fdMax RETURN fdOpen, fdMax -[{\"Header\":\"fdOpen\",\"accessor\":\"fdOpen\"},{\"Header\":\"fdMax\",\"accessor\":\"fdMax\"}]}",
        "label": "OS_OPEN_FDS",
        "address": "bolt://node2.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 49,
          "fdOpen": 951,
          "fdMax": 60000,
          "fdUsed": 59049,
          "boltnode2clustergraphcenter7687fdUsed": 59049,
          "boltnode2clustergraphcenter7687fdOpen": 951,
          "boltnode2clustergraphcenter7687fdMax": 60000
        },
        "query": "\n        CALL dbms.queryJmx(\"java.lang:type=OperatingSystem\") \n        YIELD attributes \n        WITH\n            attributes.OpenFileDescriptorCount.value as fdOpen,\n            attributes.MaxFileDescriptorCount.value as fdMax\n        RETURN \n            fdOpen, fdMax\n        ",
        "packets": 2,
        "stdev": 453.255446740577,
        "mean": 369.5,
        "median": 369.5,
        "mode": [
          690,
          49
        ],
        "min": 49,
        "max": 690,
        "listeners": 1,
        "augFns": 1,
        "aliases": 1,
        "timings": [
          690,
          49
        ]
      },
      {
        "name": "bolt://node3.cluster.graph.center:7687- CALL dbms.queryJmx(\"java.lang:type=OperatingSystem\") YIELD attributes WITH attributes.OpenFileDescriptorCount.value as fdOpen, attributes.MaxFileDescriptorCount.value as fdMax RETURN fdOpen, fdMax -[{\"Header\":\"fdOpen\",\"accessor\":\"fdOpen\"},{\"Header\":\"fdMax\",\"accessor\":\"fdMax\"}]}",
        "label": "OS_OPEN_FDS",
        "address": "bolt://node3.cluster.graph.center:7687",
        "lastObservation": {
          "_sampleTime": 47,
          "fdOpen": 954,
          "fdMax": 60000,
          "fdUsed": 59046,
          "boltnode3clustergraphcenter7687fdUsed": 59046,
          "boltnode3clustergraphcenter7687fdOpen": 954,
          "boltnode3clustergraphcenter7687fdMax": 60000
        },
        "query": "\n        CALL dbms.queryJmx(\"java.lang:type=OperatingSystem\") \n        YIELD attributes \n        WITH\n            attributes.OpenFileDescriptorCount.value as fdOpen,\n            attributes.MaxFileDescriptorCount.value as fdMax\n        RETURN \n            fdOpen, fdMax\n        ",
        "packets": 2,
        "stdev": 440.5275246792191,
        "mean": 358.5,
        "median": 358.5,
        "mode": [
          670,
          47
        ],
        "min": 47,
        "max": 670,
        "listeners": 1,
        "augFns": 1,
        "aliases": 1,
        "timings": [
          670,
          47
        ]
      }
    ],
    "name": "halin",
    "description": "Halin helps you monitor and improve your Neo4j graph",
    "version": "0.7.1",
    "neo4jDesktop": {
      "apiVersion": "^1.2.0"
    },
    "license": "Apache-2.0",
    "icons": [
      {
        "src": "./public/img/halin-icon.png",
        "type": "png"
      }
    ],
    "repository": {
      "type": "git",
      "url": "https://github.com/moxious/halin.git"
    },
    "homepage": "http://halin.graphapp.io/",
    "private": false,
    "dependencies": {
      "@sentry/browser": "^4.4.1",
      "bluebird": "^3.5.3",
      "graph-app-kit": "^1.0.3",
      "lodash": "^4.17.11",
      "mathjs": "^5.4.0",
      "moment": "^2.22.2",
      "neo4j-driver": "^1.7.2",
      "pondjs": "^0.8.9",
      "prop-types": "^15.6.0",
      "react": "^16.6.3",
      "react-d3-components": "^0.9.1",
      "react-dom": "^16.6.3",
      "react-graph-vis": "^1.0.2",
      "react-scripts": "1.0.16",
      "react-sortable-tree": "^2.2.0",
      "react-table": "^6.8.6",
      "react-timeseries-charts": "^0.15.3",
      "ringjs": "^0.0.1",
      "source-map-explorer": "^1.6.0",
      "uri-parser": "^1.0.1",
      "uuid": "^3.3.2",
      "yargs": "^12.0.5"
    },
    "scripts": {
      "analyze": "./node_modules/.bin/source-map-explorer dist/static/js/main.*",
      "start": "./node_modules/.bin/react-scripts start",
      "build": "./node_modules/.bin/react-scripts build",
      "gather": "./node_modules/.bin/babel-node --presets @babel/env,@babel/react --plugins @babel/plugin-proposal-class-properties src/scripts/gather.js",
      "test": "./node_modules/.bin/react-scripts test --env=jsdom",
      "eject": "./node_modules/.bin/react-scripts eject",
      "postbuild": "rm -rf dist && mv build dist",
      "prepublishOnly": "npm run build"
    },
    "devDependencies": {
      "@babel/cli": "^7.2.0",
      "@babel/core": "^7.2.0",
      "@babel/node": "^7.2.0",
      "@babel/plugin-proposal-class-properties": "^7.2.1",
      "@babel/preset-env": "^7.2.0",
      "@babel/preset-react": "^7.0.0"
    }
  },
  "databases": [],
  "nodes": [
    {
      "basics": {
        "address": "bolt://node1.cluster.graph.center:7687",
        "procotols": [
          "bolt",
          "http",
          "https"
        ],
        "role": "FOLLOWER",
        "database": "default",
        "id": "414afeff-ddb5-4d34-b6b9-ae400e57a7f3",
        "label": "node1",
        "dbms": {
          "name": "Neo4j Kernel",
          "versions": [
            "3.5.0"
          ],
          "edition": "enterprise",
          "nativeAuth": true,
          "authEnabled": "true"
        },
        "performance": {
          "stdev": 162.69736620798292,
          "mean": 128.45833333333334,
          "median": 50.5,
          "mode": [
            45,
            46
          ],
          "min": 43,
          "max": 642,
          "errors": {},
          "observations": [
            {
              "x": "2019-03-03T01:17:29.821Z",
              "y": 52
            },
            {
              "x": "2019-03-03T01:17:30.844Z",
              "y": 57
            },
            {
              "x": "2019-03-03T01:17:30.980Z",
              "y": 80
            },
            {
              "x": "2019-03-03T01:17:31.045Z",
              "y": 143
            },
            {
              "x": "2019-03-03T01:17:31.145Z",
              "y": 242
            },
            {
              "x": "2019-03-03T01:17:31.291Z",
              "y": 387
            },
            {
              "x": "2019-03-03T01:17:31.441Z",
              "y": 534
            },
            {
              "x": "2019-03-03T01:17:31.551Z",
              "y": 642
            },
            {
              "x": "2019-03-03T01:17:31.890Z",
              "y": 45
            },
            {
              "x": "2019-03-03T01:17:32.027Z",
              "y": 46
            },
            {
              "x": "2019-03-03T01:17:32.161Z",
              "y": 113
            },
            {
              "x": "2019-03-03T01:17:32.191Z",
              "y": 44
            },
            {
              "x": "2019-03-03T01:17:32.937Z",
              "y": 46
            },
            {
              "x": "2019-03-03T01:17:33.076Z",
              "y": 49
            },
            {
              "x": "2019-03-03T01:17:33.238Z",
              "y": 44
            },
            {
              "x": "2019-03-03T01:17:33.270Z",
              "y": 107
            },
            {
              "x": "2019-03-03T01:17:33.341Z",
              "y": 45
            },
            {
              "x": "2019-03-03T01:17:33.508Z",
              "y": 65
            },
            {
              "x": "2019-03-03T01:17:33.599Z",
              "y": 47
            },
            {
              "x": "2019-03-03T01:17:33.986Z",
              "y": 45
            },
            {
              "x": "2019-03-03T01:17:34.125Z",
              "y": 47
            },
            {
              "x": "2019-03-03T01:17:34.281Z",
              "y": 43
            },
            {
              "x": "2019-03-03T01:17:34.384Z",
              "y": 114
            },
            {
              "x": "2019-03-03T01:17:34.868Z",
              "y": 46
            }
          ]
        }
      },
      "users": [
        {
          "username": "neo4j",
          "flags": [],
          "roles": [
            "admin"
          ]
        },
        {
          "username": "reader",
          "flags": [],
          "roles": [
            "reader"
          ]
        },
        {
          "username": "testevent",
          "flags": [],
          "roles": []
        },
        {
          "username": "arepa",
          "flags": [],
          "roles": []
        },
        {
          "username": "onlyhere",
          "flags": [],
          "roles": []
        },
        {
          "username": "ship",
          "flags": [],
          "roles": [
            "architect",
            "halindemo",
            "reader"
          ]
        },
        {
          "username": "test-newuser",
          "flags": [],
          "roles": [
            "halindemo",
            "testnewrole",
            "testy35role"
          ]
        },
        {
          "username": "abk",
          "flags": [],
          "roles": [
            "graphconnect"
          ]
        },
        {
          "username": "halin",
          "flags": [],
          "roles": [
            "reader"
          ]
        }
      ],
      "roles": [
        {
          "role": "aa",
          "users": []
        },
        {
          "role": "editor",
          "users": []
        },
        {
          "role": "testy35role",
          "users": [
            "test-newuser"
          ]
        },
        {
          "role": "reader",
          "users": [
            "halin",
            "reader",
            "ship"
          ]
        },
        {
          "role": "architect",
          "users": [
            "ship"
          ]
        },
        {
          "role": "admin",
          "users": [
            "neo4j"
          ]
        },
        {
          "role": "onlyhere",
          "users": []
        },
        {
          "role": "Node2Role",
          "users": []
        },
        {
          "role": "testnewrole",
          "users": [
            "test-newuser"
          ]
        },
        {
          "role": "halindemo",
          "users": [
            "ship",
            "test-newuser"
          ]
        },
        {
          "role": "graphconnect",
          "users": [
            "abk"
          ]
        },
        {
          "role": "publisher",
          "users": []
        },
        {
          "role": "testrole4",
          "users": []
        }
      ],
      "indexes": [
        {
          "description": "INDEX ON :Address(city)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "city"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(cityPrefix)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "cityPrefix"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(country)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "country"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(countryCode)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "countryCode"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(county)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "county"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(created)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "created"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(location)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "location"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(score)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "score"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(secondaryAddress)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "secondaryAddress"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(state)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "state"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(stateAbbr)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "stateAbbr"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(streetAddress)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "streetAddress"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(streetName)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "streetName"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(streetPrefix)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "streetPrefix"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(zip)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "zip"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Chord(name)",
          "label": null,
          "tokenNames": [
            "Chord"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :ChordInstance(name)",
          "label": null,
          "tokenNames": [
            "ChordInstance"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Customer(created)",
          "label": null,
          "tokenNames": [
            "Customer"
          ],
          "properties": [
            "created"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Customer(email)",
          "label": null,
          "tokenNames": [
            "Customer"
          ],
          "properties": [
            "email"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Customer(id)",
          "label": null,
          "tokenNames": [
            "Customer"
          ],
          "properties": [
            "id"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Customer(name)",
          "label": null,
          "tokenNames": [
            "Customer"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Customer(score)",
          "label": null,
          "tokenNames": [
            "Customer"
          ],
          "properties": [
            "score"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Customer(username)",
          "label": null,
          "tokenNames": [
            "Customer"
          ],
          "properties": [
            "username"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :FatNode(data)",
          "label": null,
          "tokenNames": [
            "FatNode"
          ],
          "properties": [
            "data"
          ],
          "state": "FAILED",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Hashtag(name)",
          "label": null,
          "tokenNames": [
            "Hashtag"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Interval(name)",
          "label": null,
          "tokenNames": [
            "Interval"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Leaf(val)",
          "label": null,
          "tokenNames": [
            "Leaf"
          ],
          "properties": [
            "val"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :MergeNode(id)",
          "label": null,
          "tokenNames": [
            "MergeNode"
          ],
          "properties": [
            "id"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :NAryTree(val)",
          "label": null,
          "tokenNames": [
            "NAryTree"
          ],
          "properties": [
            "val"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Node(id)",
          "label": null,
          "tokenNames": [
            "Node"
          ],
          "properties": [
            "id"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :P(id)",
          "label": null,
          "tokenNames": [
            "P"
          ],
          "properties": [
            "id"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Rando(id)",
          "label": null,
          "tokenNames": [
            "Rando"
          ],
          "properties": [
            "id"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Scale(name)",
          "label": null,
          "tokenNames": [
            "Scale"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :ScaleInstance(name)",
          "label": null,
          "tokenNames": [
            "ScaleInstance"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Tone(name)",
          "label": null,
          "tokenNames": [
            "Tone"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Tweet(text)",
          "label": null,
          "tokenNames": [
            "Tweet"
          ],
          "properties": [
            "text"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :User(name)",
          "label": null,
          "tokenNames": [
            "User"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Fictional(id)",
          "label": null,
          "tokenNames": [
            "Fictional"
          ],
          "properties": [
            "id"
          ],
          "state": "ONLINE",
          "type": "node_unique_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        }
      ],
      "constraints": [
        {
          "idx": 0,
          "description": "CONSTRAINT ON ( fictional:Fictional ) ASSERT (fictional.id) IS NODE KEY"
        }
      ],
      "JMX": [
        {
          "name": "org.neo4j:instance=kernel#0,name=Kernel",
          "attributes": {
            "KernelVersion": {
              "description": "The version of Neo4j",
              "value": "neo4j-kernel, version: 3.5.0,78fb2c3fb974d4cc4ce4a7803283e2eb776305ff"
            },
            "ReadOnly": {
              "description": "Whether this is a read only instance",
              "value": false
            },
            "StoreId": {
              "description": "An identifier that, together with store creation time, uniquely identifies this Neo4j graph store.",
              "value": "4c06975e6b81247d"
            },
            "KernelStartTime": {
              "description": "The time from which this Neo4j instance was in operational mode.",
              "value": 1547135280150
            },
            "DatabaseName": {
              "description": "The name of the mounted database",
              "value": "graph.db"
            },
            "MBeanQuery": {
              "description": "An ObjectName that can be used as a query for getting all management beans for this Neo4j instance.",
              "value": "org.neo4j:instance=kernel#0,name=*"
            },
            "StoreLogVersion": {
              "description": "The current version of the Neo4j store logical log.",
              "value": 49
            },
            "StoreCreationDate": {
              "description": "The time when this Neo4j graph store was created.",
              "value": 1537200614306
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Causal Clustering",
          "attributes": {
            "Role": {
              "description": "The current role this member has in the cluster",
              "value": "FOLLOWER"
            },
            "ReplicatedStateSize": {
              "description": "The total amount of disk space used by the replicated states, in bytes",
              "value": 16710
            },
            "RaftLogSize": {
              "description": "The total amount of disk space used by the raft log, in bytes",
              "value": 1234132140
            }
          }
        },
        {
          "name": "JMImplementation:type=MBeanServerDelegate",
          "attributes": {
            "ImplementationName": {
              "description": "The JMX implementation name (the name of this product)",
              "value": "JMX"
            },
            "MBeanServerId": {
              "description": "The MBean server agent identification",
              "value": "meetup-cluster-core-vm-1_1547135244834"
            },
            "ImplementationVersion": {
              "description": "The JMX implementation version (the version of this product).",
              "value": "1.8.0_191-8u191-b12-0ubuntu0.16.04.1-b12"
            },
            "SpecificationVersion": {
              "description": "The version of the JMX specification implemented by this product.",
              "value": "1.4"
            },
            "SpecificationVendor": {
              "description": "The vendor of the JMX specification implemented by this product.",
              "value": "Oracle Corporation"
            },
            "SpecificationName": {
              "description": "The full name of the JMX specification implemented by this product.",
              "value": "Java Management Extensions"
            },
            "ImplementationVendor": {
              "description": "the JMX implementation vendor (the vendor of this product).",
              "value": "Oracle Corporation"
            }
          }
        },
        {
          "name": "java.lang:type=Runtime",
          "attributes": {
            "SpecVendor": {
              "description": "SpecVendor",
              "value": "Oracle Corporation"
            },
            "ClassPath": {
              "description": "ClassPath",
              "value": "/var/lib/neo4j/plugins:/etc/neo4j:/usr/share/neo4j/lib/concurrentlinkedhashmap-lru-1.4.2.jar:/usr/share/neo4j/lib/ssl-config-core_2.11-0.2.3.jar:/usr/share/neo4j/lib/jersey-core-1.19.3.jar:/usr/share/neo4j/lib/neo4j-auth-plugin-api-3.5.0.jar:/usr/share/neo4j/lib/jetty-util-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-fulltext-index-3.5.0.jar:/usr/share/neo4j/lib/neo4j-com-3.5.0.jar:/usr/share/neo4j/lib/akka-actor_2.11-2.5.14.jar:/usr/share/neo4j/lib/config-1.3.3.jar:/usr/share/neo4j/lib/ast-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/akka-protobuf_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-diagnostics-3.5.0.jar:/usr/share/neo4j/lib/jetty-webapp-9.4.11.v20180605.jar:/usr/share/neo4j/lib/jProcesses-1.6.4.jar:/usr/share/neo4j/lib/jetty-servlet-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-graphdb-api-3.5.0.jar:/usr/share/neo4j/lib/jsr311-api-1.1.2.r612.jar:/usr/share/neo4j/lib/neo4j-resource-3.5.0.jar:/usr/share/neo4j/lib/jaxb-core-2.3.0.1.jar:/usr/share/neo4j/lib/neo4j-cypher-ir-3.5-3.5.0.jar:/usr/share/neo4j/lib/bcprov-jdk15on-1.60.jar:/usr/share/neo4j/lib/neo4j-management-3.5.0.jar:/usr/share/neo4j/lib/jackson-mapper-asl-1.9.13.jar:/usr/share/neo4j/lib/jetty-security-9.4.11.v20180605.jar:/usr/share/neo4j/lib/jackson-jaxrs-1.9.13.jar:/usr/share/neo4j/lib/neo4j-command-line-3.5.0.jar:/usr/share/neo4j/lib/neo4j-ha-3.5.0.jar:/usr/share/neo4j/lib/jaxb-api-2.3.0.jar:/usr/share/neo4j/lib/shiro-crypto-cipher-1.4.0.jar:/usr/share/neo4j/lib/neo4j-server-enterprise-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-util-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-cypher-compiled-expressions-3.5.0.jar:/usr/share/neo4j/lib/neo4j-server-3.5.0.jar:/usr/share/neo4j/lib/neo4j-io-3.5.0.jar:/usr/share/neo4j/lib/scala-parser-combinators_2.11-1.1.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-spi-3.5-3.5.0.jar:/usr/share/neo4j/lib/shiro-core-1.4.0.jar:/usr/share/neo4j/lib/jline-2.14.3.jar:/usr/share/neo4j/lib/scallop_2.11-2.1.1.jar:/usr/share/neo4j/lib/txw2-2.3.0.1.jar:/usr/share/neo4j/lib/istack-commons-runtime-3.0.5.jar:/usr/share/neo4j/lib/akka-cluster_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-common-3.5.0.jar:/usr/share/neo4j/lib/neo4j-server-commercial-3.5.0.jar:/usr/share/neo4j/lib/util-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/opencsv-2.3.jar:/usr/share/neo4j/lib/neo4j-index-3.5.0.jar:/usr/share/neo4j/lib/jetty-server-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-concurrent-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-kernel-api-3.5.0.jar:/usr/share/neo4j/lib/asm-analysis-6.2.jar:/usr/share/neo4j/lib/neo4j-security-enterprise-3.5.0.jar:/usr/share/neo4j/lib/neo4j-causal-clustering-3.5.0.jar:/usr/share/neo4j/lib/neo4j-dbms-3.5.0.jar:/usr/share/neo4j/lib/parser-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/neo4j-cypher-frontend-2.3-2.3.12.jar:/usr/share/neo4j/lib/neo4j-values-3.5.0.jar:/usr/share/neo4j/lib/netty-3.9.9.Final.jar:/usr/share/neo4j/lib/neo4j-cypher-slotted-runtime-3.5.0.jar:/usr/share/neo4j/lib/akka-cluster-tools_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-cypher-3.5.0.jar:/usr/share/neo4j/lib/commons-configuration-1.10.jar:/usr/share/neo4j/lib/bcpkix-jdk15on-1.60.jar:/usr/share/neo4j/lib/commons-lang-2.6.jar:/usr/share/neo4j/lib/server-api-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-compiler-3.1-3.1.9.jar:/usr/share/neo4j/lib/neo4j-enterprise-kernel-3.5.0.jar:/usr/share/neo4j/lib/shiro-config-core-1.4.0.jar:/usr/share/neo4j/lib/neo4j-unsafe-3.5.0.jar:/usr/share/neo4j/lib/asm-tree-6.2.jar:/usr/share/neo4j/lib/jaxb-runtime-2.3.0.1.jar:/usr/share/neo4j/lib/stax-ex-1.7.8.jar:/usr/share/neo4j/lib/neo4j-csv-3.5.0.jar:/usr/share/neo4j/lib/neo4j-kernel-3.5.0.jar:/usr/share/neo4j/lib/shiro-crypto-hash-1.4.0.jar:/usr/share/neo4j/lib/jetty-io-9.4.11.v20180605.jar:/usr/share/neo4j/lib/jackson-core-asl-1.9.13.jar:/usr/share/neo4j/lib/jersey-server-1.19.3.jar:/usr/share/neo4j/lib/akka-stream_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-cypher-runtime-util-3.5.0.jar:/usr/share/neo4j/lib/shiro-event-1.4.0.jar:/usr/share/neo4j/lib/jersey-servlet-1.19.3.jar:/usr/share/neo4j/lib/WMI4Java-1.6.1.jar:/usr/share/neo4j/lib/hazelcast-all-3.7.8.jar:/usr/share/neo4j/lib/metrics-core-4.0.2.jar:/usr/share/neo4j/lib/parboiled-core-1.1.7.jar:/usr/share/neo4j/lib/neo4j-spatial-index-3.5.0.jar:/usr/share/neo4j/lib/rewriting-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/neo4j-udc-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-physical-planning-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-3.5-3.5.0.jar:/usr/share/neo4j/lib/neo4j-codegen-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-morsel-runtime-3.5.0.jar:/usr/share/neo4j/lib/reactive-streams-1.0.2.jar:/usr/share/neo4j/lib/neo4j-import-tool-3.5.0.jar:/usr/share/neo4j/lib/akka-remote_2.11-2.5.14.jar:/usr/share/neo4j/lib/lucene-analyzers-common-5.5.5.jar:/usr/share/neo4j/lib/neo4j-logging-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-logical-plans-3.5-3.5.0.jar:/usr/share/neo4j/lib/front-end-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/scala-java8-compat_2.11-0.7.0.jar:/usr/share/neo4j/lib/parboiled-scala_2.11-1.1.7.jar:/usr/share/neo4j/lib/simpleclient_httpserver-0.4.0.jar:/usr/share/neo4j/lib/neo4j-query-logging-3.5.0.jar:/usr/share/neo4j/lib/commons-text-1.4.jar:/usr/share/neo4j/lib/simpleclient-0.4.0.jar:/usr/share/neo4j/lib/lucene-core-5.5.5.jar:/usr/share/neo4j/lib/netty-all-4.1.30.Final.jar:/usr/share/neo4j/lib/neo4j-causal-clustering-commercial-3.5.0.jar:/usr/share/neo4j/lib/slf4j-api-1.7.25.jar:/usr/share/neo4j/lib/commons-collections-3.2.2.jar:/usr/share/neo4j/lib/neo4j-lucene-upgrade-3.5.0.jar:/usr/share/neo4j/lib/eclipse-collections-9.2.0.jar:/usr/share/neo4j/lib/neo4j-consistency-check-3.5.0.jar:/usr/share/neo4j/lib/neo4j-kernel-commercial-3.5.0.jar:/usr/share/neo4j/lib/neo4j-backup-3.5.0.jar:/usr/share/neo4j/lib/neo4j-configuration-3.5.0.jar:/usr/share/neo4j/lib/neo4j-commercial-3.5.0.jar:/usr/share/neo4j/lib/neo4j-security-3.5.0.jar:/usr/share/neo4j/lib/commons-compress-1.18.jar:/usr/share/neo4j/lib/kiama_2.11-2.1.0.jar:/usr/share/neo4j/lib/neo4j-cypher-frontend-3.1-3.1.9.jar:/usr/share/neo4j/lib/neo4j-cypher-ir-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-cypher-logical-plans-3.4-3.4.9.jar:/usr/share/neo4j/lib/eclipse-collections-api-9.2.0.jar:/usr/share/neo4j/lib/neo4j-security-commercial-3.5.0.jar:/usr/share/neo4j/lib/openCypher-frontend-1-3.4.9.jar:/usr/share/neo4j/lib/simpleclient_common-0.4.0.jar:/usr/share/neo4j/lib/commons-logging-1.1.1.jar:/usr/share/neo4j/lib/commons-beanutils-1.9.3.jar:/usr/share/neo4j/lib/caffeine-2.6.2.jar:/usr/share/neo4j/lib/neo4j-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-compiler-2.3-2.3.12.jar:/usr/share/neo4j/lib/aeron-client-1.9.1.jar:/usr/share/neo4j/lib/metrics-graphite-4.0.2.jar:/usr/share/neo4j/lib/activation-1.1.1.jar:/usr/share/neo4j/lib/expressions-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/jetty-client-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-jmx-3.5.0.jar:/usr/share/neo4j/lib/neo4j-browser-3.2.13.jar:/usr/share/neo4j/lib/neo4j-graph-algo-3.5.0.jar:/usr/share/neo4j/lib/neo4j-graph-matching-3.1.9.jar:/usr/share/neo4j/lib/neo4j-cluster-3.5.0.jar:/usr/share/neo4j/lib/neo4j-collections-3.5.0.jar:/usr/share/neo4j/lib/lz4-1.3.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-spi-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-lucene-index-3.5.0.jar:/usr/share/neo4j/lib/FastInfoset-1.2.13.jar:/usr/share/neo4j/lib/shiro-lang-1.4.0.jar:/usr/share/neo4j/lib/commons-io-2.6.jar:/usr/share/neo4j/lib/neo4j-cypher-interpreted-runtime-3.5.0.jar:/usr/share/neo4j/lib/simpleclient_dropwizard-0.4.0.jar:/usr/share/neo4j/lib/neo4j-legacy-3.5.0.jar:/usr/share/neo4j/lib/scala-reflect-2.11.12.jar:/usr/share/neo4j/lib/agrona-0.9.17.jar:/usr/share/neo4j/lib/shiro-crypto-core-1.4.0.jar:/usr/share/neo4j/lib/neo4j-enterprise-cypher-3.5.0.jar:/usr/share/neo4j/lib/akka-distributed-data_2.11-2.5.14.jar:/usr/share/neo4j/lib/shiro-config-ogdl-1.4.0.jar:/usr/share/neo4j/lib/asm-util-6.2.jar:/usr/share/neo4j/lib/jetty-http-9.4.11.v20180605.jar:/usr/share/neo4j/lib/lucene-codecs-5.5.5.jar:/usr/share/neo4j/lib/neo4j-bolt-3.5.0.jar:/usr/share/neo4j/lib/lucene-queryparser-5.5.5.jar:/usr/share/neo4j/lib/scala-library-2.11.12.jar:/usr/share/neo4j/lib/neo4j-ssl-3.5.0.jar:/usr/share/neo4j/lib/jetty-xml-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-procedure-api-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-expression-3.4-3.4.9.jar:/usr/share/neo4j/lib/jPowerShell-1.9.jar:/usr/share/neo4j/lib/shiro-cache-1.4.0.jar:/usr/share/neo4j/lib/javax.servlet-api-3.1.0.jar:/usr/share/neo4j/lib/neo4j-metrics-3.5.0.jar:/usr/share/neo4j/lib/slf4j-nop-1.7.25.jar:/usr/share/neo4j/lib/commons-lang3-3.8.jar:/usr/share/neo4j/lib/asm-6.2.jar:/usr/share/neo4j/lib/aeron-driver-1.9.1.jar:/var/lib/neo4j/plugins/*"
            },
            "InputArguments": {
              "description": "InputArguments",
              "value": [
                "-Xms4900m",
                "-Xmx5000m",
                "-XX:+UseG1GC",
                "-XX:-OmitStackTraceInFastThrow",
                "-XX:+AlwaysPreTouch",
                "-XX:+UnlockExperimentalVMOptions",
                "-XX:+TrustFinalNonStaticFields",
                "-XX:+DisableExplicitGC",
                "-Djdk.tls.ephemeralDHKeySize=2048",
                "-Djdk.tls.rejectClientInitiatedRenegotiation=true",
                "-Dunsupported.dbms.udc.source=gcloud-CORE",
                "-Dfile.encoding=UTF-8"
              ]
            },
            "Uptime": {
              "description": "Uptime",
              "value": 4440628633
            },
            "VmName": {
              "description": "VmName",
              "value": "OpenJDK 64-Bit Server VM"
            },
            "StartTime": {
              "description": "StartTime",
              "value": 1547135236488
            },
            "SpecName": {
              "description": "SpecName",
              "value": "Java Virtual Machine Specification"
            },
            "VmVersion": {
              "description": "VmVersion",
              "value": "25.191-b12"
            },
            "ManagementSpecVersion": {
              "description": "ManagementSpecVersion",
              "value": "1.2"
            },
            "Name": {
              "description": "Name",
              "value": "27284@meetup-cluster-core-vm-1"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:type=Runtime"
            },
            "VmVendor": {
              "description": "VmVendor",
              "value": "Oracle Corporation"
            },
            "LibraryPath": {
              "description": "LibraryPath",
              "value": "/usr/java/packages/lib/amd64:/usr/lib/x86_64-linux-gnu/jni:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/usr/lib/jni:/lib:/usr/lib"
            },
            "BootClassPath": {
              "description": "BootClassPath",
              "value": "/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/rt.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jfr.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/classes"
            },
            "SpecVersion": {
              "description": "SpecVersion",
              "value": "1.8"
            },
            "SystemProperties": {
              "description": "SystemProperties",
              "value": {
                "[sun.io.unicode.encoding]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "UnicodeLittle",
                    "key": "sun.io.unicode.encoding"
                  }
                },
                "[awt.toolkit]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "sun.awt.X11.XToolkit",
                    "key": "awt.toolkit"
                  }
                },
                "[sun.java.command]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "com.neo4j.server.enterprise.CommercialEntryPoint --home-dir=/var/lib/neo4j --config-dir=/etc/neo4j",
                    "key": "sun.java.command"
                  }
                },
                "[file.separator]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/",
                    "key": "file.separator"
                  }
                },
                "[sun.arch.data.model]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "64",
                    "key": "sun.arch.data.model"
                  }
                },
                "[java.vm.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "25.191-b12",
                    "key": "java.vm.version"
                  }
                },
                "[java.class.path]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/var/lib/neo4j/plugins:/etc/neo4j:/usr/share/neo4j/lib/concurrentlinkedhashmap-lru-1.4.2.jar:/usr/share/neo4j/lib/ssl-config-core_2.11-0.2.3.jar:/usr/share/neo4j/lib/jersey-core-1.19.3.jar:/usr/share/neo4j/lib/neo4j-auth-plugin-api-3.5.0.jar:/usr/share/neo4j/lib/jetty-util-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-fulltext-index-3.5.0.jar:/usr/share/neo4j/lib/neo4j-com-3.5.0.jar:/usr/share/neo4j/lib/akka-actor_2.11-2.5.14.jar:/usr/share/neo4j/lib/config-1.3.3.jar:/usr/share/neo4j/lib/ast-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/akka-protobuf_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-diagnostics-3.5.0.jar:/usr/share/neo4j/lib/jetty-webapp-9.4.11.v20180605.jar:/usr/share/neo4j/lib/jProcesses-1.6.4.jar:/usr/share/neo4j/lib/jetty-servlet-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-graphdb-api-3.5.0.jar:/usr/share/neo4j/lib/jsr311-api-1.1.2.r612.jar:/usr/share/neo4j/lib/neo4j-resource-3.5.0.jar:/usr/share/neo4j/lib/jaxb-core-2.3.0.1.jar:/usr/share/neo4j/lib/neo4j-cypher-ir-3.5-3.5.0.jar:/usr/share/neo4j/lib/bcprov-jdk15on-1.60.jar:/usr/share/neo4j/lib/neo4j-management-3.5.0.jar:/usr/share/neo4j/lib/jackson-mapper-asl-1.9.13.jar:/usr/share/neo4j/lib/jetty-security-9.4.11.v20180605.jar:/usr/share/neo4j/lib/jackson-jaxrs-1.9.13.jar:/usr/share/neo4j/lib/neo4j-command-line-3.5.0.jar:/usr/share/neo4j/lib/neo4j-ha-3.5.0.jar:/usr/share/neo4j/lib/jaxb-api-2.3.0.jar:/usr/share/neo4j/lib/shiro-crypto-cipher-1.4.0.jar:/usr/share/neo4j/lib/neo4j-server-enterprise-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-util-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-cypher-compiled-expressions-3.5.0.jar:/usr/share/neo4j/lib/neo4j-server-3.5.0.jar:/usr/share/neo4j/lib/neo4j-io-3.5.0.jar:/usr/share/neo4j/lib/scala-parser-combinators_2.11-1.1.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-spi-3.5-3.5.0.jar:/usr/share/neo4j/lib/shiro-core-1.4.0.jar:/usr/share/neo4j/lib/jline-2.14.3.jar:/usr/share/neo4j/lib/scallop_2.11-2.1.1.jar:/usr/share/neo4j/lib/txw2-2.3.0.1.jar:/usr/share/neo4j/lib/istack-commons-runtime-3.0.5.jar:/usr/share/neo4j/lib/akka-cluster_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-common-3.5.0.jar:/usr/share/neo4j/lib/neo4j-server-commercial-3.5.0.jar:/usr/share/neo4j/lib/util-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/opencsv-2.3.jar:/usr/share/neo4j/lib/neo4j-index-3.5.0.jar:/usr/share/neo4j/lib/jetty-server-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-concurrent-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-kernel-api-3.5.0.jar:/usr/share/neo4j/lib/asm-analysis-6.2.jar:/usr/share/neo4j/lib/neo4j-security-enterprise-3.5.0.jar:/usr/share/neo4j/lib/neo4j-causal-clustering-3.5.0.jar:/usr/share/neo4j/lib/neo4j-dbms-3.5.0.jar:/usr/share/neo4j/lib/parser-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/neo4j-cypher-frontend-2.3-2.3.12.jar:/usr/share/neo4j/lib/neo4j-values-3.5.0.jar:/usr/share/neo4j/lib/netty-3.9.9.Final.jar:/usr/share/neo4j/lib/neo4j-cypher-slotted-runtime-3.5.0.jar:/usr/share/neo4j/lib/akka-cluster-tools_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-cypher-3.5.0.jar:/usr/share/neo4j/lib/commons-configuration-1.10.jar:/usr/share/neo4j/lib/bcpkix-jdk15on-1.60.jar:/usr/share/neo4j/lib/commons-lang-2.6.jar:/usr/share/neo4j/lib/server-api-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-compiler-3.1-3.1.9.jar:/usr/share/neo4j/lib/neo4j-enterprise-kernel-3.5.0.jar:/usr/share/neo4j/lib/shiro-config-core-1.4.0.jar:/usr/share/neo4j/lib/neo4j-unsafe-3.5.0.jar:/usr/share/neo4j/lib/asm-tree-6.2.jar:/usr/share/neo4j/lib/jaxb-runtime-2.3.0.1.jar:/usr/share/neo4j/lib/stax-ex-1.7.8.jar:/usr/share/neo4j/lib/neo4j-csv-3.5.0.jar:/usr/share/neo4j/lib/neo4j-kernel-3.5.0.jar:/usr/share/neo4j/lib/shiro-crypto-hash-1.4.0.jar:/usr/share/neo4j/lib/jetty-io-9.4.11.v20180605.jar:/usr/share/neo4j/lib/jackson-core-asl-1.9.13.jar:/usr/share/neo4j/lib/jersey-server-1.19.3.jar:/usr/share/neo4j/lib/akka-stream_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-cypher-runtime-util-3.5.0.jar:/usr/share/neo4j/lib/shiro-event-1.4.0.jar:/usr/share/neo4j/lib/jersey-servlet-1.19.3.jar:/usr/share/neo4j/lib/WMI4Java-1.6.1.jar:/usr/share/neo4j/lib/hazelcast-all-3.7.8.jar:/usr/share/neo4j/lib/metrics-core-4.0.2.jar:/usr/share/neo4j/lib/parboiled-core-1.1.7.jar:/usr/share/neo4j/lib/neo4j-spatial-index-3.5.0.jar:/usr/share/neo4j/lib/rewriting-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/neo4j-udc-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-physical-planning-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-3.5-3.5.0.jar:/usr/share/neo4j/lib/neo4j-codegen-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-morsel-runtime-3.5.0.jar:/usr/share/neo4j/lib/reactive-streams-1.0.2.jar:/usr/share/neo4j/lib/neo4j-import-tool-3.5.0.jar:/usr/share/neo4j/lib/akka-remote_2.11-2.5.14.jar:/usr/share/neo4j/lib/lucene-analyzers-common-5.5.5.jar:/usr/share/neo4j/lib/neo4j-logging-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-logical-plans-3.5-3.5.0.jar:/usr/share/neo4j/lib/front-end-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/scala-java8-compat_2.11-0.7.0.jar:/usr/share/neo4j/lib/parboiled-scala_2.11-1.1.7.jar:/usr/share/neo4j/lib/simpleclient_httpserver-0.4.0.jar:/usr/share/neo4j/lib/neo4j-query-logging-3.5.0.jar:/usr/share/neo4j/lib/commons-text-1.4.jar:/usr/share/neo4j/lib/simpleclient-0.4.0.jar:/usr/share/neo4j/lib/lucene-core-5.5.5.jar:/usr/share/neo4j/lib/netty-all-4.1.30.Final.jar:/usr/share/neo4j/lib/neo4j-causal-clustering-commercial-3.5.0.jar:/usr/share/neo4j/lib/slf4j-api-1.7.25.jar:/usr/share/neo4j/lib/commons-collections-3.2.2.jar:/usr/share/neo4j/lib/neo4j-lucene-upgrade-3.5.0.jar:/usr/share/neo4j/lib/eclipse-collections-9.2.0.jar:/usr/share/neo4j/lib/neo4j-consistency-check-3.5.0.jar:/usr/share/neo4j/lib/neo4j-kernel-commercial-3.5.0.jar:/usr/share/neo4j/lib/neo4j-backup-3.5.0.jar:/usr/share/neo4j/lib/neo4j-configuration-3.5.0.jar:/usr/share/neo4j/lib/neo4j-commercial-3.5.0.jar:/usr/share/neo4j/lib/neo4j-security-3.5.0.jar:/usr/share/neo4j/lib/commons-compress-1.18.jar:/usr/share/neo4j/lib/kiama_2.11-2.1.0.jar:/usr/share/neo4j/lib/neo4j-cypher-frontend-3.1-3.1.9.jar:/usr/share/neo4j/lib/neo4j-cypher-ir-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-cypher-logical-plans-3.4-3.4.9.jar:/usr/share/neo4j/lib/eclipse-collections-api-9.2.0.jar:/usr/share/neo4j/lib/neo4j-security-commercial-3.5.0.jar:/usr/share/neo4j/lib/openCypher-frontend-1-3.4.9.jar:/usr/share/neo4j/lib/simpleclient_common-0.4.0.jar:/usr/share/neo4j/lib/commons-logging-1.1.1.jar:/usr/share/neo4j/lib/commons-beanutils-1.9.3.jar:/usr/share/neo4j/lib/caffeine-2.6.2.jar:/usr/share/neo4j/lib/neo4j-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-compiler-2.3-2.3.12.jar:/usr/share/neo4j/lib/aeron-client-1.9.1.jar:/usr/share/neo4j/lib/metrics-graphite-4.0.2.jar:/usr/share/neo4j/lib/activation-1.1.1.jar:/usr/share/neo4j/lib/expressions-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/jetty-client-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-jmx-3.5.0.jar:/usr/share/neo4j/lib/neo4j-browser-3.2.13.jar:/usr/share/neo4j/lib/neo4j-graph-algo-3.5.0.jar:/usr/share/neo4j/lib/neo4j-graph-matching-3.1.9.jar:/usr/share/neo4j/lib/neo4j-cluster-3.5.0.jar:/usr/share/neo4j/lib/neo4j-collections-3.5.0.jar:/usr/share/neo4j/lib/lz4-1.3.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-spi-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-lucene-index-3.5.0.jar:/usr/share/neo4j/lib/FastInfoset-1.2.13.jar:/usr/share/neo4j/lib/shiro-lang-1.4.0.jar:/usr/share/neo4j/lib/commons-io-2.6.jar:/usr/share/neo4j/lib/neo4j-cypher-interpreted-runtime-3.5.0.jar:/usr/share/neo4j/lib/simpleclient_dropwizard-0.4.0.jar:/usr/share/neo4j/lib/neo4j-legacy-3.5.0.jar:/usr/share/neo4j/lib/scala-reflect-2.11.12.jar:/usr/share/neo4j/lib/agrona-0.9.17.jar:/usr/share/neo4j/lib/shiro-crypto-core-1.4.0.jar:/usr/share/neo4j/lib/neo4j-enterprise-cypher-3.5.0.jar:/usr/share/neo4j/lib/akka-distributed-data_2.11-2.5.14.jar:/usr/share/neo4j/lib/shiro-config-ogdl-1.4.0.jar:/usr/share/neo4j/lib/asm-util-6.2.jar:/usr/share/neo4j/lib/jetty-http-9.4.11.v20180605.jar:/usr/share/neo4j/lib/lucene-codecs-5.5.5.jar:/usr/share/neo4j/lib/neo4j-bolt-3.5.0.jar:/usr/share/neo4j/lib/lucene-queryparser-5.5.5.jar:/usr/share/neo4j/lib/scala-library-2.11.12.jar:/usr/share/neo4j/lib/neo4j-ssl-3.5.0.jar:/usr/share/neo4j/lib/jetty-xml-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-procedure-api-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-expression-3.4-3.4.9.jar:/usr/share/neo4j/lib/jPowerShell-1.9.jar:/usr/share/neo4j/lib/shiro-cache-1.4.0.jar:/usr/share/neo4j/lib/javax.servlet-api-3.1.0.jar:/usr/share/neo4j/lib/neo4j-metrics-3.5.0.jar:/usr/share/neo4j/lib/slf4j-nop-1.7.25.jar:/usr/share/neo4j/lib/commons-lang3-3.8.jar:/usr/share/neo4j/lib/asm-6.2.jar:/usr/share/neo4j/lib/aeron-driver-1.9.1.jar:/var/lib/neo4j/plugins/*",
                    "key": "java.class.path"
                  }
                },
                "[path.separator]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": ":",
                    "key": "path.separator"
                  }
                },
                "[java.vendor]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Oracle Corporation",
                    "key": "java.vendor"
                  }
                },
                "[java.awt.graphicsenv]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "sun.awt.X11GraphicsEnvironment",
                    "key": "java.awt.graphicsenv"
                  }
                },
                "[java.ext.dirs]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/ext:/usr/java/packages/lib/ext",
                    "key": "java.ext.dirs"
                  }
                },
                "[hazelcast.socket.bind.any]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "false",
                    "key": "hazelcast.socket.bind.any"
                  }
                },
                "[os.name]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Linux",
                    "key": "os.name"
                  }
                },
                "[jdk.tls.rejectClientInitiatedRenegotiation]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "true",
                    "key": "jdk.tls.rejectClientInitiatedRenegotiation"
                  }
                },
                "[java.class.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "52.0",
                    "key": "java.class.version"
                  }
                },
                "[user.dir]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/",
                    "key": "user.dir"
                  }
                },
                "[line.separator]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "\n",
                    "key": "line.separator"
                  }
                },
                "[hazelcast.wait.seconds.before.join]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "1",
                    "key": "hazelcast.wait.seconds.before.join"
                  }
                },
                "[java.io.tmpdir]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/tmp",
                    "key": "java.io.tmpdir"
                  }
                },
                "[java.vm.specification.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "1.8",
                    "key": "java.vm.specification.version"
                  }
                },
                "[java.runtime.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "1.8.0_191-8u191-b12-0ubuntu0.16.04.1-b12",
                    "key": "java.runtime.version"
                  }
                },
                "[sun.management.compiler]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "HotSpot 64-Bit Tiered Compilers",
                    "key": "sun.management.compiler"
                  }
                },
                "[hazelcast.phone.home.enabled]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "false",
                    "key": "hazelcast.phone.home.enabled"
                  }
                },
                "[java.specification.name]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Java Platform API Specification",
                    "key": "java.specification.name"
                  }
                },
                "[java.home]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/usr/lib/jvm/java-8-openjdk-amd64/jre",
                    "key": "java.home"
                  }
                },
                "[sun.cpu.isalist]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "",
                    "key": "sun.cpu.isalist"
                  }
                },
                "[user.timezone]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Etc/UTC",
                    "key": "user.timezone"
                  }
                },
                "[sun.java.launcher]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "SUN_STANDARD",
                    "key": "sun.java.launcher"
                  }
                },
                "[java.specification.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "1.8",
                    "key": "java.specification.version"
                  }
                },
                "[unsupported.dbms.udc.source]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "gcloud-CORE",
                    "key": "unsupported.dbms.udc.source"
                  }
                },
                "[java.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "1.8.0_191",
                    "key": "java.version"
                  }
                },
                "[file.encoding]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "UTF-8",
                    "key": "file.encoding"
                  }
                },
                "[java.runtime.name]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "OpenJDK Runtime Environment",
                    "key": "java.runtime.name"
                  }
                },
                "[java.specification.vendor]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Oracle Corporation",
                    "key": "java.specification.vendor"
                  }
                },
                "[java.vendor.url.bug]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "http://bugreport.sun.com/bugreport/",
                    "key": "java.vendor.url.bug"
                  }
                },
                "[java.vendor.url]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "http://java.oracle.com/",
                    "key": "java.vendor.url"
                  }
                },
                "[file.encoding.pkg]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "sun.io",
                    "key": "file.encoding.pkg"
                  }
                },
                "[jetty.git.hash]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "d5fc0523cfa96bfebfbda19606cad384d772f04c",
                    "key": "jetty.git.hash"
                  }
                },
                "[jdk.tls.ephemeralDHKeySize]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "2048",
                    "key": "jdk.tls.ephemeralDHKeySize"
                  }
                },
                "[java.endorsed.dirs]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/endorsed",
                    "key": "java.endorsed.dirs"
                  }
                },
                "[os.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "4.15.0-1017-gcp",
                    "key": "os.version"
                  }
                },
                "[java.vm.specification.name]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Java Virtual Machine Specification",
                    "key": "java.vm.specification.name"
                  }
                },
                "[user.name]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "neo4j",
                    "key": "user.name"
                  }
                },
                "[user.country]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "US",
                    "key": "user.country"
                  }
                },
                "[java.vm.vendor]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Oracle Corporation",
                    "key": "java.vm.vendor"
                  }
                },
                "[hazelcast.shutdownhook.enabled]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "false",
                    "key": "hazelcast.shutdownhook.enabled"
                  }
                },
                "[java.library.path]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/usr/java/packages/lib/amd64:/usr/lib/x86_64-linux-gnu/jni:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/usr/lib/jni:/lib:/usr/lib",
                    "key": "java.library.path"
                  }
                },
                "[sun.os.patch.level]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "unknown",
                    "key": "sun.os.patch.level"
                  }
                },
                "[user.language]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "en",
                    "key": "user.language"
                  }
                },
                "[sun.boot.library.path]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/amd64",
                    "key": "sun.boot.library.path"
                  }
                },
                "[java.vm.name]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "OpenJDK 64-Bit Server VM",
                    "key": "java.vm.name"
                  }
                },
                "[sun.nio.ch.bugLevel]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "",
                    "key": "sun.nio.ch.bugLevel"
                  }
                },
                "[hazelcast.logging.type]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "none",
                    "key": "hazelcast.logging.type"
                  }
                },
                "[sun.cpu.endian]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "little",
                    "key": "sun.cpu.endian"
                  }
                },
                "[java.vm.info]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "mixed mode",
                    "key": "java.vm.info"
                  }
                },
                "[os.arch]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "amd64",
                    "key": "os.arch"
                  }
                },
                "[user.home]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/var/lib/neo4j",
                    "key": "user.home"
                  }
                },
                "[sun.boot.class.path]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/rt.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jfr.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/classes",
                    "key": "sun.boot.class.path"
                  }
                },
                "[java.vm.specification.vendor]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Oracle Corporation",
                    "key": "java.vm.specification.vendor"
                  }
                },
                "[sun.jnu.encoding]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "UTF-8",
                    "key": "sun.jnu.encoding"
                  }
                },
                "[java.awt.printerjob]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "sun.print.PSPrinterJob",
                    "key": "java.awt.printerjob"
                  }
                }
              }
            },
            "BootClassPathSupported": {
              "description": "BootClassPathSupported",
              "value": true
            }
          }
        },
        {
          "name": "java.lang:type=Threading",
          "attributes": {
            "ThreadAllocatedMemorySupported": {
              "description": "ThreadAllocatedMemorySupported",
              "value": true
            },
            "ThreadContentionMonitoringEnabled": {
              "description": "ThreadContentionMonitoringEnabled",
              "value": false
            },
            "TotalStartedThreadCount": {
              "description": "TotalStartedThreadCount",
              "value": 15849
            },
            "CurrentThreadCpuTimeSupported": {
              "description": "CurrentThreadCpuTimeSupported",
              "value": true
            },
            "CurrentThreadUserTime": {
              "description": "CurrentThreadUserTime",
              "value": 760000000
            },
            "PeakThreadCount": {
              "description": "PeakThreadCount",
              "value": 198
            },
            "AllThreadIds": {
              "description": "AllThreadIds",
              "value": [
                15860,
                15859,
                15858,
                15843,
                15786,
                15489,
                15487,
                15381,
                15380,
                15379,
                15122,
                15060,
                15059,
                15058,
                14315,
                13748,
                10431,
                9915,
                8798,
                8785,
                8758,
                329,
                155,
                154,
                153,
                152,
                151,
                150,
                107,
                103,
                102,
                101,
                98,
                95,
                92,
                90,
                88,
                87,
                86,
                83,
                82,
                81,
                79,
                73,
                72,
                70,
                68,
                67,
                66,
                65,
                64,
                62,
                61,
                60,
                59,
                58,
                14,
                57,
                56,
                51,
                50,
                49,
                48,
                47,
                46,
                45,
                44,
                27,
                19,
                26,
                25,
                24,
                23,
                22,
                21,
                20,
                42,
                35,
                39,
                38,
                37,
                36,
                34,
                33,
                32,
                31,
                30,
                29,
                28,
                18,
                15,
                13,
                12,
                5,
                3,
                2
              ]
            },
            "ThreadAllocatedMemoryEnabled": {
              "description": "ThreadAllocatedMemoryEnabled",
              "value": true
            },
            "CurrentThreadCpuTime": {
              "description": "CurrentThreadCpuTime",
              "value": 1104505337
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:type=Threading"
            },
            "ThreadContentionMonitoringSupported": {
              "description": "ThreadContentionMonitoringSupported",
              "value": true
            },
            "ThreadCpuTimeSupported": {
              "description": "ThreadCpuTimeSupported",
              "value": true
            },
            "ThreadCount": {
              "description": "ThreadCount",
              "value": 96
            },
            "ThreadCpuTimeEnabled": {
              "description": "ThreadCpuTimeEnabled",
              "value": true
            },
            "ObjectMonitorUsageSupported": {
              "description": "ObjectMonitorUsageSupported",
              "value": true
            },
            "SynchronizerUsageSupported": {
              "description": "SynchronizerUsageSupported",
              "value": true
            },
            "DaemonThreadCount": {
              "description": "DaemonThreadCount",
              "value": 63
            }
          }
        },
        {
          "name": "java.lang:type=OperatingSystem",
          "attributes": {
            "OpenFileDescriptorCount": {
              "description": "OpenFileDescriptorCount",
              "value": 948
            },
            "CommittedVirtualMemorySize": {
              "description": "CommittedVirtualMemorySize",
              "value": 10467692544
            },
            "FreePhysicalMemorySize": {
              "description": "FreePhysicalMemorySize",
              "value": 249802752
            },
            "SystemLoadAverage": {
              "description": "SystemLoadAverage",
              "value": 0.07
            },
            "Arch": {
              "description": "Arch",
              "value": "amd64"
            },
            "ProcessCpuLoad": {
              "description": "ProcessCpuLoad",
              "value": 0.015037593984962405
            },
            "TotalPhysicalMemorySize": {
              "description": "TotalPhysicalMemorySize",
              "value": 15762874368
            },
            "FreeSwapSpaceSize": {
              "description": "FreeSwapSpaceSize",
              "value": 0
            },
            "Name": {
              "description": "Name",
              "value": "Linux"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:type=OperatingSystem"
            },
            "TotalSwapSpaceSize": {
              "description": "TotalSwapSpaceSize",
              "value": 0
            },
            "ProcessCpuTime": {
              "description": "ProcessCpuTime",
              "value": 80656970000000
            },
            "MaxFileDescriptorCount": {
              "description": "MaxFileDescriptorCount",
              "value": 60000
            },
            "SystemCpuLoad": {
              "description": "SystemCpuLoad",
              "value": 0.015037593984962405
            },
            "Version": {
              "description": "Version",
              "value": "4.15.0-1017-gcp"
            },
            "AvailableProcessors": {
              "description": "AvailableProcessors",
              "value": 4
            }
          }
        },
        {
          "name": "java.lang:name=Code Cache,type=MemoryPool",
          "attributes": {
            "UsageThresholdCount": {
              "description": "UsageThresholdCount",
              "value": 0
            },
            "Usage": {
              "description": "Usage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 2555904,
                  "committed": 69271552,
                  "used": 68584768,
                  "max": 251658240
                }
              }
            },
            "MemoryManagerNames": {
              "description": "MemoryManagerNames",
              "value": [
                "CodeCacheManager"
              ]
            },
            "UsageThresholdSupported": {
              "description": "UsageThresholdSupported",
              "value": true
            },
            "UsageThreshold": {
              "description": "UsageThreshold",
              "value": 0
            },
            "CollectionUsageThresholdCount": {
              "description": "CollectionUsageThresholdCount",
              "value": null
            },
            "PeakUsage": {
              "description": "PeakUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 2555904,
                  "committed": 69271552,
                  "used": 68595200,
                  "max": 251658240
                }
              }
            },
            "UsageThresholdExceeded": {
              "description": "UsageThresholdExceeded",
              "value": false
            },
            "CollectionUsageThreshold": {
              "description": "CollectionUsageThreshold",
              "value": null
            },
            "Name": {
              "description": "Name",
              "value": "Code Cache"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=Code Cache,type=MemoryPool"
            },
            "Type": {
              "description": "Type",
              "value": "NON_HEAP"
            },
            "CollectionUsageThresholdSupported": {
              "description": "CollectionUsageThresholdSupported",
              "value": false
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionUsage": {
              "description": "CollectionUsage",
              "value": null
            },
            "CollectionUsageThresholdExceeded": {
              "description": "CollectionUsageThresholdExceeded",
              "value": null
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Primitive count",
          "attributes": {
            "NumberOfRelationshipIdsInUse": {
              "description": "An estimation of the number of relationships used in this Neo4j instance",
              "value": 4265596
            },
            "NumberOfPropertyIdsInUse": {
              "description": "An estimation of the number of properties used in this Neo4j instance",
              "value": 17122433
            },
            "NumberOfNodeIdsInUse": {
              "description": "An estimation of the number of nodes used in this Neo4j instance",
              "value": 9273218
            },
            "NumberOfRelationshipTypeIdsInUse": {
              "description": "The number of relationship types used in this Neo4j instance",
              "value": 66
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Memory Mapping",
          "attributes": {
            "MemoryPools": {
              "description": "Get information about each pool of memory mapped regions from store files with memory mapping enabled",
              "value": []
            }
          }
        },
        {
          "name": "java.nio:name=direct,type=BufferPool",
          "attributes": {
            "TotalCapacity": {
              "description": "TotalCapacity",
              "value": 8224345
            },
            "MemoryUsed": {
              "description": "MemoryUsed",
              "value": 8224346
            },
            "Count": {
              "description": "Count",
              "value": 71
            },
            "Name": {
              "description": "Name",
              "value": "direct"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.nio:name=direct,type=BufferPool"
            }
          }
        },
        {
          "name": "java.lang:type=Compilation",
          "attributes": {
            "TotalCompilationTime": {
              "description": "TotalCompilationTime",
              "value": 168442
            },
            "CompilationTimeMonitoringSupported": {
              "description": "CompilationTimeMonitoringSupported",
              "value": true
            },
            "Name": {
              "description": "Name",
              "value": "HotSpot 64-Bit Tiered Compilers"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:type=Compilation"
            }
          }
        },
        {
          "name": "java.lang:name=G1 Young Generation,type=GarbageCollector",
          "attributes": {
            "MemoryPoolNames": {
              "description": "MemoryPoolNames",
              "value": [
                "G1 Eden Space",
                "G1 Survivor Space"
              ]
            },
            "LastGcInfo": {
              "description": "LastGcInfo",
              "value": {
                "description": "CompositeType for GC info for G1 Young Generation",
                "properties": {
                  "duration": 53,
                  "memoryUsageBeforeGc": {
                    "[G1 Survivor Space]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 0,
                            "committed": 10485760,
                            "used": 10485760,
                            "max": -1
                          }
                        },
                        "key": "G1 Survivor Space"
                      }
                    },
                    "[Metaspace]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 0,
                            "committed": 112619520,
                            "used": 106837488,
                            "max": -1
                          }
                        },
                        "key": "Metaspace"
                      }
                    },
                    "[G1 Eden Space]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 270532608,
                            "committed": 3227516928,
                            "used": 3072327680,
                            "max": -1
                          }
                        },
                        "key": "G1 Eden Space"
                      }
                    },
                    "[Compressed Class Space]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 0,
                            "committed": 15626240,
                            "used": 14580984,
                            "max": 1073741824
                          }
                        },
                        "key": "Compressed Class Space"
                      }
                    },
                    "[G1 Old Gen]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 4867489792,
                            "committed": 1900019712,
                            "used": 1400722224,
                            "max": 5242880000
                          }
                        },
                        "key": "G1 Old Gen"
                      }
                    },
                    "[Code Cache]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 2555904,
                            "committed": 69206016,
                            "used": 68347200,
                            "max": 251658240
                          }
                        },
                        "key": "Code Cache"
                      }
                    }
                  },
                  "GcThreadCount": 10,
                  "startTime": 4439191607,
                  "endTime": 4439191660,
                  "id": 824,
                  "memoryUsageAfterGc": {
                    "[G1 Survivor Space]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 0,
                            "committed": 10485760,
                            "used": 10485760,
                            "max": -1
                          }
                        },
                        "key": "G1 Survivor Space"
                      }
                    },
                    "[Metaspace]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 0,
                            "committed": 112619520,
                            "used": 106837488,
                            "max": -1
                          }
                        },
                        "key": "Metaspace"
                      }
                    },
                    "[G1 Eden Space]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 270532608,
                            "committed": 3227516928,
                            "used": 0,
                            "max": -1
                          }
                        },
                        "key": "G1 Eden Space"
                      }
                    },
                    "[Compressed Class Space]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 0,
                            "committed": 15626240,
                            "used": 14580984,
                            "max": 1073741824
                          }
                        },
                        "key": "Compressed Class Space"
                      }
                    },
                    "[G1 Old Gen]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 4867489792,
                            "committed": 1900019712,
                            "used": 1401018160,
                            "max": 5242880000
                          }
                        },
                        "key": "G1 Old Gen"
                      }
                    },
                    "[Code Cache]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 2555904,
                            "committed": 69206016,
                            "used": 68347200,
                            "max": 251658240
                          }
                        },
                        "key": "Code Cache"
                      }
                    }
                  }
                }
              }
            },
            "CollectionTime": {
              "description": "CollectionTime",
              "value": 55919
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionCount": {
              "description": "CollectionCount",
              "value": 824
            },
            "Name": {
              "description": "Name",
              "value": "G1 Young Generation"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=G1 Young Generation,type=GarbageCollector"
            }
          }
        },
        {
          "name": "java.lang:name=CodeCacheManager,type=MemoryManager",
          "attributes": {
            "MemoryPoolNames": {
              "description": "MemoryPoolNames",
              "value": [
                "Code Cache"
              ]
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "Name": {
              "description": "Name",
              "value": "CodeCacheManager"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=CodeCacheManager,type=MemoryManager"
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Index sampler",
          "attributes": {}
        },
        {
          "name": "java.lang:name=G1 Old Gen,type=MemoryPool",
          "attributes": {
            "UsageThresholdCount": {
              "description": "UsageThresholdCount",
              "value": 0
            },
            "Usage": {
              "description": "Usage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 4867489792,
                  "committed": 1900019712,
                  "used": 1401018160,
                  "max": 5242880000
                }
              }
            },
            "MemoryManagerNames": {
              "description": "MemoryManagerNames",
              "value": [
                "G1 Old Generation"
              ]
            },
            "UsageThresholdSupported": {
              "description": "UsageThresholdSupported",
              "value": true
            },
            "UsageThreshold": {
              "description": "UsageThreshold",
              "value": 0
            },
            "CollectionUsageThresholdCount": {
              "description": "CollectionUsageThresholdCount",
              "value": 0
            },
            "PeakUsage": {
              "description": "PeakUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 4867489792,
                  "committed": 4867489792,
                  "used": 1401018160,
                  "max": 5242880000
                }
              }
            },
            "UsageThresholdExceeded": {
              "description": "UsageThresholdExceeded",
              "value": false
            },
            "CollectionUsageThreshold": {
              "description": "CollectionUsageThreshold",
              "value": 0
            },
            "Name": {
              "description": "Name",
              "value": "G1 Old Gen"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=G1 Old Gen,type=MemoryPool"
            },
            "Type": {
              "description": "Type",
              "value": "HEAP"
            },
            "CollectionUsageThresholdSupported": {
              "description": "CollectionUsageThresholdSupported",
              "value": true
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionUsage": {
              "description": "CollectionUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 4867489792,
                  "committed": 0,
                  "used": 0,
                  "max": 5242880000
                }
              }
            },
            "CollectionUsageThresholdExceeded": {
              "description": "CollectionUsageThresholdExceeded",
              "value": false
            }
          }
        },
        {
          "name": "java.util.logging:type=Logging",
          "attributes": {
            "LoggerNames": {
              "description": "LoggerNames",
              "value": [
                "com.sun.jersey.server.impl.application.WebApplicationImpl",
                "javax.management.notification",
                "javax.management.timer",
                "com.sun.jersey.spi.inject.Errors",
                "com.sun.jersey.core.spi.component.ProviderServices",
                "com.sun.jersey.spi.container.ContainerResponse",
                "javax.management.modelmbean",
                "io.netty.channel.AbstractChannel",
                "com.sun.jersey.api.core.ResourceConfig",
                "com.sun.jersey.server.impl.application.ResourceMethodDispatcherFactory",
                "io.netty.util.concurrent.AbstractEventExecutor",
                "io.netty.util.NetUtil",
                "com.sun.jersey.server.impl.application.RootResourceUriRules",
                "io.netty.util.internal.PlatformDependent",
                "io.netty.util.internal.SystemPropertyUtil",
                "com.sun.jersey.server.impl.model.method.dispatch.MultipartFormDispatchProvider",
                "javax.management.mbeanserver",
                "io.netty.channel.socket.nio.NioServerSocketChannel",
                "io.netty.util.concurrent.SingleThreadEventExecutor",
                "io.netty.util.internal.PlatformDependent0",
                "com.sun.jersey.spi.service.ServiceFinder",
                "com.sun.jersey.core.impl.provider.entity.EntityHolderReader",
                "com.sun.jersey.server.impl.cdi.CDIComponentProviderFactoryInitializer",
                "global",
                "io.netty.util.ReferenceCountUtil",
                "com.sun.jersey.server.impl.resource.PerRequestFactory",
                "io.netty.channel.ChannelInitializer",
                "io.netty.util.internal.InternalThreadLocalMap",
                "com.sun.jersey.server.impl.managedbeans.ManagedBeanComponentProviderFactoryInitilizer",
                "io.netty.util.Recycler",
                "io.netty.util.concurrent.GlobalEventExecutor",
                "io.netty.channel.nio.NioEventLoop",
                "io.netty.channel.socket.nio.NioSocketChannel",
                "javax.management.snmp",
                "javax.management",
                "com.sun.jersey.server.impl.container.filter.FilterFactory",
                "io.netty.util.ResourceLeakDetector",
                "io.netty.util.concurrent.DefaultPromise",
                "io.netty.channel.MultithreadEventLoopGroup",
                "javax.management.misc",
                "io.netty.channel.AbstractChannelHandlerContext",
                "io.netty.buffer.ByteBufUtil",
                "com.sun.jersey.server.impl.wadl.WadlFactory",
                "io.netty.channel.DefaultChannelId",
                "javax.management.monitor",
                "io.netty.channel.DefaultChannelPipeline",
                "io.netty.buffer.PooledByteBufAllocator",
                "io.netty.bootstrap.Bootstrap",
                "io.netty.bootstrap.ServerBootstrap",
                "javax.management.mlet",
                "io.netty.util.concurrent.DefaultPromise.rejectedExecution",
                "com.github.benmanes.caffeine.cache.BoundedLocalCache",
                "com.github.benmanes.caffeine.cache.Caffeine",
                "com.sun.jersey.core.reflection.ReflectionHelper",
                "io.netty.resolver.AddressResolverGroup",
                "com.sun.jersey.server.impl.ejb.EJBComponentProviderFactoryInitilizer",
                "io.netty.util.ResourceLeakDetectorFactory",
                "com.sun.jersey.server.impl.modelapi.annotation.IntrospectionModeller",
                "javax.management.relation",
                "io.netty.util.internal.CleanerJava6",
                "com.sun.jersey.spi.container.servlet.WebComponent",
                "com.sun.jersey.server.impl.application.CloseableServiceFactory",
                "com.sun.jersey.core.impl.provider.xml.DocumentBuilderFactoryProvider",
                "io.netty.util.internal.MacAddressUtil",
                "javax.management.snmp.daemon",
                "io.netty.buffer.AbstractByteBuf",
                "io.netty.handler.stream.ChunkedWriteHandler",
                "io.netty.buffer.PoolThreadCache",
                "sun.net.www.protocol.http.HttpURLConnection",
                "io.netty.channel.nio.AbstractNioChannel",
                "com.sun.jersey.spi.container.ContainerRequest",
                "com.sun.jersey.core.spi.component.ProviderFactory",
                "io.netty.channel.ChannelOutboundBuffer",
                "com.sun.jersey.server.impl.monitoring.GlassFishMonitoringInitializer",
                ""
              ]
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.util.logging:type=Logging"
            }
          }
        },
        {
          "name": "java.lang:name=G1 Old Generation,type=GarbageCollector",
          "attributes": {
            "MemoryPoolNames": {
              "description": "MemoryPoolNames",
              "value": [
                "G1 Eden Space",
                "G1 Survivor Space",
                "G1 Old Gen"
              ]
            },
            "LastGcInfo": {
              "description": "LastGcInfo",
              "value": null
            },
            "CollectionTime": {
              "description": "CollectionTime",
              "value": 0
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionCount": {
              "description": "CollectionCount",
              "value": 0
            },
            "Name": {
              "description": "Name",
              "value": "G1 Old Generation"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=G1 Old Generation,type=GarbageCollector"
            }
          }
        },
        {
          "name": "java.lang:type=ClassLoading",
          "attributes": {
            "LoadedClassCount": {
              "description": "LoadedClassCount",
              "value": 20139
            },
            "UnloadedClassCount": {
              "description": "UnloadedClassCount",
              "value": 0
            },
            "Verbose": {
              "description": "Verbose",
              "value": false
            },
            "TotalLoadedClassCount": {
              "description": "TotalLoadedClassCount",
              "value": 20139
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:type=ClassLoading"
            }
          }
        },
        {
          "name": "java.lang:name=Metaspace Manager,type=MemoryManager",
          "attributes": {
            "MemoryPoolNames": {
              "description": "MemoryPoolNames",
              "value": [
                "Metaspace",
                "Compressed Class Space"
              ]
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "Name": {
              "description": "Name",
              "value": "Metaspace Manager"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=Metaspace Manager,type=MemoryManager"
            }
          }
        },
        {
          "name": "java.lang:name=G1 Survivor Space,type=MemoryPool",
          "attributes": {
            "UsageThresholdCount": {
              "description": "UsageThresholdCount",
              "value": null
            },
            "Usage": {
              "description": "Usage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 10485760,
                  "used": 10485760,
                  "max": -1
                }
              }
            },
            "MemoryManagerNames": {
              "description": "MemoryManagerNames",
              "value": [
                "G1 Old Generation",
                "G1 Young Generation"
              ]
            },
            "UsageThresholdSupported": {
              "description": "UsageThresholdSupported",
              "value": false
            },
            "UsageThreshold": {
              "description": "UsageThreshold",
              "value": null
            },
            "CollectionUsageThresholdCount": {
              "description": "CollectionUsageThresholdCount",
              "value": 0
            },
            "PeakUsage": {
              "description": "PeakUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 314572800,
                  "used": 314572800,
                  "max": -1
                }
              }
            },
            "UsageThresholdExceeded": {
              "description": "UsageThresholdExceeded",
              "value": null
            },
            "CollectionUsageThreshold": {
              "description": "CollectionUsageThreshold",
              "value": 0
            },
            "Name": {
              "description": "Name",
              "value": "G1 Survivor Space"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=G1 Survivor Space,type=MemoryPool"
            },
            "Type": {
              "description": "Type",
              "value": "HEAP"
            },
            "CollectionUsageThresholdSupported": {
              "description": "CollectionUsageThresholdSupported",
              "value": true
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionUsage": {
              "description": "CollectionUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 10485760,
                  "used": 10485760,
                  "max": -1
                }
              }
            },
            "CollectionUsageThresholdExceeded": {
              "description": "CollectionUsageThresholdExceeded",
              "value": false
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Transactions",
          "attributes": {
            "NumberOfRolledBackTransactions": {
              "description": "The total number of rolled back transactions",
              "value": 116
            },
            "NumberOfOpenTransactions": {
              "description": "The number of currently open transactions",
              "value": 1
            },
            "LastCommittedTxId": {
              "description": "The id of the latest committed transaction",
              "value": 541593
            },
            "NumberOfOpenedTransactions": {
              "description": "The total number started transactions",
              "value": 3899570
            },
            "PeakNumberOfConcurrentTransactions": {
              "description": "The highest number of transactions ever opened concurrently",
              "value": 101
            },
            "NumberOfCommittedTransactions": {
              "description": "The total number of committed transactions",
              "value": 3899453
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Store file sizes",
          "attributes": {
            "LogicalLogSize": {
              "description": "The amount of disk space used by the current Neo4j logical log, in bytes.",
              "value": 243711137
            },
            "StringStoreSize": {
              "description": "The amount of disk space used to store string properties, in bytes.",
              "value": 523640832
            },
            "ArrayStoreSize": {
              "description": "The amount of disk space used to store array properties, in bytes.",
              "value": 10982948864
            },
            "RelationshipStoreSize": {
              "description": "The amount of disk space used to store relationships, in bytes.",
              "value": 145035840
            },
            "PropertyStoreSize": {
              "description": "The amount of disk space used to store properties (excluding string values and array values), in bytes.",
              "value": 702032996
            },
            "TotalStoreSize": {
              "description": "The total disk space used by this Neo4j instance, in bytes.",
              "value": 15277128216
            },
            "NodeStoreSize": {
              "description": "The amount of disk space used to store nodes, in bytes.",
              "value": 139107150
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Diagnostics",
          "attributes": {
            "DiagnosticsProviders": {
              "description": "A list of the ids for the registered diagnostics providers.",
              "value": null
            }
          }
        },
        {
          "name": "org.neo4j.ServerManagement:restartServer=lifecycle",
          "attributes": {}
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Locking",
          "attributes": {
            "Locks": {
              "description": "Information about all locks held by Neo4j",
              "value": []
            },
            "NumberOfAvertedDeadlocks": {
              "description": "The number of lock sequences that would have lead to a deadlock situation that Neo4j has detected and averted (by throwing DeadlockDetectedException).",
              "value": -1
            }
          }
        },
        {
          "name": "java.lang:name=Metaspace,type=MemoryPool",
          "attributes": {
            "UsageThresholdCount": {
              "description": "UsageThresholdCount",
              "value": 0
            },
            "Usage": {
              "description": "Usage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 112619520,
                  "used": 106883616,
                  "max": -1
                }
              }
            },
            "MemoryManagerNames": {
              "description": "MemoryManagerNames",
              "value": [
                "Metaspace Manager"
              ]
            },
            "UsageThresholdSupported": {
              "description": "UsageThresholdSupported",
              "value": true
            },
            "UsageThreshold": {
              "description": "UsageThreshold",
              "value": 0
            },
            "CollectionUsageThresholdCount": {
              "description": "CollectionUsageThresholdCount",
              "value": null
            },
            "PeakUsage": {
              "description": "PeakUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 112619520,
                  "used": 106883616,
                  "max": -1
                }
              }
            },
            "UsageThresholdExceeded": {
              "description": "UsageThresholdExceeded",
              "value": false
            },
            "CollectionUsageThreshold": {
              "description": "CollectionUsageThreshold",
              "value": null
            },
            "Name": {
              "description": "Name",
              "value": "Metaspace"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=Metaspace,type=MemoryPool"
            },
            "Type": {
              "description": "Type",
              "value": "NON_HEAP"
            },
            "CollectionUsageThresholdSupported": {
              "description": "CollectionUsageThresholdSupported",
              "value": false
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionUsage": {
              "description": "CollectionUsage",
              "value": null
            },
            "CollectionUsageThresholdExceeded": {
              "description": "CollectionUsageThresholdExceeded",
              "value": null
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Reports",
          "attributes": {
            "EnvironmentVariables": {
              "description": "Returns a map if the current environment variables",
              "value": "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nNEO4J_CONF=/etc/neo4j\ndbms_directories_metrics=/var/lib/neo4j/metrics\ndbms_security_procedures_unrestricted=\"apoc.*,algo.*\"\ncausal_clustering_transaction_advertised_address=10.142.0.3:6000\ncausal_clustering_expected_core_cluster_size=3 3\nLOGNAME=neo4j\ndbms_backup_enabled=true true\ndbms_security_auth_enabled=true\nPWD=/\ndbms_logs_security_level=INFO INFO\ndbms_directories_logs=/var/log/neo4j\ndbms_connectors_default_listen_address=0.0.0.0 0.0.0.0\nSHELL=/bin/bash\ndbms_connector_https_listen_address=0.0.0.0:7473 0.0.0.0:7473\nha_pull_interval=10\ndbms_connector_bolt_tls_level=REQUIRED REQUIRED\nINTERNAL_IP_ADDR=10.142.0.3\ncausal_clustering_raft_advertised_address=10.142.0.3:7000\ndbms_ssl_policy_default_allow_key_generation=false\ndbms_connector_bolt_enabled=true true\ndbms_allow_upgrade=true\ndbms_ssl_policy_default_base_directory=/var/lib/neo4j/certificates\nINTERNAL_HOSTNAME=meetup-cluster-core-vm-1.c.testbed-187316.internal\ncausal_clustering_initial_discovery_members=meetup-cluster-core-vm-1:5000,meetup-cluster-core-vm-2:5000,meetup-cluster-core-vm-3:5000 meetup-cluster-core-vm-1:5000,meetup-cluster-core-vm-2:5000,meetup-cluster-core-vm-3:5000\nSHLVL=1\ndbms_connector_bolt_listen_address=0.0.0.0:7687 0.0.0.0:7687\ndbms_ssl_policy_default_client_auth=NONE\ndbms_connectors_default_advertised_address=node1.cluster.graph.center\ndbms_connector_https_enabled=true true\ndbms_connector_http_listen_address=0.0.0.0:7474 0.0.0.0:7474\ncausal_clustering_discovery_type=LIST LIST\nNEO4J_HOME=/var/lib/neo4j\ndbms_memory_pagecache_size=1g\ndbms_jvm_additional=-XX:+UseG1GC -XX:-OmitStackTraceInFastThrow -XX:+AlwaysPreTouch -XX:+UnlockExperimentalVMOptions -XX:+TrustFinalNonStaticFields -XX:+DisableExplicitGC -Djdk.tls.ephemeralDHKeySize=2048 -Djdk.tls.rejectClientInitiatedRenegotiation=true -Dunsupported.dbms.udc.source=gcloud-CORE\nbolt_ssl_policy=default\ndbms_logs_http_enabled=false false\nLANG=en_US.UTF-8\ndbms_windows_service_name=neo4j\ncausal_clustering_discovery_listen_address=0.0.0.0:5000 0.0.0.0:5000\ndbms_backup_address=localhost:6362 localhost:6362\ndbms_directories_data=/var/lib/neo4j/data\ndbms_connector_http_enabled=true true\nEXTERNAL_IP_ADDR=35.231.134.20\ndbms_directories_certificates=/var/lib/neo4j/certificates\nINSTANCE_API=http://metadata.google.internal/computeMetadata/v1/instance\ndbms_ssl_policy_default_private_key=/var/lib/neo4j/certificates/neo4j.key\ndbms_logs_gc_enabled=false false\ndbms_ssl_policy_default_revoked_dir=/var/lib/neo4j/certificates/revoked\nUSER=neo4j\ndbms_security_allow_csv_import_from_file_urls=true true\ndbms_ssl_policy_default_public_certificate=/var/lib/neo4j/certificates/neo4j.cert\ndbms_directories_run=/var/run/neo4j\ndbms_directories_import=/var/lib/neo4j/import\ndbms_directories_plugins=/var/lib/neo4j/plugins\ndbms_memory_heap_max_size=5000m\ndbms_directories_lib=/usr/share/neo4j/lib\ndbms_memory_heap_initial_size=4900m\nHOME=/var/lib/neo4j\ndbms_mode=CORE CORE\n"
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Page cache",
          "attributes": {
            "Hits": {
              "description": "Number of page hits. How often requested data was found in memory.",
              "value": 9783412614
            },
            "FileUnmappings": {
              "description": "Number of files that have been unmapped from the page cache.",
              "value": 172
            },
            "FileMappings": {
              "description": "Number of files that have been mapped into the page cache.",
              "value": 271
            },
            "Faults": {
              "description": "Number of page faults. How often requested data was not found in memory and had to be loaded.",
              "value": 484983
            },
            "EvictionExceptions": {
              "description": "Number of exceptions caught during page eviction. This number should be zero, or at least not growing, in a healthy database. Otherwise it could indicate drive failure, storage space, or permission problems.",
              "value": 0
            },
            "BytesWritten": {
              "description": "Number of bytes written to durable storage.",
              "value": 3130982711
            },
            "Flushes": {
              "description": "Number of page flushes. How many dirty pages have been written to durable storage.",
              "value": 111632
            },
            "UsageRatio": {
              "description": "The percentage of used pages. Will return NaN if it cannot be determined.",
              "value": 0.9966146092631031
            },
            "Unpins": {
              "description": "Number of page unpins. How many pages have been accessed and are not accessed anymore (monitoring must be enabled separately).",
              "value": 9783897323
            },
            "Evictions": {
              "description": "Number of page evictions. How many pages have been removed from memory to make room for other pages.",
              "value": 354864
            },
            "BytesRead": {
              "description": "Number of bytes read from durable storage.",
              "value": 1517259834
            },
            "Pins": {
              "description": "Number of page pins. How many pages have been accessed (monitoring must be enabled separately).",
              "value": 109807924056
            },
            "HitRatio": {
              "description": "Ratio of hits to the total number of lookups in the page cache",
              "value": 0.999950430490999
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Store sizes",
          "attributes": {
            "CountStoreSize": {
              "description": "Disk space used to store counters, in bytes",
              "value": 12000
            },
            "LabelStoreSize": {
              "description": "Disk space used to store labels, in bytes",
              "value": 89908
            },
            "IndexStoreSize": {
              "description": "Disk space used to store all indices, in bytes",
              "value": 130436329
            },
            "StringStoreSize": {
              "description": "Disk space used to store string properties, in bytes.",
              "value": 523640841
            },
            "ArrayStoreSize": {
              "description": "Disk space used to store array properties, in bytes.",
              "value": 10982950265
            },
            "RelationshipStoreSize": {
              "description": "Disk space used to store relationships, in bytes.",
              "value": 145184303
            },
            "PropertyStoreSize": {
              "description": "Disk space used to store properties (excluding string values and array values), in bytes.",
              "value": 702124441
            },
            "TransactionLogsSize": {
              "description": "Disk space used by the transaction logs, in bytes.",
              "value": 505861828
            },
            "SchemaStoreSize": {
              "description": "Disk space used to store schemas (index and constrain declarations), in bytes",
              "value": 204809
            },
            "TotalStoreSize": {
              "description": "Disk space used by whole store, in bytes.",
              "value": 15277128216
            },
            "NodeStoreSize": {
              "description": "Disk space used to store nodes, in bytes.",
              "value": 139116904
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Configuration",
          "attributes": {
            "metrics.neo4j.server.enabled": {
              "description": "Enable reporting metrics about Server threading info.",
              "value": "true"
            },
            "unsupported.dbms.index.archive_failed": {
              "description": "Create an archive of an index before re-creating it if failing to load on startup.",
              "value": "false"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84-3d.z.max": {
              "description": "The maximum z value for the index extents for 3D wgs-84-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "1000000.0"
            },
            "metrics.graphite.server": {
              "description": "The hostname or IP address of the Graphite server",
              "value": ":2003"
            },
            "unsupported.ha.cluster_name": {
              "description": "The name of a cluster.",
              "value": "neo4j.ha"
            },
            "unsupported.dbms.db.spatial.crs.cartesian-3d.y.min": {
              "description": "The minimum y value for the index extents for 3D cartesian-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-1000000.0"
            },
            "unsupported.dbms.max_http_request_header_size": {
              "description": "Maximum request header size",
              "value": "20480"
            },
            "causal_clustering.discovery_resolution_timeout": {
              "description": "Configures the time after which we give up trying to resolve a DNS/SRV record into a list of initial discovery members.",
              "value": "300000ms"
            },
            "tools.consistency_checker.check_graph": {
              "description": "This setting is deprecated. See commandline arguments for neoj4-admin check-consistency instead. Perform checks between nodes, relationships, properties, types and tokens.",
              "value": "true"
            },
            "dbms.memory.heap.initial_size": {
              "description": "Initial heap size. By default it is calculated based on available system resources.",
              "value": "4900m"
            },
            "dbms.ssl.policy.<policyname>.base_directory": {
              "description": "The mandatory base directory for cryptographic objects of this policy. It is also possible to override each individual configuration with absolute paths.",
              "value": null
            },
            "dbms.security.auth_provider": {
              "description": "The authentication and authorization provider that contains both the users and roles. This can be one of the built-in `native` or `ldap` providers, or it can be an externally provided plugin, with a custom name prefixed by `plugin-`, i.e. `plugin-<AUTH_PROVIDER_NAME>`. ",
              "value": "native"
            },
            "dbms.checkpoint.interval.tx": {
              "description": "Configures the transaction interval between check-points. The database will not check-point more often  than this (unless check pointing is triggered by a different event), but might check-point less often than this interval, if performing a check-point takes longer time than the configured interval. A check-point is a point in the transaction logs, from which recovery would start from. Longer check-point intervals typically means that recovery will take longer to complete in case of a crash. On the other hand, a longer check-point interval can also reduce the I/O load that the database places on the system, as each check-point implies a flushing and forcing of all the store files.  The default is '100000' for a check-point every 100000 transactions.",
              "value": "100000"
            },
            "hazelcast.license_key": {
              "description": "Hazelcast license key",
              "value": null
            },
            "ha.join_timeout": {
              "description": "Timeout for joining a cluster. Defaults to ha.broadcast_timeout. Note that if the timeout expires during cluster formation, the operator may have to restart the instance or instances.",
              "value": "30000ms"
            },
            "ha.configuration_timeout": {
              "description": "Timeout for waiting for configuration from an existing cluster member during cluster join.",
              "value": "1000ms"
            },
            "dbms.memory.pagecache.swapper": {
              "description": "Specify which page swapper to use for doing paged IO. This is only used when integrating with proprietary storage technology.",
              "value": null
            },
            "causal_clustering.relationship_group_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP_GROUP IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "ha.host.coordination": {
              "description": "Host and port to bind the cluster management communication.",
              "value": "0.0.0.0:5001-5099"
            },
            "causal_clustering.minimum_core_cluster_size_at_formation": {
              "description": "Minimum number of Core machines in the cluster at formation. The expected_core_cluster size setting is used when bootstrapping the cluster on first formation. A cluster will not form without the configured amount of cores and this should in general be configured to the full and fixed amount. When using multi-clustering (configuring multiple distinct database names across core hosts), this setting is used to define the minimum size of *each* sub-cluster at formation.",
              "value": "3"
            },
            "dbms.query_cache_size": {
              "description": "The number of Cypher query execution plans that are cached.",
              "value": "1000"
            },
            "ha.allow_init_cluster": {
              "description": "Whether to allow this instance to create a cluster if unable to join.",
              "value": "true"
            },
            "bolt.ssl_policy": {
              "description": "Specify the SSL policy to use for the encrypted bolt connections.",
              "value": "default"
            },
            "metrics.jvm.memory.enabled": {
              "description": "Enable reporting metrics about the memory usage.",
              "value": "true"
            },
            "metrics.neo4j.pagecache.enabled": {
              "description": "Enable reporting metrics about the Neo4j page cache; page faults, evictions, flushes, exceptions, etc.",
              "value": "true"
            },
            "dbms.security.procedures.default_allowed": {
              "description": "The default role that can execute all procedures and user-defined functions that are not covered by the `dbms.security.procedures.roles` setting. If the `dbms.security.procedures.default_allowed` setting is the empty string (default), procedures will be executed according to the same security rules as normal Cypher statements.\n\nDeprecated: This will be replaced by dynamic configuration in the system graph in 4.0, including a migration step for the existing setting value.",
              "value": ""
            },
            "dbms.connector.bolt.listen_address": {
              "description": "Address the connector should bind to.",
              "value": "0.0.0.0:7687"
            },
            "unsupported.dbms.counts_store_rotation_timeout": {
              "description": "Maximum time to wait for active transaction completion when rotating counts store",
              "value": "600000ms"
            },
            "causal_clustering.cluster_allow_reads_on_followers": {
              "description": "Configure if the `dbms.cluster.routing.getServers()` procedure should include followers as read endpoints or return only read replicas. Note: if there are no read replicas in the cluster, followers are returned as read end points regardless the value of this setting. Defaults to true so that followers are available for read-only queries in a typical heterogeneous setup.",
              "value": "true"
            },
            "causal_clustering.raft_log_implementation": {
              "description": "RAFT log implementation",
              "value": "SEGMENTED"
            },
            "unsupported.dbms.uris.rest": {
              "description": "Configuration attribute",
              "value": "/db/data"
            },
            "causal_clustering.multi_dc_license": {
              "description": "Enable multi-data center features. Requires appropriate licensing.",
              "value": "false"
            },
            "dbms.db.timezone": {
              "description": "Database timezone. Among other things, this setting influences which timezone the logs and monitoring procedures use.",
              "value": "UTC"
            },
            "dbms.logs.debug.path": {
              "description": "Path to the debug log file.",
              "value": "/var/log/neo4j/debug.log"
            },
            "dbms.connector.bolt.enabled": {
              "description": "Enable this connector.",
              "value": "true"
            },
            "unsupported.dbms.logs.debug.debug_loggers": {
              "description": "Debug log contexts that should output debug level logging",
              "value": "[org.neo4j.diagnostics, org.neo4j.cluster.protocol, org.neo4j.kernel.ha]"
            },
            "dbms.logs.query.parameter_logging_enabled": {
              "description": "Log parameters for the executed queries being logged.",
              "value": "true"
            },
            "dbms.auto_index.nodes.enabled": {
              "description": "Controls the auto indexing feature for nodes. Setting it to `false` shuts it down, while `true` enables it by default for properties listed in the dbms.auto_index.nodes.keys setting.",
              "value": "false"
            },
            "unsupported.cypher.idp_solver_duration_threshold": {
              "description": "To improve IDP query planning time, we can restrict the internal planning loop duration, triggering more frequent compaction of candidate plans. The smaller the threshold the faster the planning, but the higher the risk of sub-optimal plans.",
              "value": "1000"
            },
            "unsupported.dbms.multi_threaded_schema_index_population_enabled": {
              "description": "Configuration attribute",
              "value": "true"
            },
            "dbms.relationship_grouping_threshold": {
              "description": "Relationship count threshold for considering a node to be dense",
              "value": "50"
            },
            "causal_clustering.load_balancing.shuffle": {
              "description": "Enables shuffling of the returned load balancing result.",
              "value": "true"
            },
            "unsupported.dbms.db.spatial.crs.cartesian.y.min": {
              "description": "The minimum y value for the index extents for 2D cartesian spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-1000000.0"
            },
            "dbms.logs.user.stdout_enabled": {
              "description": "Send user logs to the process stdout. If this is disabled then logs will instead be sent to the file _neo4j.log_ located in the logs directory. For location of the Logs directory, see <<file-locations>>.",
              "value": "true"
            },
            "dbms.security.ldap.authorization.group_membership_attributes": {
              "description": "A list of attribute names on a user object that contains groups to be used for mapping to roles when LDAP authorization is enabled.",
              "value": "[memberOf]"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84.y.min": {
              "description": "The minimum y value for the index extents for 2D wgs-84 spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-90.0"
            },
            "cypher.default_language_version": {
              "description": "Set this to specify the default parser (language version).",
              "value": "default"
            },
            "unsupported.dbms.uris.browser": {
              "description": "Configuration attribute",
              "value": "/browser/"
            },
            "causal_clustering.middleware.akka.failure_detector.threshold": {
              "description": "Akka cluster phi accrual failure detector. Defines the failure detector threshold. A low threshold is prone to generate many wrong suspicions but ensures a quick detection in the event of a real crash. Conversely, a high threshold generates fewer mistakes but needs more time to detect actual crashes.",
              "value": "10.0"
            },
            "causal_clustering.minimum_core_cluster_size_at_runtime": {
              "description": "Minimum number of Core machines required to be available at runtime. The consensus group size (core machines successfully voted into the Raft) can shrink and grow dynamically but bounded on the lower end at this number. The intention is in almost all cases for users to leave this setting alone. If you have 5 machines then you can survive failures down to 3 remaining, e.g. with 2 dead members. The three remaining can still vote another replacement member in successfully up to a total of 6 (2 of which are still dead) and then after this, one of the superfluous dead members will be immediately and automatically voted out (so you are left with 5 members in the consensus group, 1 of which is currently dead). Operationally you can now bring the last machine up by bringing in another replacement or repairing the dead one. When using multi-clustering (configuring multiple distinct database names across core hosts), this setting is used to define the minimum size of *each* sub-cluster at runtime.",
              "value": "3"
            },
            "dbms.logs.debug.rotation.keep_number": {
              "description": "Maximum number of history files for the debug log.",
              "value": "7"
            },
            "causal_clustering.raft_in_queue_size": {
              "description": "Maximum number of entries in the RAFT in-queue",
              "value": "1024"
            },
            "https.ssl_policy": {
              "description": "SSL policy name.",
              "value": "legacy"
            },
            "causal_clustering.neostore_block_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of NEOSTORE_BLOCK IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "dbms.lock.acquisition.timeout": {
              "description": "The maximum time interval within which lock should be acquired.",
              "value": "0ms"
            },
            "ha.broadcast_timeout": {
              "description": "Timeout for broadcasting values in cluster. Must consider end-to-end duration of Paxos algorithm. This value is the default value for the ha.join_timeout and ha.leave_timeout settings.",
              "value": "30000ms"
            },
            "unsupported.dbms.record_id_batch_size": {
              "description": "Specifies the size of id batches local to each transaction when committing. Committing a transaction which contains changes most often results in new data records being created. For each record a new id needs to be generated from an id generator. It's more efficient to allocate a batch of ids from the contended id generator, which the transaction holds and generates ids from while creating these new records. This setting specifies how big those batches are. Remaining ids are freed back to id generator on clean shutdown.",
              "value": "20"
            },
            "metrics.graphite.enabled": {
              "description": "Set to `true` to enable exporting metrics to Graphite.",
              "value": "false"
            },
            "dbms.security.ldap.authorization.user_search_base": {
              "description": "The name of the base object or named context to search for user objects when LDAP authorization is enabled. A common case is that this matches the last part of `dbms.security.ldap.authentication.user_dn_template`.",
              "value": "ou=users,dc=example,dc=com"
            },
            "ha.pull_batch_size": {
              "description": "Size of batches of transactions applied on slaves when pulling from master",
              "value": "100"
            },
            "causal_clustering.label_token_name_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of LABEL_TOKEN_NAME IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "metrics.cypher.replanning.enabled": {
              "description": "Enable reporting metrics about number of occurred replanning events.",
              "value": "true"
            },
            "dbms.logs.query.time_logging_enabled": {
              "description": "Log detailed time information for the executed queries being logged. Requires `dbms.track_query_cpu_time=true`",
              "value": "false"
            },
            "unsupported.dbms.id_generator_fast_rebuild_enabled": {
              "description": "Use a quick approach for rebuilding the ID generators. This give quicker recovery time, but will limit the ability to reuse the space of deleted entities.",
              "value": "true"
            },
            "unsupported.dbms.block_size.array_properties": {
              "description": "Specifies the block size for storing arrays. This parameter is only honored when the store is created, otherwise it is ignored. Also note that each block carries a ~10B of overhead so record size on disk will be slightly larger than the configured block size",
              "value": "120"
            },
            "dbms.import.csv.buffer_size": {
              "description": "The size of the internal buffer in bytes used by `LOAD CSV`. If the csv file contains huge fields this value may have to be increased.",
              "value": "2097152"
            },
            "dbms.ssl.policy.<policyname>.verify_hostname": {
              "description": "When true, this node will verify the hostname of every other instance it connects to by comparing the address it used to connect with it and the patterns described in the remote hosts public certificate Subject Alternative Names",
              "value": "false"
            },
            "causal_clustering.raft_membership_state_size": {
              "description": "The maximum file size before the membership state file is rotated (in unit of entries)",
              "value": "1000"
            },
            "causal_clustering.handshake_timeout": {
              "description": "Time out for protocol negotiation handshake",
              "value": "20000ms"
            },
            "causal_clustering.middleware.akka.sink-parallelism": {
              "description": "Parallelism level of dispatcher used for communication from Akka based cluster topology discovery ",
              "value": "2"
            },
            "dbms.security.procedures.whitelist": {
              "description": "A list of procedures (comma separated) that are to be loaded. The list may contain both fully-qualified procedure names, and partial names with the wildcard '*'. If this setting is left empty no procedures will be loaded.",
              "value": "*"
            },
            "dbms.security.auth_max_failed_attempts": {
              "description": "The maximum number of unsuccessful authentication attempts before imposing a user lock for the configured amount of time.The locked out user will not be able to log in until the lock period expires, even if correct credentials are provided. Setting this configuration option to values less than 3 is not recommended because it might make it easier for an attacker to brute force the password.",
              "value": "3"
            },
            "dbms.security.ldap.authorization.use_system_account": {
              "description": "Perform LDAP search for authorization info using a system account instead of the user's own account.\n\nIf this is set to `false` (default), the search for group membership will be performed directly after authentication using the LDAP context bound with the user's own account. The mapped roles will be cached for the duration of `dbms.security.auth_cache_ttl`, and then expire, requiring re-authentication. To avoid frequently having to re-authenticate sessions you may want to set a relatively long auth cache expiration time together with this option. NOTE: This option will only work if the users are permitted to search for their own group membership attributes in the directory.\n\nIf this is set to `true`, the search will be performed using a special system account user with read access to all the users in the directory. You need to specify the username and password using the settings `dbms.security.ldap.authorization.system_username` and `dbms.security.ldap.authorization.system_password` with this option. Note that this account only needs read access to the relevant parts of the LDAP directory and does not need to have access rights to Neo4j, or any other systems.",
              "value": "false"
            },
            "metrics.prometheus.endpoint": {
              "description": "The hostname and port to use as Prometheus endpoint",
              "value": "localhost:2004"
            },
            "dbms.security.property_level.blacklist": {
              "description": "An authorization mapping for property level access for roles. The map should be formatted as a semicolon separated list of key-value pairs, where the key is the role name and the value is a comma separated list of blacklisted properties. For example: role1=prop1;role2=prop2;role3=prop3,prop4,prop5\n\nYou could also use whitespaces and quotes around group names to make this mapping more readable, for example: dbms.security.property_level.blacklist=\\\n         \"role1\"      = ssn;    \\\n         \"role2\"      = ssn,income; \\\n\nDeprecated: This will be replaced by dynamic configuration in the system graph in 4.0, including a migration step for the existing setting value.",
              "value": null
            },
            "dbms.checkpoint.iops.limit": {
              "description": "Limit the number of IOs the background checkpoint process will consume per second. This setting is advisory, is ignored in Neo4j Community Edition, and is followed to best effort in Enterprise Edition. An IO is in this case a 8 KiB (mostly sequential) write. Limiting the write IO in this way will leave more bandwidth in the IO subsystem to service random-read IOs, which is important for the response time of queries when the database cannot fit entirely in memory. The only drawback of this setting is that longer checkpoint times may lead to slightly longer recovery times in case of a database or system crash. A lower number means lower IO pressure, and consequently longer checkpoint times. The configuration can also be commented out to remove the limitation entirely, and let the checkpointer flush data as fast as the hardware will go. Set this to -1 to disable the IOPS limit.",
              "value": "300"
            },
            "unsupported.dbms.memory.pagecache.warmup.profile.interval": {
              "description": "The profiling frequency for the page cache. Accurate profiles allow the page cache to do active warmup after a restart, reducing the mean time to performance. This feature available in Neo4j Enterprise Edition.",
              "value": "60000ms"
            },
            "dbms.transaction.timeout": {
              "description": "The maximum time interval of a transaction within which it should be completed.",
              "value": "0ms"
            },
            "dbms.logs.gc.options": {
              "description": "GC Logging Options",
              "value": "-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintPromotionFailure -XX:+PrintTenuringDistribution"
            },
            "causal_clustering.read_replica_time_to_live": {
              "description": "Time To Live before read replica is considered unavailable",
              "value": "60000ms"
            },
            "unsupported.dbms.transaction_start_timeout": {
              "description": "The maximum amount of time to wait for the database to become available, when starting a new transaction.",
              "value": "1000ms"
            },
            "causal_clustering.middleware.akka.failure_detector.min_std_deviation": {
              "description": "Akka cluster phi accrual failure detector. Minimum standard deviation to use for the normal distribution in AccrualFailureDetector. Too low standard deviation might result in too much sensitivity for sudden, but normal, deviations in heartbeat inter arrival times.",
              "value": "100ms"
            },
            "dbms.connector.bolt.tls_level": {
              "description": "Encryption level to require this connector to use.",
              "value": "REQUIRED"
            },
            "metrics.neo4j.tx.enabled": {
              "description": "Enable reporting metrics about transactions; number of transactions started, committed, etc.",
              "value": "true"
            },
            "unsupported.dbms.db.spatial.crs.cartesian-3d.x.min": {
              "description": "The minimum x value for the index extents for 3D cartesian-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-1000000.0"
            },
            "causal_clustering.cluster_binding_timeout": {
              "description": "Configures the time after which we give up trying to bind to a cluster formed of the other initial discovery members.",
              "value": "300000ms"
            },
            "dbms.security.ha_status_auth_enabled": {
              "description": "Require authorization for access to the HA status endpoints.",
              "value": "true"
            },
            "dbms.security.procedures.unrestricted": {
              "description": "A list of procedures and user defined functions (comma separated) that are allowed full access to the database. The list may contain both fully-qualified procedure names, and partial names with the wildcard '*'. Note that this enables these procedures to bypass security. Use with caution.",
              "value": "\"apoc.*,algo.*\""
            },
            "unsupported.dbms.uris.management": {
              "description": "Configuration attribute",
              "value": "/db/manage"
            },
            "ha.server_id": {
              "description": "Id for a cluster instance. Must be unique within the cluster.",
              "value": null
            },
            "causal_clustering.array_block_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of ARRAY_BLOCK IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "dbms.logs.query.rotation.size": {
              "description": "The file size in bytes at which the query log will auto-rotate. If set to zero then no rotation will occur. Accepts a binary suffix `k`, `m` or `g`.",
              "value": "20971520"
            },
            "unsupported.dbms.udc.first_delay": {
              "description": "Configuration attribute",
              "value": "600000"
            },
            "dbms.security.ldap.read_timeout": {
              "description": "The timeout for an LDAP read request (i.e. search). If the LDAP server does not respond within the given time the request will be aborted. A value of 0 means wait for a response indefinitely.",
              "value": "30000ms"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84.x.min": {
              "description": "The minimum x value for the index extents for 2D wgs-84 spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-180.0"
            },
            "unsupported.dbms.udc.interval": {
              "description": "Configuration attribute",
              "value": "86400000"
            },
            "unsupported.dbms.index.spatial.curve.max_bits": {
              "description": "The maximum number of bits to use for levels in the quad tree representing the spatial index. When creating the spatial index, we simulate a quad tree using a 2D (or 3D) to 1D mapping function. This requires that the extents of the index and the depth of the tree be defined in advance, so ensure the 2D to 1D mapping is deterministic and repeatable. This setting will define the maximum depth of any future spatial index created, calculated as max_bits / dimensions. For example 60 bits will define 30 levels in 2D and 20 levels in 3D. Existing indexes will not be changed, and need to be recreated if you wish to use the new value. For 2D indexes, a value of 30 is the largest supported. For 3D indexes 20 is the largest.",
              "value": "60"
            },
            "dbms.unmanaged_extension_classes": {
              "description": "Comma-separated list of <classname>=<mount point> for unmanaged extensions.",
              "value": "[]"
            },
            "causal_clustering.property_key_token_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of PROPERTY_KEY_TOKEN IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "32"
            },
            "dbms.auto_index.relationships.enabled": {
              "description": "Controls the auto indexing feature for relationships. Setting it to `false` shuts it down, while `true` enables it by default for properties listed in the dbms.auto_index.relationships.keys setting.",
              "value": "false"
            },
            "metrics.graphite.interval": {
              "description": "The reporting interval for Graphite. That is, how often to send updated metrics to Graphite.",
              "value": "3000ms"
            },
            "unsupported.dbms.bolt.outbound_buffer_throttle.low_watermark": {
              "description": "When the size (in bytes) of outbound network buffers, previously advertised as unwritable, gets below this value bolt channel will re-advertise itself as writable and blocked processing thread will resume execution.",
              "value": "131072"
            },
            "unsupported.tools.batch_inserter.batch_size": {
              "description": "Specifies number of operations that batch inserter will try to group into one batch before flushing data into underlying storage.",
              "value": "10000"
            },
            "causal_clustering.middleware.akka.failure_detector.acceptable_heartbeat_pause": {
              "description": "Akka cluster phi accrual failure detector. Number of potentially lost/delayed heartbeats that will be accepted before considering it to be an anomaly. This margin is important to be able to survive sudden, occasional, pauses in heartbeat arrivals, due to for example garbage collect or network drop.",
              "value": "4000ms"
            },
            "causal_clustering.leader_election_timeout": {
              "description": "The time limit within which a new leader election will occur if no messages are received.",
              "value": "7000ms"
            },
            "ha.pull_interval": {
              "description": "Interval of pulling updates from master.",
              "value": "10000ms"
            },
            "cypher.statistics_divergence_threshold": {
              "description": "The threshold when a plan is considered stale. If any of the underlying statistics used to create the plan have changed more than this value, the plan will be considered stale and will be replanned. Change is calculated as abs(a-b)/max(a,b). This means that a value of 0.75 requires the database to approximately quadruple in size. A value of 0 means replan as soon as possible, with the soonest being defined by the cypher.min_replan_interval which defaults to 10s. After this interval the divergence threshold will slowly start to decline, reaching 10% after about 7h. This will ensure that long running databases will still get query replanning on even modest changes, while not replanning frequently unless the changes are very large.",
              "value": "0.75"
            },
            "dbms.connector.https.enabled": {
              "description": "Enable this connector.",
              "value": "true"
            },
            "unsupported.dbms.query.snapshot": {
              "description": "Specifies if engine should run cypher query based on a snapshot of accessed data. Query will be restarted in case if concurrent modification of data will be detected.",
              "value": "false"
            },
            "unsupported.cypher.non_indexed_label_warning_threshold": {
              "description": "The threshold when a warning is generated if a label scan is done after a load csv where the label has no index",
              "value": "10000"
            },
            "unsupported.dbms.db.spatial.crs.cartesian.x.max": {
              "description": "The maximum x value for the index extents for 2D cartesian spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "1000000.0"
            },
            "causal_clustering.store_copy_max_retry_time_per_request": {
              "description": "Maximum retry time per request during store copy. Regular store files and indexes are downloaded in separate requests during store copy. This configures the maximum time failed requests are allowed to resend. ",
              "value": "1200000ms"
            },
            "unsupported.cypher.number_of_workers": {
              "description": "Number of threads to allocate to Cypher worker threads. If set to 0, two workers will be started for every physical core in the system.",
              "value": "0"
            },
            "unsupported.dbms.memory.pagecache.warmup.enable": {
              "description": "Page cache can be configured to perform usage sampling of loaded pages that can be used to construct active load profile. According to that profile pages can be reloaded on the restart, replication, etc. This setting allows disabling that behavior. This feature available in Neo4j Enterprise Edition.",
              "value": "true"
            },
            "dbms.active_database": {
              "description": "Name of the database to load",
              "value": "graph.db"
            },
            "dbms.tx_state.memory_allocation": {
              "description": "Defines whether memory for transaction state should be allocated on- or off-heap.",
              "value": "ON_HEAP"
            },
            "unsupported.dbms.block_size.strings": {
              "description": "Specifies the block size for storing strings. This parameter is only honored when the store is created, otherwise it is ignored. Note that each character in a string occupies two bytes, meaning that e.g a block size of 120 will hold a 60 character long string before overflowing into a second block. Also note that each block carries a ~10B of overhead so record size on disk will be slightly larger than the configured block size",
              "value": "120"
            },
            "unsupported.cypher.compiler_tracing": {
              "description": "Enable tracing of compilation in cypher.",
              "value": "false"
            },
            "dbms.connector.https.listen_address": {
              "description": "Address the connector should bind to.",
              "value": "0.0.0.0:7473"
            },
            "dbms.logs.timezone": {
              "description": "Database logs timezone.",
              "value": "UTC"
            },
            "metrics.csv.rotation.size": {
              "description": "The file size in bytes at which the csv files will auto-rotate. If set to zero then no rotation will occur. Accepts a binary suffix `k`, `m` or `g`.",
              "value": "10485760"
            },
            "causal_clustering.transaction_advertised_address": {
              "description": "Advertised hostname/IP address and port for the transaction shipping server.",
              "value": "10.142.0.3:6000"
            },
            "dbms.security.ldap.authorization.user_search_filter": {
              "description": "The LDAP search filter to search for a user principal when LDAP authorization is enabled. The filter should contain the placeholder token {0} which will be substituted for the user principal.",
              "value": "(&(objectClass=*)(uid={0}))"
            },
            "causal_clustering.id_alloc_state_size": {
              "description": "The maximum file size before the ID allocation file is rotated (in unit of entries)",
              "value": "1000"
            },
            "causal_clustering.relationship_type_token_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP_TYPE_TOKEN IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "32"
            },
            "dbms.auto_index.relationships.keys": {
              "description": "A list of property names (comma separated) that will be indexed by default. This applies to _relationships_ only.",
              "value": "[]"
            },
            "ha.leave_timeout": {
              "description": "Timeout for waiting for cluster leave to finish. Defaults to ha.broadcast_timeout.",
              "value": "30000ms"
            },
            "causal_clustering.in_flight_cache.max_bytes": {
              "description": "The maximum number of bytes in the in-flight cache.",
              "value": "2147483648"
            },
            "causal_clustering.transaction_listen_address": {
              "description": "Network interface and port for the transaction shipping server to listen on. Please note that it is also possible to run the backup client against this port so always limit access to it via the firewall and configure an ssl policy.",
              "value": "0.0.0.0:6000"
            },
            "unsupported.cypher.enable_morsel_runtime_trace": {
              "description": "Enable tracing of morsel runtime scheduler.",
              "value": "false"
            },
            "dbms.directories.plugins": {
              "description": "Location of the database plugin directory. Compiled Java JAR files that contain database procedures will be loaded if they are placed in this directory.",
              "value": "/var/lib/neo4j/plugins"
            },
            "metrics.jvm.buffers.enabled": {
              "description": "Enable reporting metrics about the buffer pools.",
              "value": "true"
            },
            "causal_clustering.server_groups": {
              "description": "A list of group names for the server used when configuring load balancing and replication policies.",
              "value": "[]"
            },
            "unsupported.dbms.wadl_generation_enabled": {
              "description": "Configuration attribute",
              "value": "false"
            },
            "causal_clustering.ssl_policy": {
              "description": "Name of the SSL policy to be used by the clustering, as defined under the dbms.ssl.policy.* settings. If no policy is configured then the communication will not be secured.",
              "value": null
            },
            "dbms.index.fulltext.default_analyzer": {
              "description": "The name of the analyzer that the fulltext indexes should use by default.",
              "value": "standard"
            },
            "dbms.backup.enabled": {
              "description": "Enable support for running online backups",
              "value": "true"
            },
            "causal_clustering.catchup_batch_size": {
              "description": "The maximum batch size when catching up (in unit of entries)",
              "value": "64"
            },
            "dbms.logs.query.rotation.keep_number": {
              "description": "Maximum number of history files for the query log.",
              "value": "7"
            },
            "causal_clustering.protocol_implementations.compression": {
              "description": "Network compression algorithms that this instance will allow in negotiation as a comma-separated list. Listed in descending order of preference for incoming connections. An empty list implies no compression. For outgoing connections this merely specifies the allowed set of algorithms and the preference of the  remote peer will be used for making the decision. Allowable values: [Gzip,Snappy,Snappy_validating,LZ4,LZ4_high_compression,LZ_validating,LZ4_high_compression_validating]",
              "value": "[]"
            },
            "dbms.read_only": {
              "description": "Only allow read operations from this Neo4j instance. This mode still requires write access to the directory for lock purposes.",
              "value": "false"
            },
            "dbms.logs.query.runtime_logging_enabled": {
              "description": "Logs which runtime that was used to run the query",
              "value": "false"
            },
            "dbms.tx_log.rotation.retention_policy": {
              "description": "Make Neo4j keep the logical transaction logs for being able to backup the database. Can be used for specifying the threshold to prune logical logs after. For example \"10 days\" will prune logical logs that only contains transactions older than 10 days from the current time, or \"100k txs\" will keep the 100k latest transactions and prune any older transactions.",
              "value": "7 days"
            },
            "dbms.security.auth_lock_time": {
              "description": "The amount of time user account should be locked after a configured number of unsuccessful authentication attempts. The locked out user will not be able to log in until the lock period expires, even if correct credentials are provided. Setting this configuration option to a low value is not recommended because it might make it easier for an attacker to brute force the password.",
              "value": "5000ms"
            },
            "dbms.logs.query.threshold": {
              "description": "If the execution of query takes more time than this threshold, the query is logged - provided query logging is enabled. Defaults to 0 seconds, that is all queries are logged.",
              "value": "0ms"
            },
            "dbms.ssl.policy.<policyname>.private_key_password": {
              "description": "The password for the private key.",
              "value": null
            },
            "dbms.windows_service_name": {
              "description": "Name of the Windows Service.",
              "value": "neo4j"
            },
            "dbms.security.procedures.roles": {
              "description": "This provides a finer level of control over which roles can execute procedures than the `dbms.security.procedures.default_allowed` setting. For example: `+dbms.security.procedures.roles=apoc.convert.*:reader;apoc.load.json*:writer;apoc.trigger.add:TriggerHappy+` will allow the role `reader` to execute all procedures in the `apoc.convert` namespace, the role `writer` to execute all procedures in the `apoc.load` namespace that starts with `json` and the role `TriggerHappy` to execute the specific procedure `apoc.trigger.add`. Procedures not matching any of these patterns will be subject to the `dbms.security.procedures.default_allowed` setting.\nDeprecated: This will be replaced by dynamic configuration in the system graph in 4.0, including a migration step for the existing setting value.",
              "value": ""
            },
            "ha.initial_hosts": {
              "description": "A comma-separated list of other members of the cluster to join.",
              "value": null
            },
            "dbms.security.plugin.authentication_enabled": {
              "description": "Enable authentication via plugin authentication providers.",
              "value": "false"
            },
            "dbms.ssl.policy.<policyname>.public_certificate": {
              "description": "X.509 certificate (chain) of this server in PEM format.",
              "value": "public.crt"
            },
            "dbms.allow_format_migration": {
              "description": "Whether to allow a store upgrade in case the current version of the database starts against an older store version. Setting this to `true` does not guarantee successful upgrade, it just allows an upgrade to be performed.",
              "value": "false"
            },
            "unsupported.dbms.udc.source": {
              "description": "Configuration attribute",
              "value": "maven"
            },
            "unsupported.dbms.db.spatial.crs.cartesian-3d.y.max": {
              "description": "The maximum y value for the index extents for 3D cartesian-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "1000000.0"
            },
            "dbms.threads.worker_count": {
              "description": "Number of Neo4j worker threads, your OS might enforce a lower limit than the maximum value specified here.",
              "value": "4"
            },
            "dbms.connector.http.enabled": {
              "description": "Enable this connector.",
              "value": "true"
            },
            "metrics.bolt.messages.enabled": {
              "description": "Enable reporting metrics about Bolt Protocol message processing.",
              "value": "true"
            },
            "dbms.mode": {
              "description": "Configure the operating mode of the database -- 'SINGLE' for stand-alone operation, 'HA' for operating as a member in an HA cluster, 'ARBITER' for a cluster member with no database in an HA cluster, 'CORE' for operating as a core member of a Causal Cluster, or 'READ_REPLICA' for operating as a read replica member of a Causal Cluster.",
              "value": "CORE"
            },
            "unsupported.dbms.executiontime_limit.time": {
              "description": "If execution time limiting is enabled in the database, this configures the maximum request execution time. Please use dbms.transaction.timeout instead.",
              "value": null
            },
            "dbms.checkpoint": {
              "description": "Configures the general policy for when check-points should occur. The default policy is the 'periodic' check-point policy, as specified by the 'dbms.checkpoint.interval.tx' and 'dbms.checkpoint.interval.time' settings. The Neo4j Enterprise Edition provides two alternative policies: The first is the 'continuous' check-point policy, which will ignore those settings and run the check-point process all the time. The second is the 'volumetric' check-point policy, which makes a best-effort at check-pointing often enough so that the database doesn't get too far behind on deleting old transaction logs in accordance with the 'dbms.tx_log.rotation.retention_policy' setting.",
              "value": "periodic"
            },
            "unsupported.dbms.security.module": {
              "description": "Configuration attribute",
              "value": "enterprise-security-module"
            },
            "dbms.index.fulltext.eventually_consistent": {
              "description": "Whether or not fulltext indexes should be eventually consistent by default or not.",
              "value": "false"
            },
            "dbms.logs.http.rotation.keep_number": {
              "description": "Number of HTTP logs to keep.",
              "value": "5"
            },
            "unsupported.dbms.console_module.engines": {
              "description": "Configuration attribute",
              "value": "[SHELL]"
            },
            "metrics.neo4j.enabled": {
              "description": "The default enablement value for all Neo4j specific support metrics. Set this to `false` to turn off all Neo4j specific metrics by default. The individual `metrics.neo4j.*` metrics can then be turned on selectively.",
              "value": "true"
            },
            "causal_clustering.raft_listen_address": {
              "description": "Network interface and port for the RAFT server to listen on.",
              "value": "0.0.0.0:7000"
            },
            "dbms.security.ldap.authentication.mechanism": {
              "description": "LDAP authentication mechanism. This is one of `simple` or a SASL mechanism supported by JNDI, for example `DIGEST-MD5`. `simple` is basic username and password authentication and SASL is used for more advanced mechanisms. See RFC 2251 LDAPv3 documentation for more details.",
              "value": "simple"
            },
            "ha.paxos_timeout": {
              "description": "Default value for all Paxos timeouts. This setting controls the default value for the ha.phase1_timeout, ha.phase2_timeout and ha.election_timeout settings. If it is not given a value it defaults to ha.default_timeout and will implicitly change if ha.default_timeout changes. This is an advanced parameter which should only be changed if specifically advised by Neo4j Professional Services.",
              "value": "5000ms"
            },
            "unsupported.dbms.db.spatial.crs.cartesian.y.max": {
              "description": "The maximum y value for the index extents for 2D cartesian spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "1000000.0"
            },
            "dbms.security.ldap.connection_timeout": {
              "description": "The timeout for establishing an LDAP connection. If a connection with the LDAP server cannot be established within the given time the attempt is aborted. A value of 0 means to use the network protocol's (i.e., TCP's) timeout value.",
              "value": "30000ms"
            },
            "dbms.record_format": {
              "description": "Database record format. Valid values: `standard`, `high_limit`. The `high_limit` formatis available for Enterprise Edition only. It is required if you have a graph that is larger than 34 billion nodes, 34 billion relationships, or 68 billion properties. A change of the record format is irreversible. Certain operations may suffer from a performance penalty of up to 10%, which is why this format is not switched on by default.",
              "value": ""
            },
            "unsupported.dbms.discoverable_bolt_routing_address": {
              "description": "Publicly discoverable bolt+routing:// URI to use for Neo4j Drivers wanting to access a cluster that this instance is a member of. Only applicable to causal clusters.",
              "value": ""
            },
            "ha.strict_initial_hosts": {
              "description": "Configuration attribute",
              "value": "false"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84-3d.x.max": {
              "description": "The maximum x value for the index extents for 3D wgs-84-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "180.0"
            },
            "ha.internal_role_switch_timeout": {
              "description": "Timeout for waiting for internal conditions during state switch, like for transactions to complete, before switching to master or slave.",
              "value": "10000ms"
            },
            "dbms.security.property_level.enabled": {
              "description": "Set to true to enable property level security.",
              "value": "false"
            },
            "causal_clustering.raft_log_rotation_size": {
              "description": "RAFT log rotation size",
              "value": "262144000"
            },
            "ha.data_chunk_size": {
              "description": "Max size of the data chunks that flows between master and slaves in HA. Bigger size may increase throughput, but may also be more sensitive to variations in bandwidth, whereas lower size increases tolerance for bandwidth variations.",
              "value": "2097152"
            },
            "causal_clustering.connect-randomly-to-server-group": {
              "description": "Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy. The connect-randomly-to-server-group strategy is used if the list of strategies (`causal_clustering.upstream_selection_strategy`) includes the value `connect-randomly-to-server-group`. ",
              "value": "[]"
            },
            "dbms.ssl.policy.<policyname>.revoked_dir": {
              "description": "Path to directory of CRLs (Certificate Revocation Lists) in PEM format.",
              "value": "revoked"
            },
            "causal_clustering.string_block_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of STRING_BLOCK IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "unsupported.dbms.directories.auth": {
              "description": "Configuration attribute",
              "value": "/var/lib/neo4j/data/dbms"
            },
            "dbms.directories.data": {
              "description": "Path of the data directory. You must not configure more than one Neo4j installation to use the same data directory.",
              "value": "/var/lib/neo4j/data"
            },
            "dbms.logs.gc.enabled": {
              "description": "Enable GC Logging",
              "value": "false"
            },
            "causal_clustering.kubernetes.address": {
              "description": "Address for Kubernetes API",
              "value": "kubernetes.default.svc:443"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84-3d.z.min": {
              "description": "The minimum z value for the index extents for 3D wgs-84-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-1000000.0"
            },
            "unsupported.dbms.edition": {
              "description": "Configuration attribute",
              "value": "enterprise"
            },
            "dbms.track_query_cpu_time": {
              "description": "Enables or disables tracking of how much time a query spends actively executing on the CPU. Calling `dbms.listQueries` will display the time. This can also be logged in the query log by using `log_queries_detailed_time_logging_enabled`.",
              "value": "false"
            },
            "dbms.ssl.policy.<policyname>.ciphers": {
              "description": "Restrict allowed ciphers.",
              "value": null
            },
            "unsupported.cypher.idp_solver_table_threshold": {
              "description": "To improve IDP query planning time, we can restrict the internal planning table size, triggering compaction of candidate plans. The smaller the threshold the faster the planning, but the higher the risk of sub-optimal plans.",
              "value": "128"
            },
            "dbms.logs.http.rotation.size": {
              "description": "Size of each HTTP log that is kept.",
              "value": "20971520"
            },
            "dbms.logs.user.rotation.keep_number": {
              "description": "Maximum number of history files for the user log.",
              "value": "7"
            },
            "causal_clustering.cluster_topology_refresh": {
              "description": "Time between scanning the cluster to refresh current server's view of topology",
              "value": "5000ms"
            },
            "dbms.security.log_successful_authentication": {
              "description": "Set to log successful authentication events to the security log. If this is set to `false` only failed authentication events will be logged, which could be useful if you find that the successful events spam the logs too much, and you do not require full auditing capability.",
              "value": "true"
            },
            "dbms.logs.query.enabled": {
              "description": "Log executed queries that take longer than the configured threshold, dbms.logs.query.threshold. Log entries are by default written to the file _query.log_ located in the Logs directory. For location of the Logs directory, see <<file-locations>>. This feature is available in the Neo4j Enterprise Edition.",
              "value": "false"
            },
            "causal_clustering.label_token_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of LABEL_TOKEN IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "32"
            },
            "dbms.security.ldap.referral": {
              "description": "The LDAP referral behavior when creating a connection. This is one of `follow`, `ignore` or `throw`.\n\n* `follow` automatically follows any referrals\n* `ignore` ignores any referrals\n* `throw` throws an exception, which will lead to authentication failure",
              "value": "follow"
            },
            "dbms.checkpoint.interval.time": {
              "description": "Configures the time interval between check-points. The database will not check-point more often than this (unless check pointing is triggered by a different event), but might check-point less often than this interval, if performing a check-point takes longer time than the configured interval. A check-point is a point in the transaction logs, from which recovery would start from. Longer check-point intervals typically means that recovery will take longer to complete in case of a crash. On the other hand, a longer check-point interval can also reduce the I/O load that the database places on the system, as each check-point implies a flushing and forcing of all the store files.",
              "value": "900000ms"
            },
            "dbms.security.http_access_control_allow_origin": {
              "description": "Value of the Access-Control-Allow-Origin header sent over any HTTP or HTTPS connector. This defaults to '*', which allows broadest compatibility. Note that any URI provided here limits HTTP/HTTPS access to that URI only.",
              "value": "*"
            },
            "unsupported.dbms.db.spatial.crs.cartesian-3d.z.min": {
              "description": "The minimum z value for the index extents for 3D cartesian-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-1000000.0"
            },
            "dbms.logs.user.path": {
              "description": "Path to the user log file.",
              "value": "/var/log/neo4j/neo4j.log"
            },
            "dbms.ssl.policy.<policyname>.allow_key_generation": {
              "description": "Allows the generation of a private key and associated self-signed certificate. Only performed when both objects cannot be found.",
              "value": "false"
            },
            "dbms.logs.user.rotation.delay": {
              "description": "Minimum time interval after last rotation of the user log before it may be rotated again.",
              "value": "300000ms"
            },
            "unsupported.cypher.task_wait": {
              "description": "Duration in milliseconds that parallel runtime waits on a task before trying another task",
              "value": "30000"
            },
            "metrics.neo4j.logrotation.enabled": {
              "description": "Enable reporting metrics about the Neo4j log rotation; when it occurs and how much time it takes to complete.",
              "value": "true"
            },
            "browser.post_connect_cmd": {
              "description": "Commands to be run when Neo4j Browser successfully connects to this server. Separate multiple commands with semi-colon.",
              "value": ""
            },
            "unsupported.vm_pause_monitor.stall_alert_threshold": {
              "description": "Configuration attribute",
              "value": "100ms"
            },
            "metrics.neo4j.causal_clustering.enabled": {
              "description": "Enable reporting metrics about Causal Clustering mode.",
              "value": "true"
            },
            "causal_clustering.node_labels_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of NODE_LABELS IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "dbms.security.ldap.authentication_enabled": {
              "description": "Enable authentication via settings configurable LDAP authentication provider.",
              "value": "false"
            },
            "dbms.logs.security.level": {
              "description": "Security log level threshold.",
              "value": "INFO"
            },
            "dbms.logs.http.enabled": {
              "description": "Enable HTTP request logging.",
              "value": "false"
            },
            "unsupported.dbms.db.spatial.crs.cartesian-3d.x.max": {
              "description": "The maximum x value for the index extents for 3D cartesian-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "1000000.0"
            },
            "dbms.tx_log.rotation.size": {
              "description": "Specifies at which file size the logical log will auto-rotate. Minimum accepted value is 1M. ",
              "value": "262144000"
            },
            "dbms.security.allow_csv_import_from_file_urls": {
              "description": "Determines if Cypher will allow using file URLs when loading data using `LOAD CSV`. Setting this value to `false` will cause Neo4j to fail `LOAD CSV` clauses that load data from the file system.",
              "value": "true"
            },
            "dbms.logs.http.path": {
              "description": "Path to HTTP request log.",
              "value": "/var/log/neo4j/http.log"
            },
            "dbms.security.ldap.use_starttls": {
              "description": "Use secure communication with the LDAP server using opportunistic TLS. First an initial insecure connection will be made with the LDAP server, and a STARTTLS command will be issued to negotiate an upgrade of the connection to TLS before initiating authentication.",
              "value": "false"
            },
            "dbms.import.csv.legacy_quote_escaping": {
              "description": "Selects whether to conform to the standard https://tools.ietf.org/html/rfc4180 for interpreting escaped quotation characters in CSV files loaded using `LOAD CSV`. Setting this to `false` will use the standard, interpreting repeated quotes '\"\"' as a single in-lined quote, while `true` will use the legacy convention originally supported in Neo4j 3.0 and 3.1, allowing a backslash to include quotes in-lined in fields.",
              "value": "true"
            },
            "unsupported.dbms.index.spatial.curve.extra_levels": {
              "description": "When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. This setting will cause the algorithm to search deeper, reducing false positives.",
              "value": "1"
            },
            "dbms.index.default_schema_provider": {
              "description": "Index provider to use for newly created schema indexes. An index provider may store different value types in separate physical indexes. lucene-1.0: Spatial and temporal value types are stored in native indexes, remaining value types in Lucene index. lucene+native-1.0: Spatial, temporal and number value types are stored in native indexes and remaining value types in Lucene index. lucene+native-2.0: Spatial, temporal, number and string value types are stored in native indexes and remaining value types in Lucene index. native-btree-1.0: All value types and arrays of all value types, even composite keys, are stored in one native index. A native index has faster updates, less heap and CPU usage compared to a Lucene index. A native index has these limitations: Index key (be it single or composite) size limit of 4039 bytes - transaction resulting in index key surpassing that will fail. Reduced performance of CONTAINS and ENDS WITH string index queries, compared to a Lucene index.",
              "value": "native-btree-1.0"
            },
            "cypher.forbid_shortestpath_common_nodes": {
              "description": "This setting is associated with performance optimization. The shortest path algorithm does not work when the start and end nodes are the same. With this setting set to `false` no path will be returned when that happens. The default value of `true` will instead throw an exception. This can happen if you perform a shortestPath search after a cartesian product that might have the same start and end nodes for some of the rows passed to shortestPath. If it is preferable to not experience this exception, and acceptable for results to be missing for those rows, then set this to `false`. If you cannot accept missing results, and really want the shortestPath between two common nodes, then re-write the query using a standard Cypher variable length pattern expression followed by ordering by path length and limiting to one result.",
              "value": "true"
            },
            "causal_clustering.load_balancing.config": {
              "description": "The configuration must be valid for the configured plugin and usually existsunder matching subkeys, e.g. ..config.server_policies.*This is just a top-level placeholder for the plugin-specific configuration.",
              "value": ""
            },
            "metrics.neo4j.checkpointing.enabled": {
              "description": "Enable reporting metrics about Neo4j check pointing; when it occurs and how much time it takes to complete.",
              "value": "true"
            },
            "causal_clustering.protocol_implementations.raft": {
              "description": "Raft protocol implementation versions that this instance will allow in negotiation as a comma-separated list. Order is not relevant: the greatest value will be preferred. An empty list will allow all supported versions",
              "value": "[]"
            },
            "causal_clustering.pull_interval": {
              "description": "Interval of pulling updates from cores.",
              "value": "1000ms"
            },
            "causal_clustering.state_machine_apply_max_batch_size": {
              "description": "The maximum number of operations to be batched during applications of operations in the state machines",
              "value": "16"
            },
            "unsupported.dbms.udc.reg": {
              "description": "Configuration attribute",
              "value": "unreg"
            },
            "ha.heartbeat_timeout": {
              "description": "How long to wait for heartbeats from other instances before marking them as suspects for failure. This value reflects considerations of network latency, expected duration of garbage collection pauses and other factors that can delay message sending and processing. Larger values will result in more stable masters but also will result in longer waits before a failover in case of master failure. This value should not be set to less than twice the ha.heartbeat_interval value otherwise there is a high risk of frequent master switches and possibly branched data occurrence.",
              "value": "40000ms"
            },
            "dbms.ids.reuse.types.override": {
              "description": "Specified names of id types (comma separated) that should be reused. Currently only 'node' and 'relationship' types are supported. ",
              "value": "[RELATIONSHIP, NODE]"
            },
            "dbms.ssl.policy.<policyname>.private_key": {
              "description": "Private PKCS#8 key in PEM format.",
              "value": "private.key"
            },
            "unsupported.dbms.memory.pagecache.pagesize": {
              "description": "Target size for pages of mapped memory. If set to 0, then a reasonable default is chosen, depending on the storage device used.",
              "value": "0"
            },
            "ha.branched_data_copying_strategy": {
              "description": "Strategy for how to order handling of branched data on slaves and copying of the store from the master. The default is copy_then_branch, which, when combined with the keep_last or keep_none branch handling strategies results in a safer branching strategy, as there is always a store present so store failure to copy a store (for example, because of network failure) does not leave the instance without a store.",
              "value": "branch_then_copy"
            },
            "metrics.neo4j.cluster.enabled": {
              "description": "Enable reporting metrics about HA cluster info.",
              "value": "true"
            },
            "causal_clustering.catch_up_client_inactivity_timeout": {
              "description": "The catch up protocol times out if the given duration elapses with no network activity. Every message received by the client from the server extends the time out duration.",
              "value": "600000ms"
            },
            "dbms.security.http_strict_transport_security": {
              "description": "Value of the HTTP Strict-Transport-Security (HSTS) response header. This header tells browsers that a webpage should only be accessed using HTTPS instead of HTTP. It is attached to every HTTPS response. Setting is not set by default so 'Strict-Transport-Security' header is not sent. Value is expected to contain dirictives like 'max-age', 'includeSubDomains' and 'preload'.",
              "value": null
            },
            "dbms.ssl.policy.<policyname>.client_auth": {
              "description": "Client authentication stance.",
              "value": "REQUIRE"
            },
            "dbms.memory.heap.max_size": {
              "description": "Maximum heap size. By default it is calculated based on available system resources.",
              "value": "5000m"
            },
            "dbms.connectors.default_listen_address": {
              "description": "Default network interface to listen for incoming connections. To listen for connections on all interfaces, use \"0.0.0.0\". To bind specific connectors to a specific network interfaces, specify the +listen_address+ properties for the specific connector.",
              "value": "0.0.0.0"
            },
            "metrics.csv.rotation.keep_number": {
              "description": "Maximum number of history files for the csv files.",
              "value": "7"
            },
            "dbms.udc.enabled": {
              "description": "Enable the UDC extension.",
              "value": "true"
            },
            "unsupported.dbms.directories.database": {
              "description": "Configuration attribute",
              "value": "/var/lib/neo4j/data/databases/graph.db"
            },
            "dbms.shutdown_transaction_end_timeout": {
              "description": "The maximum amount of time to wait for running transactions to complete before allowing initiated database shutdown to continue",
              "value": "10000ms"
            },
            "causal_clustering.kubernetes.token": {
              "description": "File location of token for Kubernetes API",
              "value": "/var/run/secrets/kubernetes.io/serviceaccount/token"
            },
            "dbms.auto_index.nodes.keys": {
              "description": "A list of property names (comma separated) that will be indexed by default. This applies to _nodes_ only.",
              "value": "[]"
            },
            "causal_clustering.replicated_lock_token_state_size": {
              "description": "The maximum file size before the replicated lock token state file is rotated (in unit of entries)",
              "value": "1000"
            },
            "dbms.logs.query.page_logging_enabled": {
              "description": "Log page hits and page faults for the executed queries being logged.",
              "value": "false"
            },
            "dbms.memory.pagecache.size": {
              "description": "The amount of memory to use for mapping the store files, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g'). If Neo4j is running on a dedicated server, then it is generally recommended to leave about 2-4 gigabytes for the operating system, give the JVM enough heap to hold all your transaction state and query context, and then leave the rest for the page cache. If no page cache memory is configured, then a heuristic setting is computed based on available system resources.",
              "value": "1g"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84-3d.y.max": {
              "description": "The maximum y value for the index extents for 3D wgs-84-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "90.0"
            },
            "dbms.filewatcher.enabled": {
              "description": "Allows the enabling or disabling of the file watcher service. This is an auxiliary service but should be left enabled in almost all cases.",
              "value": "true"
            },
            "unsupported.dbms.console_module.enabled": {
              "description": "Configuration attribute",
              "value": "true"
            },
            "unsupported.cypher.runtime": {
              "description": "Set this to specify the default runtime for the default language version.",
              "value": "default"
            },
            "causal_clustering.property_key_token_name_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of PROPERTY_KEY_TOKEN_NAME IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "dbms.security.ldap.authorization.system_username": {
              "description": "An LDAP system account username to use for authorization searches when `dbms.security.ldap.authorization.use_system_account` is `true`. Note that the `dbms.security.ldap.authentication.user_dn_template` will not be applied to this username, so you may have to specify a full DN.",
              "value": null
            },
            "dbms.security.http_authorization_classes": {
              "description": "Comma-separated list of custom security rules for Neo4j to use.",
              "value": "[]"
            },
            "causal_clustering.raft_in_queue_max_batch_bytes": {
              "description": "Largest batch processed by RAFT in bytes",
              "value": "8388608"
            },
            "causal_clustering.relationship_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "unsupported.dbms.schema.release_lock_while_building_constraint": {
              "description": "Whether or not to release the exclusive schema lock is while building uniqueness constraints index",
              "value": "false"
            },
            "causal_clustering.upstream_selection_strategy": {
              "description": "An ordered list in descending preference of the strategy which read replicas use to choose the upstream server from which to pull transactional updates.",
              "value": "[default]"
            },
            "ha.tx_push_factor": {
              "description": "The amount of slaves the master will ask to replicate a committed transaction. ",
              "value": "1"
            },
            "ha.max_acceptors": {
              "description": "Maximum number of servers to involve when agreeing to membership changes. In very large clusters, the probability of half the cluster failing is low, but protecting against any arbitrary half failing is expensive. Therefore you may wish to set this parameter to a value less than the cluster size.",
              "value": "21"
            },
            "dbms.logs.security.rotation.size": {
              "description": "Threshold for rotation of the security log.",
              "value": "20971520"
            },
            "causal_clustering.enable_pre_voting": {
              "description": "Enable pre-voting extension to the Raft protocol (this is breaking and must match between the core cluster members)",
              "value": "false"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84-3d.x.min": {
              "description": "The minimum x value for the index extents for 3D wgs-84-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-180.0"
            },
            "causal_clustering.raft_in_queue_max_bytes": {
              "description": "Maximum number of bytes in the RAFT in-queue",
              "value": "2147483648"
            },
            "browser.credential_timeout": {
              "description": "Configure the Neo4j Browser to time out logged in users after this idle period. Setting this to 0 indicates no limit.",
              "value": "0ms"
            },
            "causal_clustering.expected_core_cluster_size": {
              "description": "Expected number of Core machines in the cluster before startup",
              "value": "3"
            },
            "causal_clustering.in_flight_cache.max_entries": {
              "description": "The maximum number of entries in the in-flight cache.",
              "value": "1024"
            },
            "dbms.netty.ssl.provider": {
              "description": "Netty SSL provider",
              "value": "JDK"
            },
            "unsupported.dbms.security.ldap.authorization.connection_pooling": {
              "description": "Set to true if connection pooling should be used for authorization searches using the system account.",
              "value": "true"
            },
            "dbms.backup.ssl_policy": {
              "description": "Name of the SSL policy to be used by backup, as defined under the dbms.ssl.policy.* settings. If no policy is configured then the communication will not be secured.",
              "value": null
            },
            "unsupported.dbms.max_http_response_header_size": {
              "description": "Maximum response header size",
              "value": "20480"
            },
            "causal_clustering.middleware.akka.failure_detector.max_sample_size": {
              "description": "Akka cluster phi accrual failure detector. Number of the samples of inter-heartbeat arrival times to adaptively calculate the failure timeout for connections.",
              "value": "1000"
            },
            "dbms.logs.security.path": {
              "description": "Path to the security log file.",
              "value": "/var/log/neo4j/security.log"
            },
            "causal_clustering.middleware.akka.failure_detector.expected_response_after": {
              "description": "Akka cluster phi accrual failure detector. After the heartbeat request has been sent the first failure detection will start after this period, even though no heartbeat message has been received.",
              "value": "1000ms"
            },
            "dbms.backup.address": {
              "description": "Listening server for online backups. The protocol running varies depending on deployment. In a Causal Clustering environment this is the same protocol that runs on causal_clustering.transaction_listen_address. The port range is only respected in a HA or single instance deployment. In Causal Clustering a single port should be used",
              "value": "localhost:6362"
            },
            "unsupported.dbms.block_size.labels": {
              "description": "Specifies the block size for storing labels exceeding in-lined space in node record. This parameter is only honored when the store is created, otherwise it is ignored. Also note that each block carries a ~10B of overhead so record size on disk will be slightly larger than the configured block size",
              "value": "56"
            },
            "dbms.connector.http.listen_address": {
              "description": "Address the connector should bind to.",
              "value": "0.0.0.0:7474"
            },
            "unsupported.vm_pause_monitor.measurement_duration": {
              "description": "Configuration attribute",
              "value": "100ms"
            },
            "unsupported.dbms.directories.neo4j_home": {
              "description": "Root relative to which directory settings are resolved. This is set in code and should never be configured explicitly.",
              "value": "/var/lib/neo4j"
            },
            "unsupported.dbms.tracer": {
              "description": "Configuration attribute",
              "value": null
            },
            "metrics.jvm.gc.enabled": {
              "description": "Enable reporting metrics about the duration of garbage collections",
              "value": "true"
            },
            "unsupported.dbms.kernel_id": {
              "description": "An identifier that uniquely identifies this graph database instance within this JVM. Defaults to an auto-generated number depending on how many instance are started in this JVM.",
              "value": null
            },
            "unsupported.cypher.statistics_divergence_target": {
              "description": "Large databases might change slowly, and so to prevent queries from never being replanned the divergence threshold set by cypher.statistics_divergence_threshold is configured to shrink over time. The algorithm used to manage this change is set by unsupported.cypher.replan_algorithm and will cause the threshold to reach the value set here once the time since the previous replanning has reached unsupported.cypher.target_replan_interval. Setting this value to higher than the cypher.statistics_divergence_threshold will cause the threshold to not decay over time.",
              "value": "0.1"
            },
            "ha.phase2_timeout": {
              "description": "Timeout for Paxos phase 2. If it is not given a value it defaults to ha.paxos_timeout and will implicitly change if ha.paxos_timeout changes. This is an advanced parameter which should only be changed if specifically advised by Neo4j Professional Services. ",
              "value": "5000ms"
            },
            "dbms.index.fulltext.eventually_consistent_index_update_queue_max_length": {
              "description": "The eventually_consistent mode of the fulltext indexes works by queueing up index updates to be applied later in a background thread. This setting sets an upper bound on how many index updates are allowed to be in this queue at any one point in time. When it is reached, the commit process will slow down and wait for the index update applier thread to make some more room in the queue.",
              "value": "10000"
            },
            "causal_clustering.replication_retry_timeout_base": {
              "description": "The initial timeout until replication is retried. The timeout will increase exponentially.",
              "value": "10000ms"
            },
            "unsupported.dbms.security.tls_certificate_file": {
              "description": "Path to the X.509 public certificate to be used by Neo4j for TLS connections",
              "value": "/var/lib/neo4j/certificates/neo4j.cert"
            },
            "unsupported.dbms.index.spatial.curve.top_threshold": {
              "description": "When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. When traversing the tree to this depth, we can stop early based on when the search envelope overlaps the current tile by more than a certain threshold. The threshold is calculated based on depth, from the `top_threshold` at the top of the tree to the `bottom_threshold` at the depth calculated by the area comparison. Setting the top to 0.99 and the bottom to 0.5, for example would mean that if we reached the maximum depth, and the search area overlapped the current tile by more than 50%, we would stop traversing the tree, and return the 1D range for that entire tile to the search set. If the overlap is even higher, we would stop higher in the tree. This technique reduces the number of 1D ranges passed to the underlying space filling curve index. Setting this value to zero turns off this feature.",
              "value": "0.0"
            },
            "dbms.index_sampling.update_percentage": {
              "description": "Percentage of index updates of total index size required before sampling of a given index is triggered",
              "value": "5"
            },
            "dbms.security.causal_clustering_status_auth_enabled": {
              "description": "Require authorization for access to the Causal Clustering status endpoints.",
              "value": "true"
            },
            "dbms.logs.user.rotation.size": {
              "description": "Threshold for rotation of the user log. If set to 0 log rotation is disabled.",
              "value": "0"
            },
            "dbms.index_sampling.sample_size_limit": {
              "description": "Index sampling chunk size limit",
              "value": "8388608"
            },
            "dbms.security.ldap.authentication.cache_enabled": {
              "description": "Determines if the result of authentication via the LDAP server should be cached or not. Caching is used to limit the number of LDAP requests that have to be made over the network for users that have already been authenticated successfully. A user can be authenticated against an existing cache entry (instead of via an LDAP server) as long as it is alive (see `dbms.security.auth_cache_ttl`).\nAn important consequence of setting this to `true` is that Neo4j then needs to cache a hashed version of the credentials in order to perform credentials matching. This hashing is done using a cryptographic hash function together with a random salt. Preferably a conscious decision should be made if this method is considered acceptable by the security standards of the organization in which this Neo4j instance is deployed.",
              "value": "true"
            },
            "dbms.tx_state.off_heap.max_cacheable_block_size": {
              "description": "Defines the maximum size of an off-heap memory block that can be cached to speed up allocations for transaction state data. The value must be a power of 2.",
              "value": "524288"
            },
            "db.temporal.timezone": {
              "description": "Database timezone for temporal functions. All Time and DateTime values that are created without an explicit timezone will use this configured default timezone.",
              "value": "Z"
            },
            "causal_clustering.raft_messages_log_enable": {
              "description": "Enable or disable the dump of all network messages pertaining to the RAFT protocol",
              "value": "false"
            },
            "unsupported.dbms.tx_log.fail_on_corrupted_log_files": {
              "description": "If `true`, Neo4j will abort recovery if any errors are encountered in the logical log. Setting this to `false` will allow Neo4j to restore as much as possible from the corrupted log files and ignore the rest, but, the integrity of the database might be compromised.",
              "value": "true"
            },
            "unsupported.dbms.bolt.outbound_buffer_throttle.high_watermark": {
              "description": "When the size (in bytes) of outbound network buffers, used by bolt's network layer, grows beyond this value bolt channel will advertise itself as unwritable and will block related processing thread until it becomes writable again.",
              "value": "524288"
            },
            "tools.consistency_checker.check_indexes": {
              "description": "This setting is deprecated. See commandline arguments for neoj4-admin check-consistency instead. Perform checks on indexes. Checking indexes is more expensive than checking the native stores, so it may be useful to turn off this check for very large databases.",
              "value": "true"
            },
            "unsupported.dbms.index.spatial.curve.bottom_threshold": {
              "description": "When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. When traversing the tree to this depth, we can stop early based on when the search envelope overlaps the current tile by more than a certain threshold. The threshold is calculated based on depth, from the `top_threshold` at the top of the tree to the `bottom_threshold` at the depth calculated by the area comparison. Setting the top to 0.99 and the bottom to 0.5, for example would mean that if we reached the maximum depth, and the search area overlapped the current tile by more than 50%, we would stop traversing the tree, and return the 1D range for that entire tile to the search set. If the overlap is even higher, we would stop higher in the tree. This technique reduces the number of 1D ranges passed to the underlying space filling curve index. Setting this value to zero turns off this feature.",
              "value": "0.0"
            },
            "dbms.security.native.authorization_enabled": {
              "description": "Enable authorization via native authorization provider.",
              "value": "true"
            },
            "unsupported.dbms.enable_native_schema_index": {
              "description": "Configuration attribute",
              "value": "true"
            },
            "unsupported.dbms.report_configuration": {
              "description": "Print out the effective Neo4j configuration after startup.",
              "value": "false"
            },
            "dbms.directories.tx_log": {
              "description": "Location where Neo4j keeps the logical transaction logs.",
              "value": "/var/lib/neo4j/data/databases/graph.db"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84-3d.y.min": {
              "description": "The minimum y value for the index extents for 3D wgs-84-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-90.0"
            },
            "dbms.security.auth_enabled": {
              "description": "Enable auth requirement to access Neo4j.",
              "value": "true"
            },
            "dbms.security.native.authentication_enabled": {
              "description": "Enable authentication via native authentication provider.",
              "value": "true"
            },
            "ha.election_timeout": {
              "description": "Timeout for waiting for other members to finish a role election. Defaults to ha.paxos_timeout.",
              "value": "5000ms"
            },
            "dbms.index_sampling.background_enabled": {
              "description": "Enable or disable background index sampling",
              "value": "true"
            },
            "causal_clustering.raft_advertised_address": {
              "description": "Advertised hostname/IP address and port for the RAFT server.",
              "value": "10.142.0.3:7000"
            },
            "causal_clustering.user_defined_upstream_strategy": {
              "description": "Configuration of a user-defined upstream selection strategy. The user-defined strategy is used if the list of strategies (`causal_clustering.upstream_selection_strategy`) includes the value `user_defined`. ",
              "value": ""
            },
            "causal_clustering.middleware.akka.failure_detector.heartbeat_interval": {
              "description": "Akka cluster phi accrual failure detector. How often keep-alive heartbeat messages should be sent to each connection.",
              "value": "1000ms"
            },
            "unsupported.dbms.disconnected": {
              "description": "Disable all Bolt protocol connectors. This setting is deprecated and will be removed in 4.0. Please use connector configuration instead.",
              "value": "false"
            },
            "dbms.security.ldap.host": {
              "description": "URL of LDAP server to use for authentication and authorization. The format of the setting is `<protocol>://<hostname>:<port>`, where hostname is the only required field. The supported values for protocol are `ldap` (default) and `ldaps`. The default port for `ldap` is 389 and for `ldaps` 636. For example: `ldaps://ldap.example.com:10389`.\n\nYou may want to consider using STARTTLS (`dbms.security.ldap.use_starttls`) instead of LDAPS for secure connections, in which case the correct protocol is `ldap`.",
              "value": "localhost"
            },
            "unsupported.dbms.discoverable_bolt_address": {
              "description": "Publicly discoverable bolt:// URI to use for Neo4j Drivers wanting to access the data in this particular database instance. Normally this is the same as the advertised address configured for the connector, but this allows manually overriding that default.",
              "value": ""
            },
            "causal_clustering.in_flight_cache.type": {
              "description": "Type of in-flight cache.",
              "value": "CONSECUTIVE"
            },
            "causal_clustering.discovery_implementation": {
              "description": "Select the middleware used for cluster topology discovery",
              "value": "HAZELCAST"
            },
            "ha.learn_timeout": {
              "description": "Timeout for learning values. Defaults to ha.default_timeout.",
              "value": "5000ms"
            },
            "unsupported.dbms.db.spatial.crs.cartesian-3d.z.max": {
              "description": "The maximum z value for the index extents for 3D cartesian-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "1000000.0"
            },
            "causal_clustering.log_shipping_max_lag": {
              "description": "The maximum lag allowed before log shipping pauses (in unit of entries)",
              "value": "256"
            },
            "causal_clustering.middleware.akka.default-parallelism": {
              "description": "Parallelism level of default dispatcher used by Akka based cluster topology discovery, including cluster, replicator, and discovery actors",
              "value": "4"
            },
            "dbms.security.ldap.authentication.use_samaccountname": {
              "description": "Perform authentication with sAMAccountName instead of DN.\nUsing this setting requires `dbms.security.ldap.authorization.system_username` and dbms.security.ldap.authorization.system_password to be used since there is no way to log in through ldap directly with the sAMAccountName, instead the login name will be resolved to a DN that will be used to log in with.",
              "value": "false"
            },
            "unsupported.cypher.replan_algorithm": {
              "description": "Large databases might change slowly, and to prevent queries from never being replanned the divergence threshold set by cypher.statistics_divergence_threshold is configured to shrink over time using the algorithm set here. This will cause the threshold to reach the value set by unsupported.cypher.statistics_divergence_target once the time since the previous replanning has reached the value set in unsupported.cypher.target_replan_interval. Setting the algorithm to 'none' will cause the threshold to not decay over time.",
              "value": "default"
            },
            "dbms.logs.security.rotation.delay": {
              "description": "Minimum time interval after last rotation of the security log before it may be rotated again.",
              "value": "300000ms"
            },
            "causal_clustering.kubernetes.namespace": {
              "description": "File location of namespace for Kubernetes API",
              "value": "/var/run/secrets/kubernetes.io/serviceaccount/namespace"
            },
            "dbms.rest.transaction.idle_timeout": {
              "description": "Timeout for idle transactions in the REST endpoint.",
              "value": "60000ms"
            },
            "ha.slave_read_timeout": {
              "description": "How long a slave will wait for response from master before giving up.",
              "value": "20000ms"
            },
            "browser.retain_connection_credentials": {
              "description": "Configure the Neo4j Browser to store or not store user credentials.",
              "value": "true"
            },
            "unsupported.dbms.bolt.outbound_buffer_throttle.max_duration": {
              "description": "When the total time outbound network buffer based throttle lock is held exceeds this value, the corresponding bolt channel will be aborted. Setting this to 0 will disable this behaviour.",
              "value": "900000ms"
            },
            "unsupported.dbms.ephemeral": {
              "description": "Configuration attribute",
              "value": "false"
            },
            "causal_clustering.global_session_tracker_state_size": {
              "description": "The maximum file size before the global session tracker state file is rotated (in unit of entries)",
              "value": "1000"
            },
            "dbms.logs.query.allocation_logging_enabled": {
              "description": "Log allocated bytes for the executed queries being logged. The logged number is cumulative over the duration of the query, i.e. for memory intense or long-running queries the value may be larger than the current memory allocation. Requires `dbms.track_query_allocation=true`",
              "value": "false"
            },
            "causal_clustering.raft_log_reader_pool_size": {
              "description": "RAFT log reader pool size",
              "value": "8"
            },
            "causal_clustering.discovery_type": {
              "description": "Configure the discovery type used for cluster name resolution",
              "value": "LIST"
            },
            "causal_clustering.raft_term_state_size": {
              "description": "The maximum file size before the term state file is rotated (in unit of entries)",
              "value": "1000"
            },
            "tools.consistency_checker.check_label_scan_store": {
              "description": "This setting is deprecated. See commandline arguments for neoj4-admin check-consistency instead. Perform checks on the label scan store. Checking this store is more expensive than checking the native stores, so it may be useful to turn off this check for very large databases.",
              "value": "true"
            },
            "causal_clustering.raft_messages_log_path": {
              "description": "Path to RAFT messages log.",
              "value": "/var/log/neo4j/raft-messages.log"
            },
            "ha.slave_lock_timeout": {
              "description": "Timeout for taking remote (write) locks on slaves. Defaults to ha.slave_read_timeout.",
              "value": "20000ms"
            },
            "metrics.neo4j.network.enabled": {
              "description": "Enable reporting metrics about the network usage.",
              "value": "true"
            },
            "causal_clustering.discovery_resolution_retry_interval": {
              "description": "The polling interval when attempting to resolve initial_discovery_members from DNS and SRV records.",
              "value": "5000ms"
            },
            "unsupported.dbms.security.auth_store.location": {
              "description": "Configuration attribute",
              "value": null
            },
            "causal_clustering.kubernetes.ca_crt": {
              "description": "File location of CA certificate for Kubernetes API",
              "value": "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
            },
            "causal_clustering.property_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of PROPERTY IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "causal_clustering.refuse_to_be_leader": {
              "description": "Prevents the current instance from volunteering to become Raft leader. Defaults to false, and should only be used in exceptional circumstances by expert users. Using this can result in reduced availability for the cluster.",
              "value": "false"
            },
            "dbms.logs.gc.rotation.size": {
              "description": "Size of each GC log that is kept.",
              "value": "20971520"
            },
            "dbms.security.auth_cache_ttl": {
              "description": "The time to live (TTL) for cached authentication and authorization info when using external auth providers (LDAP or plugin). Setting the TTL to 0 will disable auth caching. Disabling caching while using the LDAP auth provider requires the use of an LDAP system account for resolving authorization information.",
              "value": "600000ms"
            },
            "unsupported.dbms.query.snapshot.retries": {
              "description": "Specifies number or retries that query engine will do to execute query based on stable accessed data snapshot before giving up.",
              "value": "5"
            },
            "causal_clustering.cluster_routing_ttl": {
              "description": "How long drivers should cache the data from the `dbms.cluster.routing.getServers()` procedure.",
              "value": "300000ms"
            },
            "dbms.procedures.kill_query_verbose": {
              "description": "Specifies whether or not dbms.killQueries produces a verbose output, with information about which queries were not found",
              "value": "true"
            },
            "unsupported.dbms.directories.databases.root": {
              "description": "Configuration attribute",
              "value": "/var/lib/neo4j/data/databases"
            },
            "dbms.security.auth_cache_use_ttl": {
              "description": "Enable time-based eviction of the authentication and authorization info cache for external auth providers (LDAP or plugin). Disabling this setting will make the cache live forever and only be evicted when `dbms.security.auth_cache_max_capacity` is exceeded.",
              "value": "true"
            },
            "unsupported.cypher.morsel_size": {
              "description": "The size of the morsels",
              "value": "10000"
            },
            "dbms.logs.gc.rotation.keep_number": {
              "description": "Number of GC logs to keep.",
              "value": "5"
            },
            "dbms.tx_state.max_off_heap_memory": {
              "description": "The maximum amount of off-heap memory that can be used to store transaction state data; it's a total amount of memory shared across all active transactions. Zero means 'unlimited'. Used when dbms.tx_state.memory_allocation is set to 'OFF_HEAP'.",
              "value": "2147483648"
            },
            "ha.max_channels_per_slave": {
              "description": "Maximum number of connections a slave can have to the master.",
              "value": "20"
            },
            "unsupported.ha.instance_name": {
              "description": "Configuration attribute",
              "value": null
            },
            "tools.consistency_checker.check_property_owners": {
              "description": "This setting is deprecated. See commandline arguments for neoj4-admin check-consistency instead. Perform optional additional checking on property ownership. This can detect a theoretical inconsistency where a property could be owned by multiple entities. However, the check is very expensive in time and memory, so it is skipped by default.",
              "value": "false"
            },
            "causal_clustering.kubernetes.label_selector": {
              "description": "LabelSelector for Kubernetes API",
              "value": null
            },
            "cypher.planner": {
              "description": "Set this to specify the default planner for the default language version.",
              "value": "default"
            },
            "causal_clustering.initial_discovery_members": {
              "description": "A comma-separated list of other members of the cluster to join.",
              "value": "[meetup-cluster-core-vm-1:5000, meetup-cluster-core-vm-2:5000, meetup-cluster-core-vm-3:5000]"
            },
            "dbms.tx_state.off_heap.block_cache_size": {
              "description": "Defines the size of the off-heap memory blocks cache. The cache will contain this number of blocks for each block size that is power of two. Thus, maximum amount of memory used by blocks cache can be calculated as 2 * dbms.tx_state.off_heap.max_cacheable_block_size * dbms.tx_state.off_heap.block_cache_size",
              "value": "128"
            },
            "dbms.config.strict_validation": {
              "description": "A strict configuration validation will prevent the database from starting up if unknown configuration options are specified in the neo4j settings namespace (such as dbms., ha., cypher., etc). This is currently false by default but will be true by default in 4.0.",
              "value": "false"
            },
            "unsupported.dbms.lock_manager": {
              "description": "Configuration attribute",
              "value": ""
            },
            "causal_clustering.kubernetes.service_port_name": {
              "description": "Service port name for discovery for Kubernetes API",
              "value": null
            },
            "causal_clustering.node_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of NODE IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "metrics.prefix": {
              "description": "A common prefix for the reported metrics field names. By default, this is either be 'neo4j', or a computed value based on the cluster and instance names, when running in an HA configuration.",
              "value": "neo4j"
            },
            "ha.default_timeout": {
              "description": "Default timeout used for clustering timeouts. Override  specific timeout settings with proper values if necessary. This value is the default value for the ha.heartbeat_interval, ha.paxos_timeout and ha.learn_timeout settings.",
              "value": "5000ms"
            },
            "dbms.security.ldap.authentication.user_dn_template": {
              "description": "LDAP user DN template. An LDAP object is referenced by its distinguished name (DN), and a user DN is an LDAP fully-qualified unique user identifier. This setting is used to generate an LDAP DN that conforms with the LDAP directory's schema from the user principal that is submitted with the authentication token when logging in. The special token {0} is a placeholder where the user principal will be substituted into the DN string.",
              "value": "uid={0},ou=users,dc=example,dc=com"
            },
            "causal_clustering.discovery_listen_address": {
              "description": "Host and port to bind the cluster member discovery management communication.",
              "value": "0.0.0.0:5000"
            },
            "causal_clustering.middleware.akka.failure_detector.monitored_by_nr_of_members": {
              "description": "Akka cluster phi accrual failure detector. Number of member nodes that each member will send heartbeat messages to, i.e. each node will be monitored by this number of other nodes.",
              "value": "5"
            },
            "dbms.transaction.bookmark_ready_timeout": {
              "description": "The maximum amount of time to wait for the database state represented by the bookmark.",
              "value": "30000ms"
            },
            "dbms.allow_upgrade": {
              "description": "Whether to allow an upgrade in case the current version of the database starts against an older version.",
              "value": "true"
            },
            "ha.role_switch_timeout": {
              "description": "Timeout for request threads waiting for instance to become master or slave.",
              "value": "120000ms"
            },
            "dbms.logs.query.path": {
              "description": "Path to the query log file.",
              "value": "/var/log/neo4j/query.log"
            },
            "dbms.security.ldap.authorization_enabled": {
              "description": "Enable authorization via settings configurable LDAP authorization provider.",
              "value": "false"
            },
            "dbms.connectors.default_advertised_address": {
              "description": "Default hostname or IP address the server uses to advertise itself to its connectors. To advertise a specific hostname or IP address for a specific connector, specify the +advertised_address+ property for the specific connector.",
              "value": "node1.cluster.graph.center"
            },
            "dbms.logs.debug.rotation.size": {
              "description": "Threshold for rotation of the debug log.",
              "value": "20971520"
            },
            "ha.branched_data_policy": {
              "description": "Policy for how to handle branched data.",
              "value": "keep_all"
            },
            "causal_clustering.last_applied_state_size": {
              "description": "The maximum file size before the storage file is rotated (in unit of entries)",
              "value": "1000"
            },
            "causal_clustering.relationship_type_token_name_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP_TYPE_TOKEN_NAME IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "causal_clustering.state_machine_flush_window_size": {
              "description": "The number of operations to be processed before the state machines flush to disk",
              "value": "4096"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84.y.max": {
              "description": "The maximum y value for the index extents for 2D wgs-84 spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "90.0"
            },
            "dbms.transaction.monitor.check.interval": {
              "description": "Configures the time interval between transaction monitor checks. Determines how often monitor thread will check transaction for timeout.",
              "value": "2000ms"
            },
            "causal_clustering.middleware_logging.level": {
              "description": "The level of middleware logging",
              "value": "500"
            },
            "unsupported.cypher.expression_engine": {
              "description": "Choose the expression engine. The default is to only compile expressions that are hot, if 'COMPILED' is chosen all expressions will be compiled directly and if 'INTERPRETED' is chosen expressions will never be compiled.",
              "value": "default"
            },
            "unsupported.cypher.target_replan_interval": {
              "description": "Large databases might change slowly, and to prevent queries from never being replanned the divergence threshold set by cypher.statistics_divergence_threshold is configured to shrink over time. The algorithm used to manage this change is set by unsupported.cypher.replan_algorithm and will cause the threshold to reach the value set by unsupported.cypher.statistics_divergence_target once the time since the previous replanning has reached the value set here. Setting this value to less than the value of cypher.min_replan_interval will cause the threshold to not decay over time.",
              "value": "25200000ms"
            },
            "causal_clustering.discovery_advertised_address": {
              "description": "Advertised cluster member discovery management communication.",
              "value": "node1.cluster.graph.center:5000"
            },
            "dbms.ssl.policy.<policyname>.trust_all": {
              "description": "Makes this policy trust all remote parties. Enabling this is not recommended and the trusted directory will be ignored.",
              "value": "false"
            },
            "causal_clustering.database": {
              "description": "The name of the database being hosted by this server instance. This configuration setting may be safely ignored unless deploying a multicluster. Instances may be allocated to distinct sub-clusters by assigning them distinct database names using this setting. For instance if you had 6 instances you could form 2 sub-clusters by assigning half the database name \"foo\", half the name \"bar\". The setting value must match exactly between members of the same sub-cluster. This setting is a one-off: once an instance is configured with a database name it may not be changed in future without using neo4j-admin unbind.",
              "value": "default"
            },
            "browser.remote_content_hostname_whitelist": {
              "description": "Whitelist of hosts for the Neo4j Browser to be allowed to fetch content from.",
              "value": "guides.neo4j.com,localhost"
            },
            "dbms.ssl.policy.<policyname>.tls_versions": {
              "description": "Restrict allowed TLS protocol versions.",
              "value": "[TLSv1.2]"
            },
            "causal_clustering.disable_middleware_logging": {
              "description": "Prevents the network middleware from dumping its own logs. Defaults to true.",
              "value": "true"
            },
            "unsupported.dbms.id_reuse_safe_zone": {
              "description": "Duration for which master will buffer ids and not reuse them to allow slaves read consistently. Slaves will also terminate transactions longer than this duration, when applying received transaction stream, to make sure they do not read potentially inconsistent/reused records.",
              "value": "3600000ms"
            },
            "dbms.directories.metrics": {
              "description": "The target location of the CSV files: a path to a directory wherein a CSV file per reported field  will be written.",
              "value": "/var/lib/neo4j/metrics"
            },
            "dbms.directories.logs": {
              "description": "Path of the logs directory.",
              "value": "/var/log/neo4j"
            },
            "causal_clustering.raft_vote_state_size": {
              "description": "The maximum file size before the vote state file is rotated (in unit of entries)",
              "value": "1000"
            },
            "unsupported.dbms.executiontime_limit.enabled": {
              "description": "Please use dbms.transaction.timeout instead.",
              "value": "false"
            },
            "cypher.lenient_create_relationship": {
              "description": "Set this to change the behavior for Cypher create relationship when the start or end node is missing. By default this fails the query and stops execution, but by setting this flag the create operation is simply not performed and execution continues.",
              "value": "false"
            },
            "causal_clustering.raft_log_pruning_frequency": {
              "description": "RAFT log pruning frequency",
              "value": "600000ms"
            },
            "dbms.security.ldap.authorization.system_password": {
              "description": "An LDAP system account password to use for authorization searches when `dbms.security.ldap.authorization.use_system_account` is `true`.",
              "value": null
            },
            "dbms.directories.import": {
              "description": "Sets the root directory for file URLs used with the Cypher `LOAD CSV` clause. This must be set to a single directory, restricting access to only those files within that directory and its subdirectories.",
              "value": "/var/lib/neo4j/import"
            },
            "causal_clustering.unknown_address_logging_throttle": {
              "description": "Throttle limit for logging unknown cluster member address",
              "value": "10000ms"
            },
            "dbms.security.ldap.authorization.group_to_role_mapping": {
              "description": "An authorization mapping from LDAP group names to Neo4j role names. The map should be formatted as a semicolon separated list of key-value pairs, where the key is the LDAP group name and the value is a comma separated list of corresponding role names. For example: group1=role1;group2=role2;group3=role3,role4,role5\n\nYou could also use whitespaces and quotes around group names to make this mapping more readable, for example: \n\n----\n+dbms.security.ldap.authorization.group_to_role_mapping+=\\\n         \"cn=Neo4j Read Only,cn=users,dc=example,dc=com\"      = reader;    \\\n         \"cn=Neo4j Read-Write,cn=users,dc=example,dc=com\"     = publisher; \\\n         \"cn=Neo4j Schema Manager,cn=users,dc=example,dc=com\" = architect; \\\n         \"cn=Neo4j Administrator,cn=users,dc=example,dc=com\"  = admin\n----\n\nDeprecated: This will be replaced by dynamic configuration in the system graph in 4.0, including a migration step for the existing setting value. +\n",
              "value": null
            },
            "metrics.jvm.threads.enabled": {
              "description": "Enable reporting metrics about the current number of threads running.",
              "value": "true"
            },
            "ha.slave_only": {
              "description": "Whether this instance should only participate as slave in cluster. If set to `true`, it will never be elected as master.",
              "value": "false"
            },
            "dbms.directories.run": {
              "description": "Path of the run directory. This directory holds Neo4j's runtime state, such as a pidfile when it is running in the background. The pidfile is created when starting neo4j and removed when stopping it. It may be placed on an in-memory filesystem such as tmpfs.",
              "value": "/var/run/neo4j"
            },
            "cypher.forbid_exhaustive_shortestpath": {
              "description": "This setting is associated with performance optimization. Set this to `true` in situations where it is preferable to have any queries using the 'shortestPath' function terminate as soon as possible with no answer, rather than potentially running for a long time attempting to find an answer (even if there is no path to be found). For most queries, the 'shortestPath' algorithm will return the correct answer very quickly. However there are some cases where it is possible that the fast bidirectional breadth-first search algorithm will find no results even if they exist. This can happen when the predicates in the `WHERE` clause applied to 'shortestPath' cannot be applied to each step of the traversal, and can only be applied to the entire path. When the query planner detects these special cases, it will plan to perform an exhaustive depth-first search if the fast algorithm finds no paths. However, the exhaustive search may be orders of magnitude slower than the fast algorithm. If it is critical that queries terminate as soon as possible, it is recommended that this option be set to `true`, which means that Neo4j will never consider using the exhaustive search for shortestPath queries. However, please note that if no paths are found, an error will be thrown at run time, which will need to be handled by the application.",
              "value": "false"
            },
            "dbms.directories.lib": {
              "description": "Path of the lib directory",
              "value": "/usr/share/neo4j/lib"
            },
            "unsupported.cypher.expression_recompilation_limit": {
              "description": "Number of uses before an expression is considered for compilation",
              "value": "1"
            },
            "unsupported.dbms.udc.host": {
              "description": "Configuration attribute",
              "value": "udc.neo4j.org"
            },
            "dbms.logs.security.rotation.keep_number": {
              "description": "Maximum number of history files for the security log.",
              "value": "7"
            },
            "ha.phase1_timeout": {
              "description": "Timeout for Paxos phase 1. If it is not given a value it defaults to ha.paxos_timeout and will implicitly change if ha.paxos_timeout changes. This is an advanced parameter which should only be changed if specifically advised by Neo4j Professional Services. ",
              "value": "5000ms"
            },
            "dbms.jvm.additional": {
              "description": "Additional JVM arguments. Argument order can be significant. To use a Java commercial feature, the argument to unlock commercial features must precede the argument to enable the specific feature in the config value string. For example, to use Flight Recorder, `-XX:+UnlockCommercialFeatures` must come before `-XX:+FlightRecorder`.",
              "value": "-Dunsupported.dbms.udc.source=gcloud-CORE"
            },
            "dbms.security.plugin.authorization_enabled": {
              "description": "Enable authorization via plugin authorization providers.",
              "value": "false"
            },
            "ha.tx_push_strategy": {
              "description": "Push strategy of a transaction to a slave during commit.",
              "value": "fixed_ascending"
            },
            "causal_clustering.join_catch_up_timeout": {
              "description": "Time out for a new member to catch up",
              "value": "600000ms"
            },
            "dbms.security.auth_cache_max_capacity": {
              "description": "The maximum capacity for authentication and authorization caches (respectively).",
              "value": "10000"
            },
            "unsupported.dbms.bolt.outbound_buffer_throttle": {
              "description": "Whether to apply network level outbound network buffer based throttling",
              "value": "true"
            },
            "unsupported.dbms.bolt.inbound_message_throttle.high_watermark": {
              "description": "When the number of queued inbound messages grows beyond this value, reading from underlying channel will be paused (no more inbound messages will be available) until queued number of messages drops below the configured low watermark value.",
              "value": "300"
            },
            "metrics.prometheus.enabled": {
              "description": "Set to `true` to enable the Prometheus endpoint",
              "value": "false"
            },
            "metrics.csv.interval": {
              "description": "The reporting interval for the CSV files. That is, how often new rows with numbers are appended to the CSV files.",
              "value": "3000ms"
            },
            "causal_clustering.protocol_implementations.catchup": {
              "description": "Catchup protocol implementation versions that this instance will allow in negotiation as a comma-separated list. Order is not relevant: the greatest value will be preferred. An empty list will allow all supported versions",
              "value": "[]"
            },
            "causal_clustering.raft_log_prune_strategy": {
              "description": "RAFT log pruning strategy",
              "value": "1g size"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84.x.max": {
              "description": "The maximum x value for the index extents for 2D wgs-84 spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "180.0"
            },
            "causal_clustering.read_replica_transaction_applier_batch_size": {
              "description": "Maximum transaction batch size for read replicas when applying transactions pulled from core servers.",
              "value": "64"
            },
            "cypher.hints_error": {
              "description": "Set this to specify the behavior when Cypher planner or runtime hints cannot be fulfilled. If true, then non-conformance will result in an error, otherwise only a warning is generated.",
              "value": "false"
            },
            "dbms.index_searcher_cache_size": {
              "description": "The maximum number of open Lucene index searchers.",
              "value": "2147483647"
            },
            "cypher.min_replan_interval": {
              "description": "The minimum time between possible cypher query replanning events. After this time, the graph statistics will be evaluated, and if they have changed by more than the value set by cypher.statistics_divergence_threshold, the query will be replanned. If the statistics have not changed sufficiently, the same interval will need to pass before the statistics will be evaluated again. Each time they are evaluated, the divergence threshold will be reduced slightly until it reaches 10% after 7h, so that even moderately changing databases will see query replanning after a sufficiently long time interval.",
              "value": "10000ms"
            },
            "dbms.security.auth_providers": {
              "description": "A list of security authentication and authorization providers containing the users and roles. They will be queried in the given order when login is attempted.",
              "value": "[native]"
            },
            "dbms.directories.certificates": {
              "description": "Directory for storing certificates to be used by Neo4j for TLS connections",
              "value": "/var/lib/neo4j/certificates"
            },
            "dbms.ssl.policy.<policyname>.trusted_dir": {
              "description": "Path to directory of X.509 certificates in PEM format for trusted parties.",
              "value": "trusted"
            },
            "metrics.csv.enabled": {
              "description": "Set to `true` to enable exporting metrics to CSV files",
              "value": "true"
            },
            "unsupported.dbms.security.tls_key_file": {
              "description": "Path to the X.509 private key to be used by Neo4j for TLS connections",
              "value": "/var/lib/neo4j/certificates/neo4j.key"
            },
            "dbms.label_index": {
              "description": "Backend to use for label --> nodes index",
              "value": "NATIVE"
            },
            "causal_clustering.store_copy_backoff_max_wait": {
              "description": "Maximum backoff timeout for store copy requests",
              "value": "5000ms"
            },
            "causal_clustering.schema_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of SCHEMA IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "metrics.neo4j.counts.enabled": {
              "description": "Enable reporting metrics about approximately how many entities are in the database; nodes, relationships, properties, etc.",
              "value": "true"
            },
            "metrics.enabled": {
              "description": "The default enablement value for all the supported metrics. Set this to `false` to turn off all metrics by default. The individual settings can then be used to selectively re-enable specific metrics.",
              "value": "true"
            },
            "causal_clustering.load_balancing.plugin": {
              "description": "The load balancing plugin to use.",
              "value": "server_policies"
            },
            "dbms.logs.debug.rotation.delay": {
              "description": "Minimum time interval after last rotation of the debug log before it may be rotated again.",
              "value": "300000ms"
            },
            "ha.heartbeat_interval": {
              "description": "How often heartbeat messages should be sent. Defaults to ha.default_timeout.",
              "value": "5000ms"
            },
            "dbms.logs.debug.level": {
              "description": "Debug log level threshold.",
              "value": "INFO"
            },
            "unsupported.dbms.bolt.inbound_message_throttle.low_watermark": {
              "description": "When the number of queued inbound messages, previously reached configured high watermark value, drops below this value, reading from underlying channel will be enabled and any pending messages will start queuing again.",
              "value": "100"
            },
            "browser.allow_outgoing_connections": {
              "description": "Configure the policy for outgoing Neo4j Browser connections.",
              "value": "true"
            },
            "dbms.track_query_allocation": {
              "description": "Enables or disables tracking of how many bytes are allocated by the execution of a query. Calling `dbms.listQueries` will display the time. This can also be logged in the query log by using `log_queries_allocation_logging_enabled`.",
              "value": "false"
            },
            "unsupported.dbms.jmx_module.enabled": {
              "description": "Configuration attribute",
              "value": "true"
            },
            "dbms.index_sampling.buffer_size": {
              "description": "Size of buffer used by index sampling. This configuration setting is no longer applicable as from Neo4j 3.0.3. Please use dbms.index_sampling.sample_size_limit instead.",
              "value": "67108864"
            },
            "causal_clustering.raft_in_queue_max_batch": {
              "description": "Largest batch processed by RAFT in number of entries",
              "value": "128"
            },
            "unsupported.cypher.plan_with_minimum_cardinality_estimates": {
              "description": "Enable using minimum cardinality estimates in the Cypher cost planner, so that cardinality estimates for logical plan operators are not allowed to go below certain thresholds even when the statistics give smaller numbers. This is especially useful for large import queries that write nodes and relationships into an empty or small database, where the generated query plan needs to be able to scale beyond the initial statistics. Otherwise, when this is disabled, the statistics on an empty or tiny database may lead the cost planner to for example pick a scan over an index seek, even when an index exists, because of a lower estimated cost.",
              "value": "true"
            },
            "causal_clustering.replication_retry_timeout_limit": {
              "description": "The upper limit for the exponentially incremented retry timeout.",
              "value": "60000ms"
            },
            "ha.host.data": {
              "description": "Hostname and port to bind the HA server.",
              "value": "0.0.0.0:6001-6011"
            },
            "unsupported.dbms.db.spatial.crs.cartesian.x.min": {
              "description": "The minimum x value for the index extents for 2D cartesian spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-1000000.0"
            }
          }
        },
        {
          "name": "java.lang:name=Compressed Class Space,type=MemoryPool",
          "attributes": {
            "UsageThresholdCount": {
              "description": "UsageThresholdCount",
              "value": 0
            },
            "Usage": {
              "description": "Usage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 15626240,
                  "used": 14582168,
                  "max": 1073741824
                }
              }
            },
            "MemoryManagerNames": {
              "description": "MemoryManagerNames",
              "value": [
                "Metaspace Manager"
              ]
            },
            "UsageThresholdSupported": {
              "description": "UsageThresholdSupported",
              "value": true
            },
            "UsageThreshold": {
              "description": "UsageThreshold",
              "value": 0
            },
            "CollectionUsageThresholdCount": {
              "description": "CollectionUsageThresholdCount",
              "value": null
            },
            "PeakUsage": {
              "description": "PeakUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 15626240,
                  "used": 14582168,
                  "max": 1073741824
                }
              }
            },
            "UsageThresholdExceeded": {
              "description": "UsageThresholdExceeded",
              "value": false
            },
            "CollectionUsageThreshold": {
              "description": "CollectionUsageThreshold",
              "value": null
            },
            "Name": {
              "description": "Name",
              "value": "Compressed Class Space"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=Compressed Class Space,type=MemoryPool"
            },
            "Type": {
              "description": "Type",
              "value": "NON_HEAP"
            },
            "CollectionUsageThresholdSupported": {
              "description": "CollectionUsageThresholdSupported",
              "value": false
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionUsage": {
              "description": "CollectionUsage",
              "value": null
            },
            "CollectionUsageThresholdExceeded": {
              "description": "CollectionUsageThresholdExceeded",
              "value": null
            }
          }
        },
        {
          "name": "java.lang:type=Memory",
          "attributes": {
            "ObjectPendingFinalizationCount": {
              "description": "ObjectPendingFinalizationCount",
              "value": 0
            },
            "Verbose": {
              "description": "Verbose",
              "value": false
            },
            "HeapMemoryUsage": {
              "description": "HeapMemoryUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 5138022400,
                  "committed": 5138022400,
                  "used": 2002900784,
                  "max": 5242880000
                }
              }
            },
            "NonHeapMemoryUsage": {
              "description": "NonHeapMemoryUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 2555904,
                  "committed": 197517312,
                  "used": 190051960,
                  "max": -1
                }
              }
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:type=Memory"
            }
          }
        },
        {
          "name": "java.lang:name=G1 Eden Space,type=MemoryPool",
          "attributes": {
            "UsageThresholdCount": {
              "description": "UsageThresholdCount",
              "value": null
            },
            "Usage": {
              "description": "Usage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 270532608,
                  "committed": 3227516928,
                  "used": 591396864,
                  "max": -1
                }
              }
            },
            "MemoryManagerNames": {
              "description": "MemoryManagerNames",
              "value": [
                "G1 Old Generation",
                "G1 Young Generation"
              ]
            },
            "UsageThresholdSupported": {
              "description": "UsageThresholdSupported",
              "value": false
            },
            "UsageThreshold": {
              "description": "UsageThreshold",
              "value": null
            },
            "CollectionUsageThresholdCount": {
              "description": "CollectionUsageThresholdCount",
              "value": 0
            },
            "PeakUsage": {
              "description": "PeakUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 270532608,
                  "committed": 3233808384,
                  "used": 3078619136,
                  "max": -1
                }
              }
            },
            "UsageThresholdExceeded": {
              "description": "UsageThresholdExceeded",
              "value": null
            },
            "CollectionUsageThreshold": {
              "description": "CollectionUsageThreshold",
              "value": 0
            },
            "Name": {
              "description": "Name",
              "value": "G1 Eden Space"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=G1 Eden Space,type=MemoryPool"
            },
            "Type": {
              "description": "Type",
              "value": "HEAP"
            },
            "CollectionUsageThresholdSupported": {
              "description": "CollectionUsageThresholdSupported",
              "value": true
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionUsage": {
              "description": "CollectionUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 270532608,
                  "committed": 3227516928,
                  "used": 0,
                  "max": -1
                }
              }
            },
            "CollectionUsageThresholdExceeded": {
              "description": "CollectionUsageThresholdExceeded",
              "value": false
            }
          }
        },
        {
          "name": "java.nio:name=mapped,type=BufferPool",
          "attributes": {
            "TotalCapacity": {
              "description": "TotalCapacity",
              "value": 0
            },
            "MemoryUsed": {
              "description": "MemoryUsed",
              "value": 0
            },
            "Count": {
              "description": "Count",
              "value": 0
            },
            "Name": {
              "description": "Name",
              "value": "mapped"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.nio:name=mapped,type=BufferPool"
            }
          }
        },
        {
          "name": "com.sun.management:type=DiagnosticCommand",
          "attributes": {}
        },
        {
          "name": "com.sun.management:type=HotSpotDiagnostic",
          "attributes": {
            "DiagnosticOptions": {
              "description": "DiagnosticOptions",
              "value": [
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "HeapDumpBeforeFullGC",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "HeapDumpAfterFullGC",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "HeapDumpOnOutOfMemoryError",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "HeapDumpPath",
                    "writeable": true,
                    "value": "",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "CMSAbortablePrecleanWaitMillis",
                    "writeable": true,
                    "value": "100",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "CMSWaitDuration",
                    "writeable": true,
                    "value": "2000",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "CMSTriggerInterval",
                    "writeable": true,
                    "value": "-1",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintGC",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintGCDetails",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintGCDateStamps",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintGCTimeStamps",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintGCID",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintClassHistogramBeforeFullGC",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintClassHistogramAfterFullGC",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintClassHistogram",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "MinHeapFreeRatio",
                    "writeable": true,
                    "value": "40",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "MaxHeapFreeRatio",
                    "writeable": true,
                    "value": "70",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintConcurrentLocks",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                }
              ]
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "com.sun.management:type=HotSpotDiagnostic"
            }
          }
        }
      ],
      "configuration": {
        "bolt.ssl_policy": "default",
        "browser.allow_outgoing_connections": "true",
        "browser.credential_timeout": "0ms",
        "browser.post_connect_cmd": "",
        "browser.remote_content_hostname_whitelist": "guides.neo4j.com,localhost",
        "browser.retain_connection_credentials": "true",
        "causal_clustering.array_block_id_allocation_size": "1024",
        "causal_clustering.catch_up_client_inactivity_timeout": "600000ms",
        "causal_clustering.catchup_batch_size": "64",
        "causal_clustering.cluster_allow_reads_on_followers": "true",
        "causal_clustering.cluster_routing_ttl": "300000ms",
        "causal_clustering.cluster_topology_refresh": "5000ms",
        "causal_clustering.connect-randomly-to-server-group": "[]",
        "causal_clustering.database": "default",
        "causal_clustering.disable_middleware_logging": "true",
        "causal_clustering.discovery_advertised_address": "node1.cluster.graph.center:5000",
        "causal_clustering.discovery_listen_address": "0.0.0.0:5000",
        "causal_clustering.discovery_type": "LIST",
        "causal_clustering.enable_pre_voting": "false",
        "causal_clustering.expected_core_cluster_size": "3",
        "causal_clustering.global_session_tracker_state_size": "1000",
        "causal_clustering.handshake_timeout": "20000ms",
        "causal_clustering.id_alloc_state_size": "1000",
        "causal_clustering.in_flight_cache.max_bytes": "2147483648",
        "causal_clustering.in_flight_cache.max_entries": "1024",
        "causal_clustering.in_flight_cache.type": "CONSECUTIVE",
        "causal_clustering.initial_discovery_members": "[meetup-cluster-core-vm-1:5000, meetup-cluster-core-vm-2:5000, meetup-cluster-core-vm-3:5000]",
        "causal_clustering.join_catch_up_timeout": "600000ms",
        "causal_clustering.kubernetes.address": "kubernetes.default.svc:443",
        "causal_clustering.kubernetes.ca_crt": "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt",
        "causal_clustering.kubernetes.label_selector": "",
        "causal_clustering.kubernetes.namespace": "/var/run/secrets/kubernetes.io/serviceaccount/namespace",
        "causal_clustering.kubernetes.service_port_name": "",
        "causal_clustering.kubernetes.token": "/var/run/secrets/kubernetes.io/serviceaccount/token",
        "causal_clustering.label_token_id_allocation_size": "32",
        "causal_clustering.label_token_name_id_allocation_size": "1024",
        "causal_clustering.last_applied_state_size": "1000",
        "causal_clustering.leader_election_timeout": "7000ms",
        "causal_clustering.load_balancing.config": "",
        "causal_clustering.load_balancing.plugin": "server_policies",
        "causal_clustering.load_balancing.shuffle": "true",
        "causal_clustering.log_shipping_max_lag": "256",
        "causal_clustering.middleware_logging.level": "500",
        "causal_clustering.minimum_core_cluster_size_at_formation": "3",
        "causal_clustering.minimum_core_cluster_size_at_runtime": "3",
        "causal_clustering.multi_dc_license": "false",
        "causal_clustering.neostore_block_id_allocation_size": "1024",
        "causal_clustering.node_id_allocation_size": "1024",
        "causal_clustering.node_labels_id_allocation_size": "1024",
        "causal_clustering.property_id_allocation_size": "1024",
        "causal_clustering.property_key_token_id_allocation_size": "32",
        "causal_clustering.property_key_token_name_id_allocation_size": "1024",
        "causal_clustering.protocol_implementations.catchup": "[]",
        "causal_clustering.protocol_implementations.compression": "[]",
        "causal_clustering.protocol_implementations.raft": "[]",
        "causal_clustering.pull_interval": "1000ms",
        "causal_clustering.raft_advertised_address": "10.142.0.3:7000",
        "causal_clustering.raft_in_queue_max_batch_bytes": "8388608",
        "causal_clustering.raft_in_queue_max_bytes": "2147483648",
        "causal_clustering.raft_listen_address": "0.0.0.0:7000",
        "causal_clustering.raft_log_implementation": "SEGMENTED",
        "causal_clustering.raft_log_prune_strategy": "1g size",
        "causal_clustering.raft_log_pruning_frequency": "600000ms",
        "causal_clustering.raft_log_reader_pool_size": "8",
        "causal_clustering.raft_log_rotation_size": "262144000",
        "causal_clustering.raft_membership_state_size": "1000",
        "causal_clustering.raft_term_state_size": "1000",
        "causal_clustering.raft_vote_state_size": "1000",
        "causal_clustering.read_replica_time_to_live": "60000ms",
        "causal_clustering.refuse_to_be_leader": "false",
        "causal_clustering.relationship_group_id_allocation_size": "1024",
        "causal_clustering.relationship_id_allocation_size": "1024",
        "causal_clustering.relationship_type_token_id_allocation_size": "32",
        "causal_clustering.relationship_type_token_name_id_allocation_size": "1024",
        "causal_clustering.replicated_lock_token_state_size": "1000",
        "causal_clustering.replication_retry_timeout_base": "10000ms",
        "causal_clustering.replication_retry_timeout_limit": "60000ms",
        "causal_clustering.schema_id_allocation_size": "1024",
        "causal_clustering.server_groups": "[]",
        "causal_clustering.ssl_policy": "",
        "causal_clustering.state_machine_apply_max_batch_size": "16",
        "causal_clustering.state_machine_flush_window_size": "4096",
        "causal_clustering.store_copy_max_retry_time_per_request": "1200000ms",
        "causal_clustering.string_block_id_allocation_size": "1024",
        "causal_clustering.transaction_advertised_address": "10.142.0.3:6000",
        "causal_clustering.transaction_listen_address": "0.0.0.0:6000",
        "causal_clustering.unknown_address_logging_throttle": "10000ms",
        "causal_clustering.upstream_selection_strategy": "[default]",
        "causal_clustering.user_defined_upstream_strategy": "",
        "cypher.default_language_version": "default",
        "cypher.forbid_exhaustive_shortestpath": "false",
        "cypher.forbid_shortestpath_common_nodes": "true",
        "cypher.hints_error": "false",
        "cypher.lenient_create_relationship": "false",
        "cypher.min_replan_interval": "10000ms",
        "cypher.planner": "default",
        "cypher.statistics_divergence_threshold": "0.75",
        "db.temporal.timezone": "Z",
        "dbms.active_database": "graph.db",
        "dbms.allow_format_migration": "false",
        "dbms.allow_upgrade": "true",
        "dbms.backup.address": "localhost:6362",
        "dbms.backup.enabled": "true",
        "dbms.backup.ssl_policy": "",
        "dbms.checkpoint": "periodic",
        "dbms.checkpoint.interval.time": "900000ms",
        "dbms.checkpoint.interval.tx": "100000",
        "dbms.checkpoint.iops.limit": "300",
        "dbms.config.strict_validation": "false",
        "dbms.connector.bolt.enabled": "true",
        "dbms.connector.bolt.listen_address": "0.0.0.0:7687",
        "dbms.connector.bolt.tls_level": "REQUIRED",
        "dbms.connector.http.enabled": "true",
        "dbms.connector.http.listen_address": "0.0.0.0:7474",
        "dbms.connector.https.enabled": "true",
        "dbms.connector.https.listen_address": "0.0.0.0:7473",
        "dbms.connectors.default_advertised_address": "node1.cluster.graph.center",
        "dbms.connectors.default_listen_address": "0.0.0.0",
        "dbms.db.timezone": "UTC",
        "dbms.directories.certificates": "/var/lib/neo4j/certificates",
        "dbms.directories.data": "/var/lib/neo4j/data",
        "dbms.directories.import": "/var/lib/neo4j/import",
        "dbms.directories.lib": "/usr/share/neo4j/lib",
        "dbms.directories.logs": "/var/log/neo4j",
        "dbms.directories.metrics": "/var/lib/neo4j/metrics",
        "dbms.directories.plugins": "/var/lib/neo4j/plugins",
        "dbms.directories.run": "/var/run/neo4j",
        "dbms.directories.tx_log": "/var/lib/neo4j/data/databases/graph.db",
        "dbms.filewatcher.enabled": "true",
        "dbms.ids.reuse.types.override": "[RELATIONSHIP, NODE]",
        "dbms.import.csv.buffer_size": "2097152",
        "dbms.import.csv.legacy_quote_escaping": "true",
        "dbms.index.default_schema_provider": "native-btree-1.0",
        "dbms.index.fulltext.default_analyzer": "standard",
        "dbms.index.fulltext.eventually_consistent": "false",
        "dbms.index.fulltext.eventually_consistent_index_update_queue_max_length": "10000",
        "dbms.index_sampling.background_enabled": "true",
        "dbms.index_sampling.buffer_size": "67108864",
        "dbms.index_sampling.sample_size_limit": "8388608",
        "dbms.index_sampling.update_percentage": "5",
        "dbms.index_searcher_cache_size": "2147483647",
        "dbms.jvm.additional": "-Dunsupported.dbms.udc.source=gcloud-CORE",
        "dbms.lock.acquisition.timeout": "0ms",
        "dbms.logs.debug.level": "INFO",
        "dbms.logs.debug.path": "/var/log/neo4j/debug.log",
        "dbms.logs.debug.rotation.delay": "300000ms",
        "dbms.logs.debug.rotation.keep_number": "7",
        "dbms.logs.debug.rotation.size": "20971520",
        "dbms.logs.gc.enabled": "false",
        "dbms.logs.gc.options": "-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintPromotionFailure -XX:+PrintTenuringDistribution",
        "dbms.logs.gc.rotation.keep_number": "5",
        "dbms.logs.gc.rotation.size": "20971520",
        "dbms.logs.http.enabled": "false",
        "dbms.logs.http.path": "/var/log/neo4j/http.log",
        "dbms.logs.http.rotation.keep_number": "5",
        "dbms.logs.http.rotation.size": "20971520",
        "dbms.logs.query.allocation_logging_enabled": "false",
        "dbms.logs.query.enabled": "false",
        "dbms.logs.query.page_logging_enabled": "false",
        "dbms.logs.query.parameter_logging_enabled": "true",
        "dbms.logs.query.path": "/var/log/neo4j/query.log",
        "dbms.logs.query.rotation.keep_number": "7",
        "dbms.logs.query.rotation.size": "20971520",
        "dbms.logs.query.runtime_logging_enabled": "false",
        "dbms.logs.query.threshold": "0ms",
        "dbms.logs.query.time_logging_enabled": "false",
        "dbms.logs.security.level": "INFO",
        "dbms.logs.security.path": "/var/log/neo4j/security.log",
        "dbms.logs.security.rotation.delay": "300000ms",
        "dbms.logs.security.rotation.keep_number": "7",
        "dbms.logs.security.rotation.size": "20971520",
        "dbms.logs.timezone": "UTC",
        "dbms.logs.user.path": "/var/log/neo4j/neo4j.log",
        "dbms.logs.user.rotation.delay": "300000ms",
        "dbms.logs.user.rotation.keep_number": "7",
        "dbms.logs.user.rotation.size": "0",
        "dbms.logs.user.stdout_enabled": "true",
        "dbms.memory.heap.initial_size": "4900m",
        "dbms.memory.heap.max_size": "5000m",
        "dbms.memory.pagecache.size": "1g",
        "dbms.memory.pagecache.swapper": "",
        "dbms.mode": "CORE",
        "dbms.netty.ssl.provider": "JDK",
        "dbms.procedures.kill_query_verbose": "true",
        "dbms.query_cache_size": "1000",
        "dbms.read_only": "false",
        "dbms.record_format": "",
        "dbms.relationship_grouping_threshold": "50",
        "dbms.rest.transaction.idle_timeout": "60000ms",
        "dbms.security.allow_csv_import_from_file_urls": "true",
        "dbms.security.auth_cache_max_capacity": "10000",
        "dbms.security.auth_cache_ttl": "600000ms",
        "dbms.security.auth_cache_use_ttl": "true",
        "dbms.security.auth_enabled": "true",
        "dbms.security.auth_lock_time": "5000ms",
        "dbms.security.auth_max_failed_attempts": "3",
        "dbms.security.auth_provider": "native",
        "dbms.security.causal_clustering_status_auth_enabled": "true",
        "dbms.security.ha_status_auth_enabled": "true",
        "dbms.security.http_access_control_allow_origin": "*",
        "dbms.security.http_authorization_classes": "[]",
        "dbms.security.http_strict_transport_security": "",
        "dbms.security.ldap.authentication.cache_enabled": "true",
        "dbms.security.ldap.authentication.mechanism": "simple",
        "dbms.security.ldap.authentication.use_samaccountname": "false",
        "dbms.security.ldap.authentication.user_dn_template": "uid={0},ou=users,dc=example,dc=com",
        "dbms.security.ldap.authorization.group_membership_attributes": "[memberOf]",
        "dbms.security.ldap.authorization.group_to_role_mapping": "",
        "dbms.security.ldap.authorization.system_password": "",
        "dbms.security.ldap.authorization.system_username": "",
        "dbms.security.ldap.authorization.use_system_account": "false",
        "dbms.security.ldap.authorization.user_search_base": "ou=users,dc=example,dc=com",
        "dbms.security.ldap.authorization.user_search_filter": "(&(objectClass=*)(uid={0}))",
        "dbms.security.ldap.connection_timeout": "30000ms",
        "dbms.security.ldap.host": "localhost",
        "dbms.security.ldap.read_timeout": "30000ms",
        "dbms.security.ldap.referral": "follow",
        "dbms.security.ldap.use_starttls": "false",
        "dbms.security.log_successful_authentication": "true",
        "dbms.security.procedures.default_allowed": "",
        "dbms.security.procedures.roles": "",
        "dbms.security.procedures.unrestricted": "\"apoc.*,algo.*\"",
        "dbms.security.procedures.whitelist": "*",
        "dbms.security.property_level.blacklist": "",
        "dbms.security.property_level.enabled": "false",
        "dbms.shutdown_transaction_end_timeout": "10000ms",
        "dbms.ssl.policy.<policyname>.allow_key_generation": "false",
        "dbms.ssl.policy.<policyname>.base_directory": "",
        "dbms.ssl.policy.<policyname>.ciphers": "",
        "dbms.ssl.policy.<policyname>.client_auth": "REQUIRE",
        "dbms.ssl.policy.<policyname>.private_key": "private.key",
        "dbms.ssl.policy.<policyname>.public_certificate": "public.crt",
        "dbms.ssl.policy.<policyname>.revoked_dir": "revoked",
        "dbms.ssl.policy.<policyname>.tls_versions": "[TLSv1.2]",
        "dbms.ssl.policy.<policyname>.trust_all": "false",
        "dbms.ssl.policy.<policyname>.trusted_dir": "trusted",
        "dbms.ssl.policy.<policyname>.verify_hostname": "false",
        "dbms.threads.worker_count": "4",
        "dbms.track_query_allocation": "false",
        "dbms.track_query_cpu_time": "false",
        "dbms.transaction.bookmark_ready_timeout": "30000ms",
        "dbms.transaction.monitor.check.interval": "2000ms",
        "dbms.transaction.timeout": "0ms",
        "dbms.tx_log.rotation.retention_policy": "7 days",
        "dbms.tx_log.rotation.size": "262144000",
        "dbms.tx_state.max_off_heap_memory": "2147483648",
        "dbms.tx_state.memory_allocation": "ON_HEAP",
        "dbms.tx_state.off_heap.block_cache_size": "128",
        "dbms.tx_state.off_heap.max_cacheable_block_size": "524288",
        "dbms.udc.enabled": "true",
        "dbms.unmanaged_extension_classes": "[]",
        "dbms.windows_service_name": "neo4j",
        "ha.allow_init_cluster": "true",
        "ha.branched_data_copying_strategy": "branch_then_copy",
        "ha.branched_data_policy": "keep_all",
        "ha.broadcast_timeout": "30000ms",
        "ha.configuration_timeout": "1000ms",
        "ha.data_chunk_size": "2097152",
        "ha.default_timeout": "5000ms",
        "ha.election_timeout": "5000ms",
        "ha.heartbeat_interval": "5000ms",
        "ha.heartbeat_timeout": "40000ms",
        "ha.host.coordination": "0.0.0.0:5001-5099",
        "ha.host.data": "0.0.0.0:6001-6011",
        "ha.initial_hosts": "",
        "ha.internal_role_switch_timeout": "10000ms",
        "ha.join_timeout": "30000ms",
        "ha.learn_timeout": "5000ms",
        "ha.leave_timeout": "30000ms",
        "ha.max_acceptors": "21",
        "ha.max_channels_per_slave": "20",
        "ha.paxos_timeout": "5000ms",
        "ha.phase1_timeout": "5000ms",
        "ha.phase2_timeout": "5000ms",
        "ha.pull_batch_size": "100",
        "ha.pull_interval": "10000ms",
        "ha.role_switch_timeout": "120000ms",
        "ha.server_id": "",
        "ha.slave_lock_timeout": "20000ms",
        "ha.slave_only": "false",
        "ha.slave_read_timeout": "20000ms",
        "ha.tx_push_factor": "1",
        "ha.tx_push_strategy": "fixed_ascending",
        "https.ssl_policy": "legacy",
        "metrics.bolt.messages.enabled": "true",
        "metrics.csv.enabled": "true",
        "metrics.csv.interval": "3000ms",
        "metrics.csv.rotation.keep_number": "7",
        "metrics.csv.rotation.size": "10485760",
        "metrics.cypher.replanning.enabled": "true",
        "metrics.enabled": "true",
        "metrics.graphite.enabled": "false",
        "metrics.graphite.interval": "3000ms",
        "metrics.graphite.server": ":2003",
        "metrics.jvm.buffers.enabled": "true",
        "metrics.jvm.gc.enabled": "true",
        "metrics.jvm.memory.enabled": "true",
        "metrics.jvm.threads.enabled": "true",
        "metrics.neo4j.causal_clustering.enabled": "true",
        "metrics.neo4j.checkpointing.enabled": "true",
        "metrics.neo4j.cluster.enabled": "true",
        "metrics.neo4j.counts.enabled": "true",
        "metrics.neo4j.enabled": "true",
        "metrics.neo4j.logrotation.enabled": "true",
        "metrics.neo4j.network.enabled": "true",
        "metrics.neo4j.pagecache.enabled": "true",
        "metrics.neo4j.server.enabled": "true",
        "metrics.neo4j.tx.enabled": "true",
        "metrics.prefix": "neo4j",
        "metrics.prometheus.enabled": "false",
        "metrics.prometheus.endpoint": "localhost:2004",
        "tools.consistency_checker.check_graph": "true",
        "tools.consistency_checker.check_indexes": "true",
        "tools.consistency_checker.check_label_scan_store": "true",
        "tools.consistency_checker.check_property_owners": "false"
      },
      "apoc": {
        "version": "Neo4jError: Unknown function 'apoc.version' (line 1, column 8 (offset: 7))\n\"RETURN apoc.version() as value\"\n        ^"
      },
      "nodes": {
        "count": 6673172
      },
      "schema": {
        "labels": [
          "NAryTree",
          "Hub",
          "MergeNode",
          "Spoke",
          "Leaf",
          "Customer",
          "RawWriteNode",
          "Address",
          "SimpleWrite",
          "Node",
          "FatNode",
          "Test",
          "Fictional",
          "Interval",
          "ScaleInstance",
          "ChordInstance",
          "Chord",
          "Scale",
          "Tone",
          "Rando",
          "P",
          "TestNode",
          "Canary",
          "User",
          "Tweet",
          "Hashtag",
          "Source"
        ]
      },
      "algo": {
        "version": "Neo4jError: Unknown function 'algo.version' (line 1, column 8 (offset: 7))\n\"RETURN algo.version() as value\"\n        ^"
      }
    },
    {
      "basics": {
        "address": "bolt://node2.cluster.graph.center:7687",
        "procotols": [
          "bolt",
          "http",
          "https"
        ],
        "role": "FOLLOWER",
        "database": "default",
        "id": "d93a0d8d-d9f6-4c86-9bbf-8f05b20abd24",
        "label": "node2",
        "dbms": {
          "name": "Neo4j Kernel",
          "versions": [
            "3.5.0"
          ],
          "edition": "enterprise",
          "nativeAuth": true,
          "authEnabled": "true"
        },
        "performance": {
          "stdev": 192.70903131661512,
          "mean": 165.04347826086956,
          "median": 68,
          "mode": [
            49
          ],
          "min": 48,
          "max": 690,
          "errors": {},
          "observations": [
            {
              "x": "2019-03-03T01:17:30.312Z",
              "y": 542
            },
            {
              "x": "2019-03-03T01:17:30.882Z",
              "y": 94
            },
            {
              "x": "2019-03-03T01:17:31.005Z",
              "y": 104
            },
            {
              "x": "2019-03-03T01:17:31.061Z",
              "y": 159
            },
            {
              "x": "2019-03-03T01:17:31.172Z",
              "y": 269
            },
            {
              "x": "2019-03-03T01:17:31.321Z",
              "y": 416
            },
            {
              "x": "2019-03-03T01:17:31.465Z",
              "y": 558
            },
            {
              "x": "2019-03-03T01:17:31.600Z",
              "y": 690
            },
            {
              "x": "2019-03-03T01:17:31.931Z",
              "y": 49
            },
            {
              "x": "2019-03-03T01:17:32.057Z",
              "y": 52
            },
            {
              "x": "2019-03-03T01:17:32.182Z",
              "y": 113
            },
            {
              "x": "2019-03-03T01:17:32.221Z",
              "y": 48
            },
            {
              "x": "2019-03-03T01:17:32.981Z",
              "y": 49
            },
            {
              "x": "2019-03-03T01:17:33.111Z",
              "y": 53
            },
            {
              "x": "2019-03-03T01:17:33.274Z",
              "y": 52
            },
            {
              "x": "2019-03-03T01:17:33.298Z",
              "y": 116
            },
            {
              "x": "2019-03-03T01:17:33.371Z",
              "y": 49
            },
            {
              "x": "2019-03-03T01:17:33.533Z",
              "y": 68
            },
            {
              "x": "2019-03-03T01:17:33.650Z",
              "y": 49
            },
            {
              "x": "2019-03-03T01:17:34.034Z",
              "y": 52
            },
            {
              "x": "2019-03-03T01:17:34.161Z",
              "y": 49
            },
            {
              "x": "2019-03-03T01:17:34.324Z",
              "y": 49
            },
            {
              "x": "2019-03-03T01:17:34.415Z",
              "y": 116
            }
          ]
        }
      },
      "users": [
        {
          "username": "neo4j",
          "flags": [],
          "roles": [
            "admin"
          ]
        },
        {
          "username": "Node2User",
          "flags": [],
          "roles": [
            "Node2Role"
          ]
        },
        {
          "username": "reader",
          "flags": [],
          "roles": [
            "reader"
          ]
        },
        {
          "username": "testevent",
          "flags": [],
          "roles": []
        },
        {
          "username": "arepa",
          "flags": [],
          "roles": []
        },
        {
          "username": "ship",
          "flags": [],
          "roles": [
            "architect",
            "halindemo",
            "reader"
          ]
        },
        {
          "username": "test-newuser",
          "flags": [],
          "roles": [
            "halindemo",
            "testnewrole",
            "testy35role"
          ]
        },
        {
          "username": "halin",
          "flags": [],
          "roles": [
            "reader"
          ]
        }
      ],
      "roles": [
        {
          "role": "aa",
          "users": []
        },
        {
          "role": "editor",
          "users": []
        },
        {
          "role": "halindemo",
          "users": [
            "ship",
            "test-newuser"
          ]
        },
        {
          "role": "testy35role",
          "users": [
            "test-newuser"
          ]
        },
        {
          "role": "reader",
          "users": [
            "halin",
            "reader",
            "ship"
          ]
        },
        {
          "role": "architect",
          "users": [
            "ship"
          ]
        },
        {
          "role": "admin",
          "users": [
            "neo4j"
          ]
        },
        {
          "role": "publisher",
          "users": []
        },
        {
          "role": "Node2Role",
          "users": [
            "Node2User"
          ]
        },
        {
          "role": "testrole4",
          "users": []
        },
        {
          "role": "testnewrole",
          "users": [
            "test-newuser"
          ]
        }
      ],
      "indexes": [
        {
          "description": "INDEX ON :Address(city)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "city"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(cityPrefix)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "cityPrefix"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(country)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "country"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(countryCode)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "countryCode"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(county)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "county"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(created)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "created"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(location)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "location"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(score)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "score"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(secondaryAddress)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "secondaryAddress"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(state)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "state"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(stateAbbr)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "stateAbbr"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(streetAddress)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "streetAddress"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(streetName)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "streetName"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(streetPrefix)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "streetPrefix"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(zip)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "zip"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Chord(name)",
          "label": null,
          "tokenNames": [
            "Chord"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :ChordInstance(name)",
          "label": null,
          "tokenNames": [
            "ChordInstance"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Customer(created)",
          "label": null,
          "tokenNames": [
            "Customer"
          ],
          "properties": [
            "created"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Customer(email)",
          "label": null,
          "tokenNames": [
            "Customer"
          ],
          "properties": [
            "email"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Customer(id)",
          "label": null,
          "tokenNames": [
            "Customer"
          ],
          "properties": [
            "id"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Customer(name)",
          "label": null,
          "tokenNames": [
            "Customer"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Customer(score)",
          "label": null,
          "tokenNames": [
            "Customer"
          ],
          "properties": [
            "score"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Customer(username)",
          "label": null,
          "tokenNames": [
            "Customer"
          ],
          "properties": [
            "username"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :FatNode(data)",
          "label": null,
          "tokenNames": [
            "FatNode"
          ],
          "properties": [
            "data"
          ],
          "state": "FAILED",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Hashtag(name)",
          "label": null,
          "tokenNames": [
            "Hashtag"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Interval(name)",
          "label": null,
          "tokenNames": [
            "Interval"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Leaf(val)",
          "label": null,
          "tokenNames": [
            "Leaf"
          ],
          "properties": [
            "val"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :MergeNode(id)",
          "label": null,
          "tokenNames": [
            "MergeNode"
          ],
          "properties": [
            "id"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :NAryTree(val)",
          "label": null,
          "tokenNames": [
            "NAryTree"
          ],
          "properties": [
            "val"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Node(id)",
          "label": null,
          "tokenNames": [
            "Node"
          ],
          "properties": [
            "id"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :P(id)",
          "label": null,
          "tokenNames": [
            "P"
          ],
          "properties": [
            "id"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Rando(id)",
          "label": null,
          "tokenNames": [
            "Rando"
          ],
          "properties": [
            "id"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Scale(name)",
          "label": null,
          "tokenNames": [
            "Scale"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :ScaleInstance(name)",
          "label": null,
          "tokenNames": [
            "ScaleInstance"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Tone(name)",
          "label": null,
          "tokenNames": [
            "Tone"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Tweet(text)",
          "label": null,
          "tokenNames": [
            "Tweet"
          ],
          "properties": [
            "text"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :User(name)",
          "label": null,
          "tokenNames": [
            "User"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Fictional(id)",
          "label": null,
          "tokenNames": [
            "Fictional"
          ],
          "properties": [
            "id"
          ],
          "state": "ONLINE",
          "type": "node_unique_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        }
      ],
      "constraints": [
        {
          "idx": 0,
          "description": "CONSTRAINT ON ( fictional:Fictional ) ASSERT (fictional.id) IS NODE KEY"
        }
      ],
      "JMX": [
        {
          "name": "org.neo4j:instance=kernel#0,name=Kernel",
          "attributes": {
            "KernelVersion": {
              "description": "The version of Neo4j",
              "value": "neo4j-kernel, version: 3.5.0,78fb2c3fb974d4cc4ce4a7803283e2eb776305ff"
            },
            "ReadOnly": {
              "description": "Whether this is a read only instance",
              "value": false
            },
            "StoreId": {
              "description": "An identifier that, together with store creation time, uniquely identifies this Neo4j graph store.",
              "value": "4c06975e6b81247d"
            },
            "KernelStartTime": {
              "description": "The time from which this Neo4j instance was in operational mode.",
              "value": 1547139703544
            },
            "DatabaseName": {
              "description": "The name of the mounted database",
              "value": "graph.db"
            },
            "MBeanQuery": {
              "description": "An ObjectName that can be used as a query for getting all management beans for this Neo4j instance.",
              "value": "org.neo4j:instance=kernel#0,name=*"
            },
            "StoreLogVersion": {
              "description": "The current version of the Neo4j store logical log.",
              "value": 52
            },
            "StoreCreationDate": {
              "description": "The time when this Neo4j graph store was created.",
              "value": 1537200614306
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Causal Clustering",
          "attributes": {
            "Role": {
              "description": "The current role this member has in the cluster",
              "value": "FOLLOWER"
            },
            "ReplicatedStateSize": {
              "description": "The total amount of disk space used by the replicated states, in bytes",
              "value": 17446
            },
            "RaftLogSize": {
              "description": "The total amount of disk space used by the raft log, in bytes",
              "value": 1313224703
            }
          }
        },
        {
          "name": "JMImplementation:type=MBeanServerDelegate",
          "attributes": {
            "ImplementationName": {
              "description": "The JMX implementation name (the name of this product)",
              "value": "JMX"
            },
            "MBeanServerId": {
              "description": "The MBean server agent identification",
              "value": "meetup-cluster-core-vm-2_1547139665158"
            },
            "ImplementationVersion": {
              "description": "The JMX implementation version (the version of this product).",
              "value": "1.8.0_191-8u191-b12-0ubuntu0.16.04.1-b12"
            },
            "SpecificationVersion": {
              "description": "The version of the JMX specification implemented by this product.",
              "value": "1.4"
            },
            "SpecificationVendor": {
              "description": "The vendor of the JMX specification implemented by this product.",
              "value": "Oracle Corporation"
            },
            "SpecificationName": {
              "description": "The full name of the JMX specification implemented by this product.",
              "value": "Java Management Extensions"
            },
            "ImplementationVendor": {
              "description": "the JMX implementation vendor (the vendor of this product).",
              "value": "Oracle Corporation"
            }
          }
        },
        {
          "name": "java.lang:type=Runtime",
          "attributes": {
            "SpecVendor": {
              "description": "SpecVendor",
              "value": "Oracle Corporation"
            },
            "ClassPath": {
              "description": "ClassPath",
              "value": "/var/lib/neo4j/plugins:/etc/neo4j:/usr/share/neo4j/lib/concurrentlinkedhashmap-lru-1.4.2.jar:/usr/share/neo4j/lib/ssl-config-core_2.11-0.2.3.jar:/usr/share/neo4j/lib/jersey-core-1.19.3.jar:/usr/share/neo4j/lib/neo4j-auth-plugin-api-3.5.0.jar:/usr/share/neo4j/lib/jetty-util-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-fulltext-index-3.5.0.jar:/usr/share/neo4j/lib/neo4j-com-3.5.0.jar:/usr/share/neo4j/lib/akka-actor_2.11-2.5.14.jar:/usr/share/neo4j/lib/config-1.3.3.jar:/usr/share/neo4j/lib/ast-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/akka-protobuf_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-diagnostics-3.5.0.jar:/usr/share/neo4j/lib/jetty-webapp-9.4.11.v20180605.jar:/usr/share/neo4j/lib/jProcesses-1.6.4.jar:/usr/share/neo4j/lib/jetty-servlet-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-graphdb-api-3.5.0.jar:/usr/share/neo4j/lib/jsr311-api-1.1.2.r612.jar:/usr/share/neo4j/lib/neo4j-resource-3.5.0.jar:/usr/share/neo4j/lib/jaxb-core-2.3.0.1.jar:/usr/share/neo4j/lib/neo4j-cypher-ir-3.5-3.5.0.jar:/usr/share/neo4j/lib/bcprov-jdk15on-1.60.jar:/usr/share/neo4j/lib/neo4j-management-3.5.0.jar:/usr/share/neo4j/lib/jackson-mapper-asl-1.9.13.jar:/usr/share/neo4j/lib/jetty-security-9.4.11.v20180605.jar:/usr/share/neo4j/lib/jackson-jaxrs-1.9.13.jar:/usr/share/neo4j/lib/neo4j-command-line-3.5.0.jar:/usr/share/neo4j/lib/neo4j-ha-3.5.0.jar:/usr/share/neo4j/lib/jaxb-api-2.3.0.jar:/usr/share/neo4j/lib/shiro-crypto-cipher-1.4.0.jar:/usr/share/neo4j/lib/neo4j-server-enterprise-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-util-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-cypher-compiled-expressions-3.5.0.jar:/usr/share/neo4j/lib/neo4j-server-3.5.0.jar:/usr/share/neo4j/lib/neo4j-io-3.5.0.jar:/usr/share/neo4j/lib/scala-parser-combinators_2.11-1.1.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-spi-3.5-3.5.0.jar:/usr/share/neo4j/lib/shiro-core-1.4.0.jar:/usr/share/neo4j/lib/jline-2.14.3.jar:/usr/share/neo4j/lib/scallop_2.11-2.1.1.jar:/usr/share/neo4j/lib/txw2-2.3.0.1.jar:/usr/share/neo4j/lib/istack-commons-runtime-3.0.5.jar:/usr/share/neo4j/lib/akka-cluster_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-common-3.5.0.jar:/usr/share/neo4j/lib/neo4j-server-commercial-3.5.0.jar:/usr/share/neo4j/lib/util-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/opencsv-2.3.jar:/usr/share/neo4j/lib/neo4j-index-3.5.0.jar:/usr/share/neo4j/lib/jetty-server-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-concurrent-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-kernel-api-3.5.0.jar:/usr/share/neo4j/lib/asm-analysis-6.2.jar:/usr/share/neo4j/lib/neo4j-security-enterprise-3.5.0.jar:/usr/share/neo4j/lib/neo4j-causal-clustering-3.5.0.jar:/usr/share/neo4j/lib/neo4j-dbms-3.5.0.jar:/usr/share/neo4j/lib/parser-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/neo4j-cypher-frontend-2.3-2.3.12.jar:/usr/share/neo4j/lib/neo4j-values-3.5.0.jar:/usr/share/neo4j/lib/netty-3.9.9.Final.jar:/usr/share/neo4j/lib/neo4j-cypher-slotted-runtime-3.5.0.jar:/usr/share/neo4j/lib/akka-cluster-tools_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-cypher-3.5.0.jar:/usr/share/neo4j/lib/commons-configuration-1.10.jar:/usr/share/neo4j/lib/bcpkix-jdk15on-1.60.jar:/usr/share/neo4j/lib/commons-lang-2.6.jar:/usr/share/neo4j/lib/server-api-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-compiler-3.1-3.1.9.jar:/usr/share/neo4j/lib/neo4j-enterprise-kernel-3.5.0.jar:/usr/share/neo4j/lib/shiro-config-core-1.4.0.jar:/usr/share/neo4j/lib/neo4j-unsafe-3.5.0.jar:/usr/share/neo4j/lib/asm-tree-6.2.jar:/usr/share/neo4j/lib/jaxb-runtime-2.3.0.1.jar:/usr/share/neo4j/lib/stax-ex-1.7.8.jar:/usr/share/neo4j/lib/neo4j-csv-3.5.0.jar:/usr/share/neo4j/lib/neo4j-kernel-3.5.0.jar:/usr/share/neo4j/lib/shiro-crypto-hash-1.4.0.jar:/usr/share/neo4j/lib/jetty-io-9.4.11.v20180605.jar:/usr/share/neo4j/lib/jackson-core-asl-1.9.13.jar:/usr/share/neo4j/lib/jersey-server-1.19.3.jar:/usr/share/neo4j/lib/akka-stream_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-cypher-runtime-util-3.5.0.jar:/usr/share/neo4j/lib/shiro-event-1.4.0.jar:/usr/share/neo4j/lib/jersey-servlet-1.19.3.jar:/usr/share/neo4j/lib/WMI4Java-1.6.1.jar:/usr/share/neo4j/lib/hazelcast-all-3.7.8.jar:/usr/share/neo4j/lib/metrics-core-4.0.2.jar:/usr/share/neo4j/lib/parboiled-core-1.1.7.jar:/usr/share/neo4j/lib/neo4j-spatial-index-3.5.0.jar:/usr/share/neo4j/lib/rewriting-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/neo4j-udc-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-physical-planning-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-3.5-3.5.0.jar:/usr/share/neo4j/lib/neo4j-codegen-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-morsel-runtime-3.5.0.jar:/usr/share/neo4j/lib/reactive-streams-1.0.2.jar:/usr/share/neo4j/lib/neo4j-import-tool-3.5.0.jar:/usr/share/neo4j/lib/akka-remote_2.11-2.5.14.jar:/usr/share/neo4j/lib/lucene-analyzers-common-5.5.5.jar:/usr/share/neo4j/lib/neo4j-logging-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-logical-plans-3.5-3.5.0.jar:/usr/share/neo4j/lib/front-end-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/scala-java8-compat_2.11-0.7.0.jar:/usr/share/neo4j/lib/parboiled-scala_2.11-1.1.7.jar:/usr/share/neo4j/lib/simpleclient_httpserver-0.4.0.jar:/usr/share/neo4j/lib/neo4j-query-logging-3.5.0.jar:/usr/share/neo4j/lib/commons-text-1.4.jar:/usr/share/neo4j/lib/simpleclient-0.4.0.jar:/usr/share/neo4j/lib/lucene-core-5.5.5.jar:/usr/share/neo4j/lib/netty-all-4.1.30.Final.jar:/usr/share/neo4j/lib/neo4j-causal-clustering-commercial-3.5.0.jar:/usr/share/neo4j/lib/slf4j-api-1.7.25.jar:/usr/share/neo4j/lib/commons-collections-3.2.2.jar:/usr/share/neo4j/lib/neo4j-lucene-upgrade-3.5.0.jar:/usr/share/neo4j/lib/eclipse-collections-9.2.0.jar:/usr/share/neo4j/lib/neo4j-consistency-check-3.5.0.jar:/usr/share/neo4j/lib/neo4j-kernel-commercial-3.5.0.jar:/usr/share/neo4j/lib/neo4j-backup-3.5.0.jar:/usr/share/neo4j/lib/neo4j-configuration-3.5.0.jar:/usr/share/neo4j/lib/neo4j-commercial-3.5.0.jar:/usr/share/neo4j/lib/neo4j-security-3.5.0.jar:/usr/share/neo4j/lib/commons-compress-1.18.jar:/usr/share/neo4j/lib/kiama_2.11-2.1.0.jar:/usr/share/neo4j/lib/neo4j-cypher-frontend-3.1-3.1.9.jar:/usr/share/neo4j/lib/neo4j-cypher-ir-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-cypher-logical-plans-3.4-3.4.9.jar:/usr/share/neo4j/lib/eclipse-collections-api-9.2.0.jar:/usr/share/neo4j/lib/neo4j-security-commercial-3.5.0.jar:/usr/share/neo4j/lib/openCypher-frontend-1-3.4.9.jar:/usr/share/neo4j/lib/simpleclient_common-0.4.0.jar:/usr/share/neo4j/lib/commons-logging-1.1.1.jar:/usr/share/neo4j/lib/commons-beanutils-1.9.3.jar:/usr/share/neo4j/lib/caffeine-2.6.2.jar:/usr/share/neo4j/lib/neo4j-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-compiler-2.3-2.3.12.jar:/usr/share/neo4j/lib/aeron-client-1.9.1.jar:/usr/share/neo4j/lib/metrics-graphite-4.0.2.jar:/usr/share/neo4j/lib/activation-1.1.1.jar:/usr/share/neo4j/lib/expressions-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/jetty-client-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-jmx-3.5.0.jar:/usr/share/neo4j/lib/neo4j-browser-3.2.13.jar:/usr/share/neo4j/lib/neo4j-graph-algo-3.5.0.jar:/usr/share/neo4j/lib/neo4j-graph-matching-3.1.9.jar:/usr/share/neo4j/lib/neo4j-cluster-3.5.0.jar:/usr/share/neo4j/lib/neo4j-collections-3.5.0.jar:/usr/share/neo4j/lib/lz4-1.3.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-spi-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-lucene-index-3.5.0.jar:/usr/share/neo4j/lib/FastInfoset-1.2.13.jar:/usr/share/neo4j/lib/shiro-lang-1.4.0.jar:/usr/share/neo4j/lib/commons-io-2.6.jar:/usr/share/neo4j/lib/neo4j-cypher-interpreted-runtime-3.5.0.jar:/usr/share/neo4j/lib/simpleclient_dropwizard-0.4.0.jar:/usr/share/neo4j/lib/neo4j-legacy-3.5.0.jar:/usr/share/neo4j/lib/scala-reflect-2.11.12.jar:/usr/share/neo4j/lib/agrona-0.9.17.jar:/usr/share/neo4j/lib/shiro-crypto-core-1.4.0.jar:/usr/share/neo4j/lib/neo4j-enterprise-cypher-3.5.0.jar:/usr/share/neo4j/lib/akka-distributed-data_2.11-2.5.14.jar:/usr/share/neo4j/lib/shiro-config-ogdl-1.4.0.jar:/usr/share/neo4j/lib/asm-util-6.2.jar:/usr/share/neo4j/lib/jetty-http-9.4.11.v20180605.jar:/usr/share/neo4j/lib/lucene-codecs-5.5.5.jar:/usr/share/neo4j/lib/neo4j-bolt-3.5.0.jar:/usr/share/neo4j/lib/lucene-queryparser-5.5.5.jar:/usr/share/neo4j/lib/scala-library-2.11.12.jar:/usr/share/neo4j/lib/neo4j-ssl-3.5.0.jar:/usr/share/neo4j/lib/jetty-xml-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-procedure-api-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-expression-3.4-3.4.9.jar:/usr/share/neo4j/lib/jPowerShell-1.9.jar:/usr/share/neo4j/lib/shiro-cache-1.4.0.jar:/usr/share/neo4j/lib/javax.servlet-api-3.1.0.jar:/usr/share/neo4j/lib/neo4j-metrics-3.5.0.jar:/usr/share/neo4j/lib/slf4j-nop-1.7.25.jar:/usr/share/neo4j/lib/commons-lang3-3.8.jar:/usr/share/neo4j/lib/asm-6.2.jar:/usr/share/neo4j/lib/aeron-driver-1.9.1.jar:/var/lib/neo4j/plugins/*"
            },
            "InputArguments": {
              "description": "InputArguments",
              "value": [
                "-XX:+UseG1GC",
                "-XX:-OmitStackTraceInFastThrow",
                "-XX:+AlwaysPreTouch",
                "-XX:+UnlockExperimentalVMOptions",
                "-XX:+TrustFinalNonStaticFields",
                "-XX:+DisableExplicitGC",
                "-Djdk.tls.ephemeralDHKeySize=2048",
                "-Djdk.tls.rejectClientInitiatedRenegotiation=true",
                "-Dunsupported.dbms.udc.source=gcloud-CORE",
                "-Dfile.encoding=UTF-8"
              ]
            },
            "Uptime": {
              "description": "Uptime",
              "value": 4436205166
            },
            "VmName": {
              "description": "VmName",
              "value": "OpenJDK 64-Bit Server VM"
            },
            "StartTime": {
              "description": "StartTime",
              "value": 1547139650691
            },
            "SpecName": {
              "description": "SpecName",
              "value": "Java Virtual Machine Specification"
            },
            "VmVersion": {
              "description": "VmVersion",
              "value": "25.191-b12"
            },
            "ManagementSpecVersion": {
              "description": "ManagementSpecVersion",
              "value": "1.2"
            },
            "Name": {
              "description": "Name",
              "value": "17634@meetup-cluster-core-vm-2"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:type=Runtime"
            },
            "VmVendor": {
              "description": "VmVendor",
              "value": "Oracle Corporation"
            },
            "LibraryPath": {
              "description": "LibraryPath",
              "value": "/usr/java/packages/lib/amd64:/usr/lib/x86_64-linux-gnu/jni:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/usr/lib/jni:/lib:/usr/lib"
            },
            "BootClassPath": {
              "description": "BootClassPath",
              "value": "/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/rt.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jfr.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/classes"
            },
            "SpecVersion": {
              "description": "SpecVersion",
              "value": "1.8"
            },
            "SystemProperties": {
              "description": "SystemProperties",
              "value": {
                "[sun.io.unicode.encoding]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "UnicodeLittle",
                    "key": "sun.io.unicode.encoding"
                  }
                },
                "[awt.toolkit]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "sun.awt.X11.XToolkit",
                    "key": "awt.toolkit"
                  }
                },
                "[sun.java.command]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "com.neo4j.server.enterprise.CommercialEntryPoint --home-dir=/var/lib/neo4j --config-dir=/etc/neo4j",
                    "key": "sun.java.command"
                  }
                },
                "[file.separator]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/",
                    "key": "file.separator"
                  }
                },
                "[sun.arch.data.model]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "64",
                    "key": "sun.arch.data.model"
                  }
                },
                "[java.vm.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "25.191-b12",
                    "key": "java.vm.version"
                  }
                },
                "[java.class.path]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/var/lib/neo4j/plugins:/etc/neo4j:/usr/share/neo4j/lib/concurrentlinkedhashmap-lru-1.4.2.jar:/usr/share/neo4j/lib/ssl-config-core_2.11-0.2.3.jar:/usr/share/neo4j/lib/jersey-core-1.19.3.jar:/usr/share/neo4j/lib/neo4j-auth-plugin-api-3.5.0.jar:/usr/share/neo4j/lib/jetty-util-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-fulltext-index-3.5.0.jar:/usr/share/neo4j/lib/neo4j-com-3.5.0.jar:/usr/share/neo4j/lib/akka-actor_2.11-2.5.14.jar:/usr/share/neo4j/lib/config-1.3.3.jar:/usr/share/neo4j/lib/ast-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/akka-protobuf_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-diagnostics-3.5.0.jar:/usr/share/neo4j/lib/jetty-webapp-9.4.11.v20180605.jar:/usr/share/neo4j/lib/jProcesses-1.6.4.jar:/usr/share/neo4j/lib/jetty-servlet-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-graphdb-api-3.5.0.jar:/usr/share/neo4j/lib/jsr311-api-1.1.2.r612.jar:/usr/share/neo4j/lib/neo4j-resource-3.5.0.jar:/usr/share/neo4j/lib/jaxb-core-2.3.0.1.jar:/usr/share/neo4j/lib/neo4j-cypher-ir-3.5-3.5.0.jar:/usr/share/neo4j/lib/bcprov-jdk15on-1.60.jar:/usr/share/neo4j/lib/neo4j-management-3.5.0.jar:/usr/share/neo4j/lib/jackson-mapper-asl-1.9.13.jar:/usr/share/neo4j/lib/jetty-security-9.4.11.v20180605.jar:/usr/share/neo4j/lib/jackson-jaxrs-1.9.13.jar:/usr/share/neo4j/lib/neo4j-command-line-3.5.0.jar:/usr/share/neo4j/lib/neo4j-ha-3.5.0.jar:/usr/share/neo4j/lib/jaxb-api-2.3.0.jar:/usr/share/neo4j/lib/shiro-crypto-cipher-1.4.0.jar:/usr/share/neo4j/lib/neo4j-server-enterprise-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-util-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-cypher-compiled-expressions-3.5.0.jar:/usr/share/neo4j/lib/neo4j-server-3.5.0.jar:/usr/share/neo4j/lib/neo4j-io-3.5.0.jar:/usr/share/neo4j/lib/scala-parser-combinators_2.11-1.1.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-spi-3.5-3.5.0.jar:/usr/share/neo4j/lib/shiro-core-1.4.0.jar:/usr/share/neo4j/lib/jline-2.14.3.jar:/usr/share/neo4j/lib/scallop_2.11-2.1.1.jar:/usr/share/neo4j/lib/txw2-2.3.0.1.jar:/usr/share/neo4j/lib/istack-commons-runtime-3.0.5.jar:/usr/share/neo4j/lib/akka-cluster_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-common-3.5.0.jar:/usr/share/neo4j/lib/neo4j-server-commercial-3.5.0.jar:/usr/share/neo4j/lib/util-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/opencsv-2.3.jar:/usr/share/neo4j/lib/neo4j-index-3.5.0.jar:/usr/share/neo4j/lib/jetty-server-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-concurrent-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-kernel-api-3.5.0.jar:/usr/share/neo4j/lib/asm-analysis-6.2.jar:/usr/share/neo4j/lib/neo4j-security-enterprise-3.5.0.jar:/usr/share/neo4j/lib/neo4j-causal-clustering-3.5.0.jar:/usr/share/neo4j/lib/neo4j-dbms-3.5.0.jar:/usr/share/neo4j/lib/parser-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/neo4j-cypher-frontend-2.3-2.3.12.jar:/usr/share/neo4j/lib/neo4j-values-3.5.0.jar:/usr/share/neo4j/lib/netty-3.9.9.Final.jar:/usr/share/neo4j/lib/neo4j-cypher-slotted-runtime-3.5.0.jar:/usr/share/neo4j/lib/akka-cluster-tools_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-cypher-3.5.0.jar:/usr/share/neo4j/lib/commons-configuration-1.10.jar:/usr/share/neo4j/lib/bcpkix-jdk15on-1.60.jar:/usr/share/neo4j/lib/commons-lang-2.6.jar:/usr/share/neo4j/lib/server-api-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-compiler-3.1-3.1.9.jar:/usr/share/neo4j/lib/neo4j-enterprise-kernel-3.5.0.jar:/usr/share/neo4j/lib/shiro-config-core-1.4.0.jar:/usr/share/neo4j/lib/neo4j-unsafe-3.5.0.jar:/usr/share/neo4j/lib/asm-tree-6.2.jar:/usr/share/neo4j/lib/jaxb-runtime-2.3.0.1.jar:/usr/share/neo4j/lib/stax-ex-1.7.8.jar:/usr/share/neo4j/lib/neo4j-csv-3.5.0.jar:/usr/share/neo4j/lib/neo4j-kernel-3.5.0.jar:/usr/share/neo4j/lib/shiro-crypto-hash-1.4.0.jar:/usr/share/neo4j/lib/jetty-io-9.4.11.v20180605.jar:/usr/share/neo4j/lib/jackson-core-asl-1.9.13.jar:/usr/share/neo4j/lib/jersey-server-1.19.3.jar:/usr/share/neo4j/lib/akka-stream_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-cypher-runtime-util-3.5.0.jar:/usr/share/neo4j/lib/shiro-event-1.4.0.jar:/usr/share/neo4j/lib/jersey-servlet-1.19.3.jar:/usr/share/neo4j/lib/WMI4Java-1.6.1.jar:/usr/share/neo4j/lib/hazelcast-all-3.7.8.jar:/usr/share/neo4j/lib/metrics-core-4.0.2.jar:/usr/share/neo4j/lib/parboiled-core-1.1.7.jar:/usr/share/neo4j/lib/neo4j-spatial-index-3.5.0.jar:/usr/share/neo4j/lib/rewriting-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/neo4j-udc-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-physical-planning-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-3.5-3.5.0.jar:/usr/share/neo4j/lib/neo4j-codegen-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-morsel-runtime-3.5.0.jar:/usr/share/neo4j/lib/reactive-streams-1.0.2.jar:/usr/share/neo4j/lib/neo4j-import-tool-3.5.0.jar:/usr/share/neo4j/lib/akka-remote_2.11-2.5.14.jar:/usr/share/neo4j/lib/lucene-analyzers-common-5.5.5.jar:/usr/share/neo4j/lib/neo4j-logging-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-logical-plans-3.5-3.5.0.jar:/usr/share/neo4j/lib/front-end-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/scala-java8-compat_2.11-0.7.0.jar:/usr/share/neo4j/lib/parboiled-scala_2.11-1.1.7.jar:/usr/share/neo4j/lib/simpleclient_httpserver-0.4.0.jar:/usr/share/neo4j/lib/neo4j-query-logging-3.5.0.jar:/usr/share/neo4j/lib/commons-text-1.4.jar:/usr/share/neo4j/lib/simpleclient-0.4.0.jar:/usr/share/neo4j/lib/lucene-core-5.5.5.jar:/usr/share/neo4j/lib/netty-all-4.1.30.Final.jar:/usr/share/neo4j/lib/neo4j-causal-clustering-commercial-3.5.0.jar:/usr/share/neo4j/lib/slf4j-api-1.7.25.jar:/usr/share/neo4j/lib/commons-collections-3.2.2.jar:/usr/share/neo4j/lib/neo4j-lucene-upgrade-3.5.0.jar:/usr/share/neo4j/lib/eclipse-collections-9.2.0.jar:/usr/share/neo4j/lib/neo4j-consistency-check-3.5.0.jar:/usr/share/neo4j/lib/neo4j-kernel-commercial-3.5.0.jar:/usr/share/neo4j/lib/neo4j-backup-3.5.0.jar:/usr/share/neo4j/lib/neo4j-configuration-3.5.0.jar:/usr/share/neo4j/lib/neo4j-commercial-3.5.0.jar:/usr/share/neo4j/lib/neo4j-security-3.5.0.jar:/usr/share/neo4j/lib/commons-compress-1.18.jar:/usr/share/neo4j/lib/kiama_2.11-2.1.0.jar:/usr/share/neo4j/lib/neo4j-cypher-frontend-3.1-3.1.9.jar:/usr/share/neo4j/lib/neo4j-cypher-ir-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-cypher-logical-plans-3.4-3.4.9.jar:/usr/share/neo4j/lib/eclipse-collections-api-9.2.0.jar:/usr/share/neo4j/lib/neo4j-security-commercial-3.5.0.jar:/usr/share/neo4j/lib/openCypher-frontend-1-3.4.9.jar:/usr/share/neo4j/lib/simpleclient_common-0.4.0.jar:/usr/share/neo4j/lib/commons-logging-1.1.1.jar:/usr/share/neo4j/lib/commons-beanutils-1.9.3.jar:/usr/share/neo4j/lib/caffeine-2.6.2.jar:/usr/share/neo4j/lib/neo4j-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-compiler-2.3-2.3.12.jar:/usr/share/neo4j/lib/aeron-client-1.9.1.jar:/usr/share/neo4j/lib/metrics-graphite-4.0.2.jar:/usr/share/neo4j/lib/activation-1.1.1.jar:/usr/share/neo4j/lib/expressions-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/jetty-client-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-jmx-3.5.0.jar:/usr/share/neo4j/lib/neo4j-browser-3.2.13.jar:/usr/share/neo4j/lib/neo4j-graph-algo-3.5.0.jar:/usr/share/neo4j/lib/neo4j-graph-matching-3.1.9.jar:/usr/share/neo4j/lib/neo4j-cluster-3.5.0.jar:/usr/share/neo4j/lib/neo4j-collections-3.5.0.jar:/usr/share/neo4j/lib/lz4-1.3.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-spi-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-lucene-index-3.5.0.jar:/usr/share/neo4j/lib/FastInfoset-1.2.13.jar:/usr/share/neo4j/lib/shiro-lang-1.4.0.jar:/usr/share/neo4j/lib/commons-io-2.6.jar:/usr/share/neo4j/lib/neo4j-cypher-interpreted-runtime-3.5.0.jar:/usr/share/neo4j/lib/simpleclient_dropwizard-0.4.0.jar:/usr/share/neo4j/lib/neo4j-legacy-3.5.0.jar:/usr/share/neo4j/lib/scala-reflect-2.11.12.jar:/usr/share/neo4j/lib/agrona-0.9.17.jar:/usr/share/neo4j/lib/shiro-crypto-core-1.4.0.jar:/usr/share/neo4j/lib/neo4j-enterprise-cypher-3.5.0.jar:/usr/share/neo4j/lib/akka-distributed-data_2.11-2.5.14.jar:/usr/share/neo4j/lib/shiro-config-ogdl-1.4.0.jar:/usr/share/neo4j/lib/asm-util-6.2.jar:/usr/share/neo4j/lib/jetty-http-9.4.11.v20180605.jar:/usr/share/neo4j/lib/lucene-codecs-5.5.5.jar:/usr/share/neo4j/lib/neo4j-bolt-3.5.0.jar:/usr/share/neo4j/lib/lucene-queryparser-5.5.5.jar:/usr/share/neo4j/lib/scala-library-2.11.12.jar:/usr/share/neo4j/lib/neo4j-ssl-3.5.0.jar:/usr/share/neo4j/lib/jetty-xml-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-procedure-api-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-expression-3.4-3.4.9.jar:/usr/share/neo4j/lib/jPowerShell-1.9.jar:/usr/share/neo4j/lib/shiro-cache-1.4.0.jar:/usr/share/neo4j/lib/javax.servlet-api-3.1.0.jar:/usr/share/neo4j/lib/neo4j-metrics-3.5.0.jar:/usr/share/neo4j/lib/slf4j-nop-1.7.25.jar:/usr/share/neo4j/lib/commons-lang3-3.8.jar:/usr/share/neo4j/lib/asm-6.2.jar:/usr/share/neo4j/lib/aeron-driver-1.9.1.jar:/var/lib/neo4j/plugins/*",
                    "key": "java.class.path"
                  }
                },
                "[path.separator]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": ":",
                    "key": "path.separator"
                  }
                },
                "[java.vendor]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Oracle Corporation",
                    "key": "java.vendor"
                  }
                },
                "[java.awt.graphicsenv]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "sun.awt.X11GraphicsEnvironment",
                    "key": "java.awt.graphicsenv"
                  }
                },
                "[java.ext.dirs]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/ext:/usr/java/packages/lib/ext",
                    "key": "java.ext.dirs"
                  }
                },
                "[hazelcast.socket.bind.any]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "false",
                    "key": "hazelcast.socket.bind.any"
                  }
                },
                "[os.name]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Linux",
                    "key": "os.name"
                  }
                },
                "[jdk.tls.rejectClientInitiatedRenegotiation]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "true",
                    "key": "jdk.tls.rejectClientInitiatedRenegotiation"
                  }
                },
                "[java.class.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "52.0",
                    "key": "java.class.version"
                  }
                },
                "[user.dir]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/",
                    "key": "user.dir"
                  }
                },
                "[line.separator]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "\n",
                    "key": "line.separator"
                  }
                },
                "[hazelcast.wait.seconds.before.join]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "1",
                    "key": "hazelcast.wait.seconds.before.join"
                  }
                },
                "[java.io.tmpdir]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/tmp",
                    "key": "java.io.tmpdir"
                  }
                },
                "[java.vm.specification.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "1.8",
                    "key": "java.vm.specification.version"
                  }
                },
                "[java.runtime.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "1.8.0_191-8u191-b12-0ubuntu0.16.04.1-b12",
                    "key": "java.runtime.version"
                  }
                },
                "[sun.management.compiler]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "HotSpot 64-Bit Tiered Compilers",
                    "key": "sun.management.compiler"
                  }
                },
                "[hazelcast.phone.home.enabled]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "false",
                    "key": "hazelcast.phone.home.enabled"
                  }
                },
                "[java.specification.name]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Java Platform API Specification",
                    "key": "java.specification.name"
                  }
                },
                "[java.home]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/usr/lib/jvm/java-8-openjdk-amd64/jre",
                    "key": "java.home"
                  }
                },
                "[sun.cpu.isalist]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "",
                    "key": "sun.cpu.isalist"
                  }
                },
                "[user.timezone]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Etc/UTC",
                    "key": "user.timezone"
                  }
                },
                "[sun.java.launcher]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "SUN_STANDARD",
                    "key": "sun.java.launcher"
                  }
                },
                "[java.specification.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "1.8",
                    "key": "java.specification.version"
                  }
                },
                "[unsupported.dbms.udc.source]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "gcloud-CORE",
                    "key": "unsupported.dbms.udc.source"
                  }
                },
                "[java.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "1.8.0_191",
                    "key": "java.version"
                  }
                },
                "[file.encoding]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "UTF-8",
                    "key": "file.encoding"
                  }
                },
                "[java.runtime.name]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "OpenJDK Runtime Environment",
                    "key": "java.runtime.name"
                  }
                },
                "[java.specification.vendor]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Oracle Corporation",
                    "key": "java.specification.vendor"
                  }
                },
                "[java.vendor.url.bug]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "http://bugreport.sun.com/bugreport/",
                    "key": "java.vendor.url.bug"
                  }
                },
                "[java.vendor.url]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "http://java.oracle.com/",
                    "key": "java.vendor.url"
                  }
                },
                "[file.encoding.pkg]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "sun.io",
                    "key": "file.encoding.pkg"
                  }
                },
                "[jetty.git.hash]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "d5fc0523cfa96bfebfbda19606cad384d772f04c",
                    "key": "jetty.git.hash"
                  }
                },
                "[jdk.tls.ephemeralDHKeySize]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "2048",
                    "key": "jdk.tls.ephemeralDHKeySize"
                  }
                },
                "[java.endorsed.dirs]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/endorsed",
                    "key": "java.endorsed.dirs"
                  }
                },
                "[os.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "4.15.0-1017-gcp",
                    "key": "os.version"
                  }
                },
                "[java.vm.specification.name]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Java Virtual Machine Specification",
                    "key": "java.vm.specification.name"
                  }
                },
                "[user.name]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "neo4j",
                    "key": "user.name"
                  }
                },
                "[user.country]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "US",
                    "key": "user.country"
                  }
                },
                "[java.vm.vendor]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Oracle Corporation",
                    "key": "java.vm.vendor"
                  }
                },
                "[hazelcast.shutdownhook.enabled]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "false",
                    "key": "hazelcast.shutdownhook.enabled"
                  }
                },
                "[java.library.path]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/usr/java/packages/lib/amd64:/usr/lib/x86_64-linux-gnu/jni:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/usr/lib/jni:/lib:/usr/lib",
                    "key": "java.library.path"
                  }
                },
                "[sun.os.patch.level]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "unknown",
                    "key": "sun.os.patch.level"
                  }
                },
                "[user.language]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "en",
                    "key": "user.language"
                  }
                },
                "[sun.boot.library.path]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/amd64",
                    "key": "sun.boot.library.path"
                  }
                },
                "[java.vm.name]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "OpenJDK 64-Bit Server VM",
                    "key": "java.vm.name"
                  }
                },
                "[sun.nio.ch.bugLevel]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "",
                    "key": "sun.nio.ch.bugLevel"
                  }
                },
                "[hazelcast.logging.type]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "none",
                    "key": "hazelcast.logging.type"
                  }
                },
                "[sun.cpu.endian]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "little",
                    "key": "sun.cpu.endian"
                  }
                },
                "[java.vm.info]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "mixed mode",
                    "key": "java.vm.info"
                  }
                },
                "[os.arch]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "amd64",
                    "key": "os.arch"
                  }
                },
                "[user.home]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/var/lib/neo4j",
                    "key": "user.home"
                  }
                },
                "[sun.boot.class.path]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/rt.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jfr.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/classes",
                    "key": "sun.boot.class.path"
                  }
                },
                "[java.vm.specification.vendor]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Oracle Corporation",
                    "key": "java.vm.specification.vendor"
                  }
                },
                "[sun.jnu.encoding]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "UTF-8",
                    "key": "sun.jnu.encoding"
                  }
                },
                "[java.awt.printerjob]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "sun.print.PSPrinterJob",
                    "key": "java.awt.printerjob"
                  }
                }
              }
            },
            "BootClassPathSupported": {
              "description": "BootClassPathSupported",
              "value": true
            }
          }
        },
        {
          "name": "java.lang:type=Threading",
          "attributes": {
            "ThreadAllocatedMemorySupported": {
              "description": "ThreadAllocatedMemorySupported",
              "value": true
            },
            "ThreadContentionMonitoringEnabled": {
              "description": "ThreadContentionMonitoringEnabled",
              "value": false
            },
            "TotalStartedThreadCount": {
              "description": "TotalStartedThreadCount",
              "value": 13364
            },
            "CurrentThreadUserTime": {
              "description": "CurrentThreadUserTime",
              "value": 2590000000
            },
            "CurrentThreadCpuTimeSupported": {
              "description": "CurrentThreadCpuTimeSupported",
              "value": true
            },
            "AllThreadIds": {
              "description": "AllThreadIds",
              "value": [
                13375,
                13374,
                13373,
                13372,
                13371,
                13351,
                13344,
                13083,
                12690,
                12366,
                12045,
                11948,
                11943,
                11446,
                10690,
                10094,
                9554,
                8439,
                8421,
                8383,
                6989,
                110,
                109,
                108,
                107,
                105,
                103,
                102,
                100,
                99,
                94,
                92,
                90,
                89,
                88,
                87,
                86,
                83,
                82,
                76,
                75,
                73,
                71,
                70,
                69,
                68,
                67,
                65,
                64,
                63,
                62,
                61,
                14,
                60,
                59,
                53,
                52,
                51,
                49,
                48,
                47,
                46,
                45,
                44,
                43,
                42,
                27,
                19,
                26,
                25,
                24,
                23,
                22,
                21,
                20,
                40,
                35,
                38,
                37,
                36,
                34,
                33,
                32,
                31,
                30,
                29,
                28,
                18,
                15,
                13,
                12,
                5,
                3,
                2
              ]
            },
            "PeakThreadCount": {
              "description": "PeakThreadCount",
              "value": 196
            },
            "ThreadAllocatedMemoryEnabled": {
              "description": "ThreadAllocatedMemoryEnabled",
              "value": true
            },
            "CurrentThreadCpuTime": {
              "description": "CurrentThreadCpuTime",
              "value": 3533363519
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:type=Threading"
            },
            "ThreadCpuTimeSupported": {
              "description": "ThreadCpuTimeSupported",
              "value": true
            },
            "ThreadContentionMonitoringSupported": {
              "description": "ThreadContentionMonitoringSupported",
              "value": true
            },
            "ThreadCount": {
              "description": "ThreadCount",
              "value": 94
            },
            "ThreadCpuTimeEnabled": {
              "description": "ThreadCpuTimeEnabled",
              "value": true
            },
            "ObjectMonitorUsageSupported": {
              "description": "ObjectMonitorUsageSupported",
              "value": true
            },
            "SynchronizerUsageSupported": {
              "description": "SynchronizerUsageSupported",
              "value": true
            },
            "DaemonThreadCount": {
              "description": "DaemonThreadCount",
              "value": 65
            }
          }
        },
        {
          "name": "java.lang:type=OperatingSystem",
          "attributes": {
            "OpenFileDescriptorCount": {
              "description": "OpenFileDescriptorCount",
              "value": 952
            },
            "CommittedVirtualMemorySize": {
              "description": "CommittedVirtualMemorySize",
              "value": 13951463424
            },
            "FreePhysicalMemorySize": {
              "description": "FreePhysicalMemorySize",
              "value": 174215168
            },
            "SystemLoadAverage": {
              "description": "SystemLoadAverage",
              "value": 0
            },
            "Arch": {
              "description": "Arch",
              "value": "amd64"
            },
            "ProcessCpuLoad": {
              "description": "ProcessCpuLoad",
              "value": 0.5
            },
            "FreeSwapSpaceSize": {
              "description": "FreeSwapSpaceSize",
              "value": 0
            },
            "TotalPhysicalMemorySize": {
              "description": "TotalPhysicalMemorySize",
              "value": 15762874368
            },
            "Name": {
              "description": "Name",
              "value": "Linux"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:type=OperatingSystem"
            },
            "TotalSwapSpaceSize": {
              "description": "TotalSwapSpaceSize",
              "value": 0
            },
            "ProcessCpuTime": {
              "description": "ProcessCpuTime",
              "value": 93067700000000
            },
            "MaxFileDescriptorCount": {
              "description": "MaxFileDescriptorCount",
              "value": 60000
            },
            "SystemCpuLoad": {
              "description": "SystemCpuLoad",
              "value": 0.375
            },
            "Version": {
              "description": "Version",
              "value": "4.15.0-1017-gcp"
            },
            "AvailableProcessors": {
              "description": "AvailableProcessors",
              "value": 4
            }
          }
        },
        {
          "name": "java.lang:name=Code Cache,type=MemoryPool",
          "attributes": {
            "UsageThresholdCount": {
              "description": "UsageThresholdCount",
              "value": 0
            },
            "Usage": {
              "description": "Usage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 2555904,
                  "committed": 62193664,
                  "used": 61634880,
                  "max": 251658240
                }
              }
            },
            "MemoryManagerNames": {
              "description": "MemoryManagerNames",
              "value": [
                "CodeCacheManager"
              ]
            },
            "UsageThresholdSupported": {
              "description": "UsageThresholdSupported",
              "value": true
            },
            "UsageThreshold": {
              "description": "UsageThreshold",
              "value": 0
            },
            "CollectionUsageThresholdCount": {
              "description": "CollectionUsageThresholdCount",
              "value": null
            },
            "PeakUsage": {
              "description": "PeakUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 2555904,
                  "committed": 62193664,
                  "used": 61645632,
                  "max": 251658240
                }
              }
            },
            "UsageThresholdExceeded": {
              "description": "UsageThresholdExceeded",
              "value": false
            },
            "CollectionUsageThreshold": {
              "description": "CollectionUsageThreshold",
              "value": null
            },
            "Name": {
              "description": "Name",
              "value": "Code Cache"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=Code Cache,type=MemoryPool"
            },
            "Type": {
              "description": "Type",
              "value": "NON_HEAP"
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionUsageThresholdSupported": {
              "description": "CollectionUsageThresholdSupported",
              "value": false
            },
            "CollectionUsage": {
              "description": "CollectionUsage",
              "value": null
            },
            "CollectionUsageThresholdExceeded": {
              "description": "CollectionUsageThresholdExceeded",
              "value": null
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Primitive count",
          "attributes": {
            "NumberOfPropertyIdsInUse": {
              "description": "An estimation of the number of properties used in this Neo4j instance",
              "value": 17122493
            },
            "NumberOfRelationshipIdsInUse": {
              "description": "An estimation of the number of relationships used in this Neo4j instance",
              "value": 4265650
            },
            "NumberOfNodeIdsInUse": {
              "description": "An estimation of the number of nodes used in this Neo4j instance",
              "value": 9273334
            },
            "NumberOfRelationshipTypeIdsInUse": {
              "description": "The number of relationship types used in this Neo4j instance",
              "value": 66
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Memory Mapping",
          "attributes": {
            "MemoryPools": {
              "description": "Get information about each pool of memory mapped regions from store files with memory mapping enabled",
              "value": []
            }
          }
        },
        {
          "name": "java.nio:name=direct,type=BufferPool",
          "attributes": {
            "TotalCapacity": {
              "description": "TotalCapacity",
              "value": 7884160
            },
            "MemoryUsed": {
              "description": "MemoryUsed",
              "value": 7884161
            },
            "Count": {
              "description": "Count",
              "value": 63
            },
            "Name": {
              "description": "Name",
              "value": "direct"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.nio:name=direct,type=BufferPool"
            }
          }
        },
        {
          "name": "java.lang:type=Compilation",
          "attributes": {
            "TotalCompilationTime": {
              "description": "TotalCompilationTime",
              "value": 226618
            },
            "CompilationTimeMonitoringSupported": {
              "description": "CompilationTimeMonitoringSupported",
              "value": true
            },
            "Name": {
              "description": "Name",
              "value": "HotSpot 64-Bit Tiered Compilers"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:type=Compilation"
            }
          }
        },
        {
          "name": "java.lang:name=G1 Young Generation,type=GarbageCollector",
          "attributes": {
            "MemoryPoolNames": {
              "description": "MemoryPoolNames",
              "value": [
                "G1 Eden Space",
                "G1 Survivor Space"
              ]
            },
            "LastGcInfo": {
              "description": "LastGcInfo",
              "value": {
                "description": "CompositeType for GC info for G1 Young Generation",
                "properties": {
                  "duration": 52,
                  "memoryUsageBeforeGc": {
                    "[G1 Survivor Space]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 0,
                            "committed": 6291456,
                            "used": 6291456,
                            "max": -1
                          }
                        },
                        "key": "G1 Survivor Space"
                      }
                    },
                    "[Metaspace]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 0,
                            "committed": 107200512,
                            "used": 102475168,
                            "max": -1
                          }
                        },
                        "key": "Metaspace"
                      }
                    },
                    "[G1 Eden Space]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 15728640,
                            "committed": 1931476992,
                            "used": 1839202304,
                            "max": -1
                          }
                        },
                        "key": "G1 Eden Space"
                      }
                    },
                    "[Compressed Class Space]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 0,
                            "committed": 14983168,
                            "used": 14057984,
                            "max": 1073741824
                          }
                        },
                        "key": "Compressed Class Space"
                      }
                    },
                    "[G1 Old Gen]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 231735296,
                            "committed": 1981808640,
                            "used": 1600320048,
                            "max": 3942645760
                          }
                        },
                        "key": "G1 Old Gen"
                      }
                    },
                    "[Code Cache]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 2555904,
                            "committed": 61603840,
                            "used": 60983552,
                            "max": 251658240
                          }
                        },
                        "key": "Code Cache"
                      }
                    }
                  },
                  "GcThreadCount": 10,
                  "startTime": 4431985643,
                  "endTime": 4431985695,
                  "id": 5038,
                  "memoryUsageAfterGc": {
                    "[G1 Survivor Space]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 0,
                            "committed": 6291456,
                            "used": 6291456,
                            "max": -1
                          }
                        },
                        "key": "G1 Survivor Space"
                      }
                    },
                    "[Metaspace]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 0,
                            "committed": 107200512,
                            "used": 102475168,
                            "max": -1
                          }
                        },
                        "key": "Metaspace"
                      }
                    },
                    "[G1 Eden Space]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 15728640,
                            "committed": 1931476992,
                            "used": 0,
                            "max": -1
                          }
                        },
                        "key": "G1 Eden Space"
                      }
                    },
                    "[Compressed Class Space]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 0,
                            "committed": 14983168,
                            "used": 14057984,
                            "max": 1073741824
                          }
                        },
                        "key": "Compressed Class Space"
                      }
                    },
                    "[G1 Old Gen]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 231735296,
                            "committed": 1981808640,
                            "used": 1600330800,
                            "max": 3942645760
                          }
                        },
                        "key": "G1 Old Gen"
                      }
                    },
                    "[Code Cache]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 2555904,
                            "committed": 61603840,
                            "used": 60983552,
                            "max": 251658240
                          }
                        },
                        "key": "Code Cache"
                      }
                    }
                  }
                }
              }
            },
            "CollectionTime": {
              "description": "CollectionTime",
              "value": 264825
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionCount": {
              "description": "CollectionCount",
              "value": 5038
            },
            "Name": {
              "description": "Name",
              "value": "G1 Young Generation"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=G1 Young Generation,type=GarbageCollector"
            }
          }
        },
        {
          "name": "java.lang:name=CodeCacheManager,type=MemoryManager",
          "attributes": {
            "MemoryPoolNames": {
              "description": "MemoryPoolNames",
              "value": [
                "Code Cache"
              ]
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "Name": {
              "description": "Name",
              "value": "CodeCacheManager"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=CodeCacheManager,type=MemoryManager"
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Index sampler",
          "attributes": {}
        },
        {
          "name": "java.lang:name=G1 Old Gen,type=MemoryPool",
          "attributes": {
            "UsageThresholdCount": {
              "description": "UsageThresholdCount",
              "value": 0
            },
            "Usage": {
              "description": "Usage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 231735296,
                  "committed": 1981808640,
                  "used": 1600330800,
                  "max": 3942645760
                }
              }
            },
            "MemoryManagerNames": {
              "description": "MemoryManagerNames",
              "value": [
                "G1 Old Generation"
              ]
            },
            "UsageThresholdSupported": {
              "description": "UsageThresholdSupported",
              "value": true
            },
            "UsageThreshold": {
              "description": "UsageThreshold",
              "value": 0
            },
            "CollectionUsageThresholdCount": {
              "description": "CollectionUsageThresholdCount",
              "value": 0
            },
            "PeakUsage": {
              "description": "PeakUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 231735296,
                  "committed": 3707764736,
                  "used": 1600330800,
                  "max": 3942645760
                }
              }
            },
            "UsageThresholdExceeded": {
              "description": "UsageThresholdExceeded",
              "value": false
            },
            "CollectionUsageThreshold": {
              "description": "CollectionUsageThreshold",
              "value": 0
            },
            "Name": {
              "description": "Name",
              "value": "G1 Old Gen"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=G1 Old Gen,type=MemoryPool"
            },
            "Type": {
              "description": "Type",
              "value": "HEAP"
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionUsageThresholdSupported": {
              "description": "CollectionUsageThresholdSupported",
              "value": true
            },
            "CollectionUsage": {
              "description": "CollectionUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 231735296,
                  "committed": 0,
                  "used": 0,
                  "max": 3942645760
                }
              }
            },
            "CollectionUsageThresholdExceeded": {
              "description": "CollectionUsageThresholdExceeded",
              "value": false
            }
          }
        },
        {
          "name": "java.util.logging:type=Logging",
          "attributes": {
            "LoggerNames": {
              "description": "LoggerNames",
              "value": [
                "com.sun.jersey.server.impl.application.WebApplicationImpl",
                "javax.management.notification",
                "javax.management.timer",
                "com.sun.jersey.spi.inject.Errors",
                "com.sun.jersey.core.spi.component.ProviderServices",
                "com.sun.jersey.spi.container.ContainerResponse",
                "javax.management.modelmbean",
                "io.netty.channel.AbstractChannel",
                "com.sun.jersey.api.core.ResourceConfig",
                "com.sun.jersey.server.impl.application.ResourceMethodDispatcherFactory",
                "io.netty.util.concurrent.AbstractEventExecutor",
                "io.netty.util.NetUtil",
                "com.sun.jersey.server.impl.application.RootResourceUriRules",
                "io.netty.util.internal.PlatformDependent",
                "io.netty.util.internal.SystemPropertyUtil",
                "com.sun.jersey.server.impl.model.method.dispatch.MultipartFormDispatchProvider",
                "javax.management.mbeanserver",
                "io.netty.channel.socket.nio.NioServerSocketChannel",
                "io.netty.util.concurrent.SingleThreadEventExecutor",
                "io.netty.util.internal.PlatformDependent0",
                "com.sun.jersey.spi.service.ServiceFinder",
                "com.sun.jersey.core.impl.provider.entity.EntityHolderReader",
                "com.sun.jersey.server.impl.cdi.CDIComponentProviderFactoryInitializer",
                "global",
                "io.netty.util.ReferenceCountUtil",
                "com.sun.jersey.server.impl.resource.PerRequestFactory",
                "io.netty.channel.ChannelInitializer",
                "io.netty.util.internal.InternalThreadLocalMap",
                "com.sun.jersey.server.impl.managedbeans.ManagedBeanComponentProviderFactoryInitilizer",
                "io.netty.util.Recycler",
                "io.netty.util.concurrent.GlobalEventExecutor",
                "io.netty.channel.nio.NioEventLoop",
                "io.netty.channel.socket.nio.NioSocketChannel",
                "javax.management.snmp",
                "javax.management",
                "com.sun.jersey.server.impl.container.filter.FilterFactory",
                "io.netty.util.ResourceLeakDetector",
                "io.netty.util.concurrent.DefaultPromise",
                "io.netty.channel.MultithreadEventLoopGroup",
                "javax.management.misc",
                "io.netty.channel.AbstractChannelHandlerContext",
                "io.netty.buffer.ByteBufUtil",
                "com.sun.jersey.server.impl.wadl.WadlFactory",
                "io.netty.channel.DefaultChannelId",
                "javax.management.monitor",
                "io.netty.channel.DefaultChannelPipeline",
                "io.netty.buffer.PooledByteBufAllocator",
                "io.netty.bootstrap.Bootstrap",
                "io.netty.bootstrap.ServerBootstrap",
                "javax.management.mlet",
                "io.netty.util.concurrent.DefaultPromise.rejectedExecution",
                "com.github.benmanes.caffeine.cache.BoundedLocalCache",
                "com.github.benmanes.caffeine.cache.Caffeine",
                "com.sun.jersey.core.reflection.ReflectionHelper",
                "io.netty.resolver.AddressResolverGroup",
                "com.sun.jersey.server.impl.ejb.EJBComponentProviderFactoryInitilizer",
                "io.netty.util.ResourceLeakDetectorFactory",
                "com.sun.jersey.server.impl.modelapi.annotation.IntrospectionModeller",
                "javax.management.relation",
                "io.netty.util.internal.CleanerJava6",
                "com.sun.jersey.spi.container.servlet.WebComponent",
                "com.sun.jersey.server.impl.application.CloseableServiceFactory",
                "com.sun.jersey.core.impl.provider.xml.DocumentBuilderFactoryProvider",
                "io.netty.util.internal.MacAddressUtil",
                "javax.management.snmp.daemon",
                "io.netty.buffer.AbstractByteBuf",
                "io.netty.handler.stream.ChunkedWriteHandler",
                "io.netty.buffer.PoolThreadCache",
                "sun.net.www.protocol.http.HttpURLConnection",
                "io.netty.channel.nio.AbstractNioChannel",
                "com.sun.jersey.spi.container.ContainerRequest",
                "com.sun.jersey.core.spi.component.ProviderFactory",
                "io.netty.channel.ChannelOutboundBuffer",
                "com.sun.jersey.server.impl.monitoring.GlassFishMonitoringInitializer",
                ""
              ]
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.util.logging:type=Logging"
            }
          }
        },
        {
          "name": "java.lang:name=G1 Old Generation,type=GarbageCollector",
          "attributes": {
            "MemoryPoolNames": {
              "description": "MemoryPoolNames",
              "value": [
                "G1 Eden Space",
                "G1 Survivor Space",
                "G1 Old Gen"
              ]
            },
            "LastGcInfo": {
              "description": "LastGcInfo",
              "value": null
            },
            "CollectionTime": {
              "description": "CollectionTime",
              "value": 0
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionCount": {
              "description": "CollectionCount",
              "value": 0
            },
            "Name": {
              "description": "Name",
              "value": "G1 Old Generation"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=G1 Old Generation,type=GarbageCollector"
            }
          }
        },
        {
          "name": "java.lang:type=ClassLoading",
          "attributes": {
            "LoadedClassCount": {
              "description": "LoadedClassCount",
              "value": 19475
            },
            "UnloadedClassCount": {
              "description": "UnloadedClassCount",
              "value": 161
            },
            "Verbose": {
              "description": "Verbose",
              "value": false
            },
            "TotalLoadedClassCount": {
              "description": "TotalLoadedClassCount",
              "value": 19635
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:type=ClassLoading"
            }
          }
        },
        {
          "name": "java.lang:name=Metaspace Manager,type=MemoryManager",
          "attributes": {
            "MemoryPoolNames": {
              "description": "MemoryPoolNames",
              "value": [
                "Metaspace",
                "Compressed Class Space"
              ]
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "Name": {
              "description": "Name",
              "value": "Metaspace Manager"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=Metaspace Manager,type=MemoryManager"
            }
          }
        },
        {
          "name": "java.lang:name=G1 Survivor Space,type=MemoryPool",
          "attributes": {
            "UsageThresholdCount": {
              "description": "UsageThresholdCount",
              "value": null
            },
            "Usage": {
              "description": "Usage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 6291456,
                  "used": 6291456,
                  "max": -1
                }
              }
            },
            "MemoryManagerNames": {
              "description": "MemoryManagerNames",
              "value": [
                "G1 Old Generation",
                "G1 Young Generation"
              ]
            },
            "UsageThresholdSupported": {
              "description": "UsageThresholdSupported",
              "value": false
            },
            "UsageThreshold": {
              "description": "UsageThreshold",
              "value": null
            },
            "CollectionUsageThresholdCount": {
              "description": "CollectionUsageThresholdCount",
              "value": 0
            },
            "PeakUsage": {
              "description": "PeakUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 235929600,
                  "used": 235929600,
                  "max": -1
                }
              }
            },
            "UsageThresholdExceeded": {
              "description": "UsageThresholdExceeded",
              "value": null
            },
            "CollectionUsageThreshold": {
              "description": "CollectionUsageThreshold",
              "value": 0
            },
            "Name": {
              "description": "Name",
              "value": "G1 Survivor Space"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=G1 Survivor Space,type=MemoryPool"
            },
            "Type": {
              "description": "Type",
              "value": "HEAP"
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionUsageThresholdSupported": {
              "description": "CollectionUsageThresholdSupported",
              "value": true
            },
            "CollectionUsage": {
              "description": "CollectionUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 6291456,
                  "used": 6291456,
                  "max": -1
                }
              }
            },
            "CollectionUsageThresholdExceeded": {
              "description": "CollectionUsageThresholdExceeded",
              "value": false
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Transactions",
          "attributes": {
            "NumberOfRolledBackTransactions": {
              "description": "The total number of rolled back transactions",
              "value": 48
            },
            "NumberOfOpenTransactions": {
              "description": "The number of currently open transactions",
              "value": 1
            },
            "LastCommittedTxId": {
              "description": "The id of the latest committed transaction",
              "value": 541593
            },
            "NumberOfOpenedTransactions": {
              "description": "The total number started transactions",
              "value": 3771225
            },
            "PeakNumberOfConcurrentTransactions": {
              "description": "The highest number of transactions ever opened concurrently",
              "value": 102
            },
            "NumberOfCommittedTransactions": {
              "description": "The total number of committed transactions",
              "value": 3771176
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Store file sizes",
          "attributes": {
            "LogicalLogSize": {
              "description": "The amount of disk space used by the current Neo4j logical log, in bytes.",
              "value": 243711137
            },
            "StringStoreSize": {
              "description": "The amount of disk space used to store string properties, in bytes.",
              "value": 523640832
            },
            "ArrayStoreSize": {
              "description": "The amount of disk space used to store array properties, in bytes.",
              "value": 10982948864
            },
            "RelationshipStoreSize": {
              "description": "The amount of disk space used to store relationships, in bytes.",
              "value": 145035840
            },
            "PropertyStoreSize": {
              "description": "The amount of disk space used to store properties (excluding string values and array values), in bytes.",
              "value": 702032996
            },
            "NodeStoreSize": {
              "description": "The amount of disk space used to store nodes, in bytes.",
              "value": 139107150
            },
            "TotalStoreSize": {
              "description": "The total disk space used by this Neo4j instance, in bytes.",
              "value": 13129744400
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Diagnostics",
          "attributes": {
            "DiagnosticsProviders": {
              "description": "A list of the ids for the registered diagnostics providers.",
              "value": null
            }
          }
        },
        {
          "name": "org.neo4j.ServerManagement:restartServer=lifecycle",
          "attributes": {}
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Locking",
          "attributes": {
            "Locks": {
              "description": "Information about all locks held by Neo4j",
              "value": []
            },
            "NumberOfAvertedDeadlocks": {
              "description": "The number of lock sequences that would have lead to a deadlock situation that Neo4j has detected and averted (by throwing DeadlockDetectedException).",
              "value": -1
            }
          }
        },
        {
          "name": "java.lang:name=Metaspace,type=MemoryPool",
          "attributes": {
            "UsageThresholdCount": {
              "description": "UsageThresholdCount",
              "value": 0
            },
            "Usage": {
              "description": "Usage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 107462656,
                  "used": 102707896,
                  "max": -1
                }
              }
            },
            "MemoryManagerNames": {
              "description": "MemoryManagerNames",
              "value": [
                "Metaspace Manager"
              ]
            },
            "UsageThresholdSupported": {
              "description": "UsageThresholdSupported",
              "value": true
            },
            "UsageThreshold": {
              "description": "UsageThreshold",
              "value": 0
            },
            "CollectionUsageThresholdCount": {
              "description": "CollectionUsageThresholdCount",
              "value": null
            },
            "PeakUsage": {
              "description": "PeakUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 107462656,
                  "used": 102707896,
                  "max": -1
                }
              }
            },
            "UsageThresholdExceeded": {
              "description": "UsageThresholdExceeded",
              "value": false
            },
            "CollectionUsageThreshold": {
              "description": "CollectionUsageThreshold",
              "value": null
            },
            "Name": {
              "description": "Name",
              "value": "Metaspace"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=Metaspace,type=MemoryPool"
            },
            "Type": {
              "description": "Type",
              "value": "NON_HEAP"
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionUsageThresholdSupported": {
              "description": "CollectionUsageThresholdSupported",
              "value": false
            },
            "CollectionUsage": {
              "description": "CollectionUsage",
              "value": null
            },
            "CollectionUsageThresholdExceeded": {
              "description": "CollectionUsageThresholdExceeded",
              "value": null
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Reports",
          "attributes": {
            "EnvironmentVariables": {
              "description": "Returns a map if the current environment variables",
              "value": "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nNEO4J_CONF=/etc/neo4j\ndbms_directories_metrics=/var/lib/neo4j/metrics\ndbms_security_procedures_unrestricted=\"apoc.*,algo.*\"\ncausal_clustering_transaction_advertised_address=10.142.0.4:6000\ncausal_clustering_expected_core_cluster_size=3 3\nLOGNAME=neo4j\ndbms_backup_enabled=true true\ndbms_security_auth_enabled=true\nPWD=/\ndbms_logs_security_level=INFO INFO\ndbms_directories_logs=/var/log/neo4j\ndbms_connectors_default_listen_address=0.0.0.0 0.0.0.0\nSHELL=/bin/bash\ndbms_connector_https_listen_address=0.0.0.0:7473 0.0.0.0:7473\nha_pull_interval=10\ndbms_connector_bolt_tls_level=REQUIRED REQUIRED\nINTERNAL_IP_ADDR=10.142.0.4\ncausal_clustering_raft_advertised_address=10.142.0.4:7000\ndbms_ssl_policy_default_allow_key_generation=false\ndbms_connector_bolt_enabled=true true\ndbms_allow_upgrade=true\ndbms_ssl_policy_default_base_directory=/var/lib/neo4j/certificates\nINTERNAL_HOSTNAME=meetup-cluster-core-vm-2.c.testbed-187316.internal\ncausal_clustering_initial_discovery_members=meetup-cluster-core-vm-1:5000,meetup-cluster-core-vm-2:5000,meetup-cluster-core-vm-3:5000 meetup-cluster-core-vm-1:5000,meetup-cluster-core-vm-2:5000,meetup-cluster-core-vm-3:5000\nSHLVL=1\ndbms_connector_bolt_listen_address=0.0.0.0:7687 0.0.0.0:7687\ndbms_ssl_policy_default_client_auth=NONE\ndbms_connectors_default_advertised_address=node2.cluster.graph.center\ndbms_connector_https_enabled=true true\ndbms_connector_http_listen_address=0.0.0.0:7474 0.0.0.0:7474\ncausal_clustering_discovery_type=LIST LIST\nNEO4J_HOME=/var/lib/neo4j\ndbms_jvm_additional=-XX:+UseG1GC -XX:-OmitStackTraceInFastThrow -XX:+AlwaysPreTouch -XX:+UnlockExperimentalVMOptions -XX:+TrustFinalNonStaticFields -XX:+DisableExplicitGC -Djdk.tls.ephemeralDHKeySize=2048 -Djdk.tls.rejectClientInitiatedRenegotiation=true -Dunsupported.dbms.udc.source=gcloud-CORE\nbolt_ssl_policy=default\ndbms_logs_http_enabled=false false\nLANG=en_US.UTF-8\ndbms_windows_service_name=neo4j\ncausal_clustering_discovery_listen_address=0.0.0.0:5000 0.0.0.0:5000\ndbms_backup_address=localhost:6362 localhost:6362\ndbms_directories_data=/var/lib/neo4j/data\ndbms_connector_http_enabled=true true\nEXTERNAL_IP_ADDR=35.229.84.146\ndbms_directories_certificates=/var/lib/neo4j/certificates\nINSTANCE_API=http://metadata.google.internal/computeMetadata/v1/instance\ndbms_ssl_policy_default_private_key=/var/lib/neo4j/certificates/neo4j.key\ndbms_logs_gc_enabled=false false\ndbms_ssl_policy_default_revoked_dir=/var/lib/neo4j/certificates/revoked\nUSER=neo4j\ndbms_security_allow_csv_import_from_file_urls=true true\ndbms_ssl_policy_default_public_certificate=/var/lib/neo4j/certificates/neo4j.cert\ndbms_directories_run=/var/run/neo4j\ndbms_directories_import=/var/lib/neo4j/import\ndbms_directories_plugins=/var/lib/neo4j/plugins\ndbms_directories_lib=/usr/share/neo4j/lib\nHOME=/var/lib/neo4j\ndbms_mode=CORE CORE\n"
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Page cache",
          "attributes": {
            "Hits": {
              "description": "Number of page hits. How often requested data was found in memory.",
              "value": 53239052114
            },
            "FileUnmappings": {
              "description": "Number of files that have been unmapped from the page cache.",
              "value": 170
            },
            "FileMappings": {
              "description": "Number of files that have been mapped into the page cache.",
              "value": 269
            },
            "Faults": {
              "description": "Number of page faults. How often requested data was not found in memory and had to be loaded.",
              "value": 931851
            },
            "EvictionExceptions": {
              "description": "Number of exceptions caught during page eviction. This number should be zero, or at least not growing, in a healthy database. Otherwise it could indicate drive failure, storage space, or permission problems.",
              "value": 0
            },
            "BytesWritten": {
              "description": "Number of bytes written to durable storage.",
              "value": 2204912478
            },
            "Flushes": {
              "description": "Number of page flushes. How many dirty pages have been written to durable storage.",
              "value": 20097
            },
            "UsageRatio": {
              "description": "The percentage of used pages. Will return NaN if it cannot be determined.",
              "value": 0.999504621216127
            },
            "Unpins": {
              "description": "Number of page unpins. How many pages have been accessed and are not accessed anymore (monitoring must be enabled separately).",
              "value": 53239983696
            },
            "Evictions": {
              "description": "Number of page evictions. How many pages have been removed from memory to make room for other pages.",
              "value": 213565
            },
            "BytesRead": {
              "description": "Number of bytes read from durable storage.",
              "value": 5948771461
            },
            "Pins": {
              "description": "Number of page pins. How many pages have been accessed (monitoring must be enabled separately).",
              "value": 109703995011
            },
            "HitRatio": {
              "description": "Ratio of hits to the total number of lookups in the page cache",
              "value": 0.9999824971585151
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Store sizes",
          "attributes": {
            "CountStoreSize": {
              "description": "Disk space used to store counters, in bytes",
              "value": 12000
            },
            "LabelStoreSize": {
              "description": "Disk space used to store labels, in bytes",
              "value": 89908
            },
            "IndexStoreSize": {
              "description": "Disk space used to store all indices, in bytes",
              "value": 130460941
            },
            "StringStoreSize": {
              "description": "Disk space used to store string properties, in bytes.",
              "value": 523640841
            },
            "ArrayStoreSize": {
              "description": "Disk space used to store array properties, in bytes.",
              "value": 10982949705
            },
            "RelationshipStoreSize": {
              "description": "Disk space used to store relationships, in bytes.",
              "value": 145183871
            },
            "PropertyStoreSize": {
              "description": "Disk space used to store properties (excluding string values and array values), in bytes.",
              "value": 702123961
            },
            "TransactionLogsSize": {
              "description": "Disk space used by the transaction logs, in bytes.",
              "value": 505861828
            },
            "SchemaStoreSize": {
              "description": "Disk space used to store schemas (index and constrain declarations), in bytes",
              "value": 204809
            },
            "NodeStoreSize": {
              "description": "Disk space used to store nodes, in bytes.",
              "value": 139115976
            },
            "TotalStoreSize": {
              "description": "Disk space used by whole store, in bytes.",
              "value": 13129744400
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Configuration",
          "attributes": {
            "metrics.neo4j.server.enabled": {
              "description": "Enable reporting metrics about Server threading info.",
              "value": "true"
            },
            "unsupported.dbms.index.archive_failed": {
              "description": "Create an archive of an index before re-creating it if failing to load on startup.",
              "value": "false"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84-3d.z.max": {
              "description": "The maximum z value for the index extents for 3D wgs-84-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "1000000.0"
            },
            "metrics.graphite.server": {
              "description": "The hostname or IP address of the Graphite server",
              "value": ":2003"
            },
            "unsupported.ha.cluster_name": {
              "description": "The name of a cluster.",
              "value": "neo4j.ha"
            },
            "unsupported.dbms.db.spatial.crs.cartesian-3d.y.min": {
              "description": "The minimum y value for the index extents for 3D cartesian-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-1000000.0"
            },
            "unsupported.dbms.max_http_request_header_size": {
              "description": "Maximum request header size",
              "value": "20480"
            },
            "causal_clustering.discovery_resolution_timeout": {
              "description": "Configures the time after which we give up trying to resolve a DNS/SRV record into a list of initial discovery members.",
              "value": "300000ms"
            },
            "tools.consistency_checker.check_graph": {
              "description": "This setting is deprecated. See commandline arguments for neoj4-admin check-consistency instead. Perform checks between nodes, relationships, properties, types and tokens.",
              "value": "true"
            },
            "dbms.memory.heap.initial_size": {
              "description": "Initial heap size. By default it is calculated based on available system resources.",
              "value": null
            },
            "dbms.ssl.policy.<policyname>.base_directory": {
              "description": "The mandatory base directory for cryptographic objects of this policy. It is also possible to override each individual configuration with absolute paths.",
              "value": null
            },
            "dbms.security.auth_provider": {
              "description": "The authentication and authorization provider that contains both the users and roles. This can be one of the built-in `native` or `ldap` providers, or it can be an externally provided plugin, with a custom name prefixed by `plugin-`, i.e. `plugin-<AUTH_PROVIDER_NAME>`. ",
              "value": "native"
            },
            "dbms.checkpoint.interval.tx": {
              "description": "Configures the transaction interval between check-points. The database will not check-point more often  than this (unless check pointing is triggered by a different event), but might check-point less often than this interval, if performing a check-point takes longer time than the configured interval. A check-point is a point in the transaction logs, from which recovery would start from. Longer check-point intervals typically means that recovery will take longer to complete in case of a crash. On the other hand, a longer check-point interval can also reduce the I/O load that the database places on the system, as each check-point implies a flushing and forcing of all the store files.  The default is '100000' for a check-point every 100000 transactions.",
              "value": "100000"
            },
            "hazelcast.license_key": {
              "description": "Hazelcast license key",
              "value": null
            },
            "ha.join_timeout": {
              "description": "Timeout for joining a cluster. Defaults to ha.broadcast_timeout. Note that if the timeout expires during cluster formation, the operator may have to restart the instance or instances.",
              "value": "30000ms"
            },
            "ha.configuration_timeout": {
              "description": "Timeout for waiting for configuration from an existing cluster member during cluster join.",
              "value": "1000ms"
            },
            "dbms.memory.pagecache.swapper": {
              "description": "Specify which page swapper to use for doing paged IO. This is only used when integrating with proprietary storage technology.",
              "value": null
            },
            "causal_clustering.relationship_group_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP_GROUP IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "ha.host.coordination": {
              "description": "Host and port to bind the cluster management communication.",
              "value": "0.0.0.0:5001-5099"
            },
            "causal_clustering.minimum_core_cluster_size_at_formation": {
              "description": "Minimum number of Core machines in the cluster at formation. The expected_core_cluster size setting is used when bootstrapping the cluster on first formation. A cluster will not form without the configured amount of cores and this should in general be configured to the full and fixed amount. When using multi-clustering (configuring multiple distinct database names across core hosts), this setting is used to define the minimum size of *each* sub-cluster at formation.",
              "value": "3"
            },
            "dbms.query_cache_size": {
              "description": "The number of Cypher query execution plans that are cached.",
              "value": "1000"
            },
            "ha.allow_init_cluster": {
              "description": "Whether to allow this instance to create a cluster if unable to join.",
              "value": "true"
            },
            "bolt.ssl_policy": {
              "description": "Specify the SSL policy to use for the encrypted bolt connections.",
              "value": "default"
            },
            "metrics.jvm.memory.enabled": {
              "description": "Enable reporting metrics about the memory usage.",
              "value": "true"
            },
            "metrics.neo4j.pagecache.enabled": {
              "description": "Enable reporting metrics about the Neo4j page cache; page faults, evictions, flushes, exceptions, etc.",
              "value": "true"
            },
            "dbms.security.procedures.default_allowed": {
              "description": "The default role that can execute all procedures and user-defined functions that are not covered by the `dbms.security.procedures.roles` setting. If the `dbms.security.procedures.default_allowed` setting is the empty string (default), procedures will be executed according to the same security rules as normal Cypher statements.\n\nDeprecated: This will be replaced by dynamic configuration in the system graph in 4.0, including a migration step for the existing setting value.",
              "value": ""
            },
            "dbms.connector.bolt.listen_address": {
              "description": "Address the connector should bind to.",
              "value": "0.0.0.0:7687"
            },
            "unsupported.dbms.counts_store_rotation_timeout": {
              "description": "Maximum time to wait for active transaction completion when rotating counts store",
              "value": "600000ms"
            },
            "causal_clustering.cluster_allow_reads_on_followers": {
              "description": "Configure if the `dbms.cluster.routing.getServers()` procedure should include followers as read endpoints or return only read replicas. Note: if there are no read replicas in the cluster, followers are returned as read end points regardless the value of this setting. Defaults to true so that followers are available for read-only queries in a typical heterogeneous setup.",
              "value": "true"
            },
            "causal_clustering.raft_log_implementation": {
              "description": "RAFT log implementation",
              "value": "SEGMENTED"
            },
            "unsupported.dbms.uris.rest": {
              "description": "Configuration attribute",
              "value": "/db/data"
            },
            "causal_clustering.multi_dc_license": {
              "description": "Enable multi-data center features. Requires appropriate licensing.",
              "value": "false"
            },
            "dbms.db.timezone": {
              "description": "Database timezone. Among other things, this setting influences which timezone the logs and monitoring procedures use.",
              "value": "UTC"
            },
            "dbms.logs.debug.path": {
              "description": "Path to the debug log file.",
              "value": "/var/log/neo4j/debug.log"
            },
            "dbms.connector.bolt.enabled": {
              "description": "Enable this connector.",
              "value": "true"
            },
            "unsupported.dbms.logs.debug.debug_loggers": {
              "description": "Debug log contexts that should output debug level logging",
              "value": "[org.neo4j.diagnostics, org.neo4j.cluster.protocol, org.neo4j.kernel.ha]"
            },
            "dbms.logs.query.parameter_logging_enabled": {
              "description": "Log parameters for the executed queries being logged.",
              "value": "true"
            },
            "dbms.auto_index.nodes.enabled": {
              "description": "Controls the auto indexing feature for nodes. Setting it to `false` shuts it down, while `true` enables it by default for properties listed in the dbms.auto_index.nodes.keys setting.",
              "value": "false"
            },
            "unsupported.cypher.idp_solver_duration_threshold": {
              "description": "To improve IDP query planning time, we can restrict the internal planning loop duration, triggering more frequent compaction of candidate plans. The smaller the threshold the faster the planning, but the higher the risk of sub-optimal plans.",
              "value": "1000"
            },
            "unsupported.dbms.multi_threaded_schema_index_population_enabled": {
              "description": "Configuration attribute",
              "value": "true"
            },
            "dbms.relationship_grouping_threshold": {
              "description": "Relationship count threshold for considering a node to be dense",
              "value": "50"
            },
            "causal_clustering.load_balancing.shuffle": {
              "description": "Enables shuffling of the returned load balancing result.",
              "value": "true"
            },
            "unsupported.dbms.db.spatial.crs.cartesian.y.min": {
              "description": "The minimum y value for the index extents for 2D cartesian spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-1000000.0"
            },
            "dbms.logs.user.stdout_enabled": {
              "description": "Send user logs to the process stdout. If this is disabled then logs will instead be sent to the file _neo4j.log_ located in the logs directory. For location of the Logs directory, see <<file-locations>>.",
              "value": "true"
            },
            "dbms.security.ldap.authorization.group_membership_attributes": {
              "description": "A list of attribute names on a user object that contains groups to be used for mapping to roles when LDAP authorization is enabled.",
              "value": "[memberOf]"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84.y.min": {
              "description": "The minimum y value for the index extents for 2D wgs-84 spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-90.0"
            },
            "cypher.default_language_version": {
              "description": "Set this to specify the default parser (language version).",
              "value": "default"
            },
            "unsupported.dbms.uris.browser": {
              "description": "Configuration attribute",
              "value": "/browser/"
            },
            "causal_clustering.middleware.akka.failure_detector.threshold": {
              "description": "Akka cluster phi accrual failure detector. Defines the failure detector threshold. A low threshold is prone to generate many wrong suspicions but ensures a quick detection in the event of a real crash. Conversely, a high threshold generates fewer mistakes but needs more time to detect actual crashes.",
              "value": "10.0"
            },
            "causal_clustering.minimum_core_cluster_size_at_runtime": {
              "description": "Minimum number of Core machines required to be available at runtime. The consensus group size (core machines successfully voted into the Raft) can shrink and grow dynamically but bounded on the lower end at this number. The intention is in almost all cases for users to leave this setting alone. If you have 5 machines then you can survive failures down to 3 remaining, e.g. with 2 dead members. The three remaining can still vote another replacement member in successfully up to a total of 6 (2 of which are still dead) and then after this, one of the superfluous dead members will be immediately and automatically voted out (so you are left with 5 members in the consensus group, 1 of which is currently dead). Operationally you can now bring the last machine up by bringing in another replacement or repairing the dead one. When using multi-clustering (configuring multiple distinct database names across core hosts), this setting is used to define the minimum size of *each* sub-cluster at runtime.",
              "value": "3"
            },
            "dbms.logs.debug.rotation.keep_number": {
              "description": "Maximum number of history files for the debug log.",
              "value": "7"
            },
            "causal_clustering.raft_in_queue_size": {
              "description": "Maximum number of entries in the RAFT in-queue",
              "value": "1024"
            },
            "https.ssl_policy": {
              "description": "SSL policy name.",
              "value": "legacy"
            },
            "causal_clustering.neostore_block_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of NEOSTORE_BLOCK IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "dbms.lock.acquisition.timeout": {
              "description": "The maximum time interval within which lock should be acquired.",
              "value": "0ms"
            },
            "ha.broadcast_timeout": {
              "description": "Timeout for broadcasting values in cluster. Must consider end-to-end duration of Paxos algorithm. This value is the default value for the ha.join_timeout and ha.leave_timeout settings.",
              "value": "30000ms"
            },
            "unsupported.dbms.record_id_batch_size": {
              "description": "Specifies the size of id batches local to each transaction when committing. Committing a transaction which contains changes most often results in new data records being created. For each record a new id needs to be generated from an id generator. It's more efficient to allocate a batch of ids from the contended id generator, which the transaction holds and generates ids from while creating these new records. This setting specifies how big those batches are. Remaining ids are freed back to id generator on clean shutdown.",
              "value": "20"
            },
            "metrics.graphite.enabled": {
              "description": "Set to `true` to enable exporting metrics to Graphite.",
              "value": "false"
            },
            "dbms.security.ldap.authorization.user_search_base": {
              "description": "The name of the base object or named context to search for user objects when LDAP authorization is enabled. A common case is that this matches the last part of `dbms.security.ldap.authentication.user_dn_template`.",
              "value": "ou=users,dc=example,dc=com"
            },
            "ha.pull_batch_size": {
              "description": "Size of batches of transactions applied on slaves when pulling from master",
              "value": "100"
            },
            "causal_clustering.label_token_name_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of LABEL_TOKEN_NAME IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "metrics.cypher.replanning.enabled": {
              "description": "Enable reporting metrics about number of occurred replanning events.",
              "value": "true"
            },
            "dbms.logs.query.time_logging_enabled": {
              "description": "Log detailed time information for the executed queries being logged. Requires `dbms.track_query_cpu_time=true`",
              "value": "false"
            },
            "unsupported.dbms.id_generator_fast_rebuild_enabled": {
              "description": "Use a quick approach for rebuilding the ID generators. This give quicker recovery time, but will limit the ability to reuse the space of deleted entities.",
              "value": "true"
            },
            "unsupported.dbms.block_size.array_properties": {
              "description": "Specifies the block size for storing arrays. This parameter is only honored when the store is created, otherwise it is ignored. Also note that each block carries a ~10B of overhead so record size on disk will be slightly larger than the configured block size",
              "value": "120"
            },
            "dbms.import.csv.buffer_size": {
              "description": "The size of the internal buffer in bytes used by `LOAD CSV`. If the csv file contains huge fields this value may have to be increased.",
              "value": "2097152"
            },
            "dbms.ssl.policy.<policyname>.verify_hostname": {
              "description": "When true, this node will verify the hostname of every other instance it connects to by comparing the address it used to connect with it and the patterns described in the remote hosts public certificate Subject Alternative Names",
              "value": "false"
            },
            "causal_clustering.raft_membership_state_size": {
              "description": "The maximum file size before the membership state file is rotated (in unit of entries)",
              "value": "1000"
            },
            "causal_clustering.handshake_timeout": {
              "description": "Time out for protocol negotiation handshake",
              "value": "20000ms"
            },
            "causal_clustering.middleware.akka.sink-parallelism": {
              "description": "Parallelism level of dispatcher used for communication from Akka based cluster topology discovery ",
              "value": "2"
            },
            "dbms.security.procedures.whitelist": {
              "description": "A list of procedures (comma separated) that are to be loaded. The list may contain both fully-qualified procedure names, and partial names with the wildcard '*'. If this setting is left empty no procedures will be loaded.",
              "value": "*"
            },
            "dbms.security.auth_max_failed_attempts": {
              "description": "The maximum number of unsuccessful authentication attempts before imposing a user lock for the configured amount of time.The locked out user will not be able to log in until the lock period expires, even if correct credentials are provided. Setting this configuration option to values less than 3 is not recommended because it might make it easier for an attacker to brute force the password.",
              "value": "3"
            },
            "dbms.security.ldap.authorization.use_system_account": {
              "description": "Perform LDAP search for authorization info using a system account instead of the user's own account.\n\nIf this is set to `false` (default), the search for group membership will be performed directly after authentication using the LDAP context bound with the user's own account. The mapped roles will be cached for the duration of `dbms.security.auth_cache_ttl`, and then expire, requiring re-authentication. To avoid frequently having to re-authenticate sessions you may want to set a relatively long auth cache expiration time together with this option. NOTE: This option will only work if the users are permitted to search for their own group membership attributes in the directory.\n\nIf this is set to `true`, the search will be performed using a special system account user with read access to all the users in the directory. You need to specify the username and password using the settings `dbms.security.ldap.authorization.system_username` and `dbms.security.ldap.authorization.system_password` with this option. Note that this account only needs read access to the relevant parts of the LDAP directory and does not need to have access rights to Neo4j, or any other systems.",
              "value": "false"
            },
            "metrics.prometheus.endpoint": {
              "description": "The hostname and port to use as Prometheus endpoint",
              "value": "localhost:2004"
            },
            "dbms.security.property_level.blacklist": {
              "description": "An authorization mapping for property level access for roles. The map should be formatted as a semicolon separated list of key-value pairs, where the key is the role name and the value is a comma separated list of blacklisted properties. For example: role1=prop1;role2=prop2;role3=prop3,prop4,prop5\n\nYou could also use whitespaces and quotes around group names to make this mapping more readable, for example: dbms.security.property_level.blacklist=\\\n         \"role1\"      = ssn;    \\\n         \"role2\"      = ssn,income; \\\n\nDeprecated: This will be replaced by dynamic configuration in the system graph in 4.0, including a migration step for the existing setting value.",
              "value": null
            },
            "dbms.checkpoint.iops.limit": {
              "description": "Limit the number of IOs the background checkpoint process will consume per second. This setting is advisory, is ignored in Neo4j Community Edition, and is followed to best effort in Enterprise Edition. An IO is in this case a 8 KiB (mostly sequential) write. Limiting the write IO in this way will leave more bandwidth in the IO subsystem to service random-read IOs, which is important for the response time of queries when the database cannot fit entirely in memory. The only drawback of this setting is that longer checkpoint times may lead to slightly longer recovery times in case of a database or system crash. A lower number means lower IO pressure, and consequently longer checkpoint times. The configuration can also be commented out to remove the limitation entirely, and let the checkpointer flush data as fast as the hardware will go. Set this to -1 to disable the IOPS limit.",
              "value": "300"
            },
            "unsupported.dbms.memory.pagecache.warmup.profile.interval": {
              "description": "The profiling frequency for the page cache. Accurate profiles allow the page cache to do active warmup after a restart, reducing the mean time to performance. This feature available in Neo4j Enterprise Edition.",
              "value": "60000ms"
            },
            "dbms.transaction.timeout": {
              "description": "The maximum time interval of a transaction within which it should be completed.",
              "value": "0ms"
            },
            "dbms.logs.gc.options": {
              "description": "GC Logging Options",
              "value": "-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintPromotionFailure -XX:+PrintTenuringDistribution"
            },
            "causal_clustering.read_replica_time_to_live": {
              "description": "Time To Live before read replica is considered unavailable",
              "value": "60000ms"
            },
            "unsupported.dbms.transaction_start_timeout": {
              "description": "The maximum amount of time to wait for the database to become available, when starting a new transaction.",
              "value": "1000ms"
            },
            "causal_clustering.middleware.akka.failure_detector.min_std_deviation": {
              "description": "Akka cluster phi accrual failure detector. Minimum standard deviation to use for the normal distribution in AccrualFailureDetector. Too low standard deviation might result in too much sensitivity for sudden, but normal, deviations in heartbeat inter arrival times.",
              "value": "100ms"
            },
            "dbms.connector.bolt.tls_level": {
              "description": "Encryption level to require this connector to use.",
              "value": "REQUIRED"
            },
            "metrics.neo4j.tx.enabled": {
              "description": "Enable reporting metrics about transactions; number of transactions started, committed, etc.",
              "value": "true"
            },
            "unsupported.dbms.db.spatial.crs.cartesian-3d.x.min": {
              "description": "The minimum x value for the index extents for 3D cartesian-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-1000000.0"
            },
            "causal_clustering.cluster_binding_timeout": {
              "description": "Configures the time after which we give up trying to bind to a cluster formed of the other initial discovery members.",
              "value": "300000ms"
            },
            "dbms.security.ha_status_auth_enabled": {
              "description": "Require authorization for access to the HA status endpoints.",
              "value": "true"
            },
            "dbms.security.procedures.unrestricted": {
              "description": "A list of procedures and user defined functions (comma separated) that are allowed full access to the database. The list may contain both fully-qualified procedure names, and partial names with the wildcard '*'. Note that this enables these procedures to bypass security. Use with caution.",
              "value": "\"apoc.*,algo.*\""
            },
            "unsupported.dbms.uris.management": {
              "description": "Configuration attribute",
              "value": "/db/manage"
            },
            "ha.server_id": {
              "description": "Id for a cluster instance. Must be unique within the cluster.",
              "value": null
            },
            "causal_clustering.array_block_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of ARRAY_BLOCK IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "dbms.logs.query.rotation.size": {
              "description": "The file size in bytes at which the query log will auto-rotate. If set to zero then no rotation will occur. Accepts a binary suffix `k`, `m` or `g`.",
              "value": "20971520"
            },
            "unsupported.dbms.udc.first_delay": {
              "description": "Configuration attribute",
              "value": "600000"
            },
            "dbms.security.ldap.read_timeout": {
              "description": "The timeout for an LDAP read request (i.e. search). If the LDAP server does not respond within the given time the request will be aborted. A value of 0 means wait for a response indefinitely.",
              "value": "30000ms"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84.x.min": {
              "description": "The minimum x value for the index extents for 2D wgs-84 spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-180.0"
            },
            "unsupported.dbms.udc.interval": {
              "description": "Configuration attribute",
              "value": "86400000"
            },
            "unsupported.dbms.index.spatial.curve.max_bits": {
              "description": "The maximum number of bits to use for levels in the quad tree representing the spatial index. When creating the spatial index, we simulate a quad tree using a 2D (or 3D) to 1D mapping function. This requires that the extents of the index and the depth of the tree be defined in advance, so ensure the 2D to 1D mapping is deterministic and repeatable. This setting will define the maximum depth of any future spatial index created, calculated as max_bits / dimensions. For example 60 bits will define 30 levels in 2D and 20 levels in 3D. Existing indexes will not be changed, and need to be recreated if you wish to use the new value. For 2D indexes, a value of 30 is the largest supported. For 3D indexes 20 is the largest.",
              "value": "60"
            },
            "dbms.unmanaged_extension_classes": {
              "description": "Comma-separated list of <classname>=<mount point> for unmanaged extensions.",
              "value": "[]"
            },
            "causal_clustering.property_key_token_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of PROPERTY_KEY_TOKEN IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "32"
            },
            "dbms.auto_index.relationships.enabled": {
              "description": "Controls the auto indexing feature for relationships. Setting it to `false` shuts it down, while `true` enables it by default for properties listed in the dbms.auto_index.relationships.keys setting.",
              "value": "false"
            },
            "metrics.graphite.interval": {
              "description": "The reporting interval for Graphite. That is, how often to send updated metrics to Graphite.",
              "value": "3000ms"
            },
            "unsupported.dbms.bolt.outbound_buffer_throttle.low_watermark": {
              "description": "When the size (in bytes) of outbound network buffers, previously advertised as unwritable, gets below this value bolt channel will re-advertise itself as writable and blocked processing thread will resume execution.",
              "value": "131072"
            },
            "unsupported.tools.batch_inserter.batch_size": {
              "description": "Specifies number of operations that batch inserter will try to group into one batch before flushing data into underlying storage.",
              "value": "10000"
            },
            "causal_clustering.middleware.akka.failure_detector.acceptable_heartbeat_pause": {
              "description": "Akka cluster phi accrual failure detector. Number of potentially lost/delayed heartbeats that will be accepted before considering it to be an anomaly. This margin is important to be able to survive sudden, occasional, pauses in heartbeat arrivals, due to for example garbage collect or network drop.",
              "value": "4000ms"
            },
            "causal_clustering.leader_election_timeout": {
              "description": "The time limit within which a new leader election will occur if no messages are received.",
              "value": "7000ms"
            },
            "ha.pull_interval": {
              "description": "Interval of pulling updates from master.",
              "value": "10000ms"
            },
            "cypher.statistics_divergence_threshold": {
              "description": "The threshold when a plan is considered stale. If any of the underlying statistics used to create the plan have changed more than this value, the plan will be considered stale and will be replanned. Change is calculated as abs(a-b)/max(a,b). This means that a value of 0.75 requires the database to approximately quadruple in size. A value of 0 means replan as soon as possible, with the soonest being defined by the cypher.min_replan_interval which defaults to 10s. After this interval the divergence threshold will slowly start to decline, reaching 10% after about 7h. This will ensure that long running databases will still get query replanning on even modest changes, while not replanning frequently unless the changes are very large.",
              "value": "0.75"
            },
            "dbms.connector.https.enabled": {
              "description": "Enable this connector.",
              "value": "true"
            },
            "unsupported.dbms.query.snapshot": {
              "description": "Specifies if engine should run cypher query based on a snapshot of accessed data. Query will be restarted in case if concurrent modification of data will be detected.",
              "value": "false"
            },
            "unsupported.cypher.non_indexed_label_warning_threshold": {
              "description": "The threshold when a warning is generated if a label scan is done after a load csv where the label has no index",
              "value": "10000"
            },
            "unsupported.dbms.db.spatial.crs.cartesian.x.max": {
              "description": "The maximum x value for the index extents for 2D cartesian spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "1000000.0"
            },
            "causal_clustering.store_copy_max_retry_time_per_request": {
              "description": "Maximum retry time per request during store copy. Regular store files and indexes are downloaded in separate requests during store copy. This configures the maximum time failed requests are allowed to resend. ",
              "value": "1200000ms"
            },
            "unsupported.cypher.number_of_workers": {
              "description": "Number of threads to allocate to Cypher worker threads. If set to 0, two workers will be started for every physical core in the system.",
              "value": "0"
            },
            "unsupported.dbms.memory.pagecache.warmup.enable": {
              "description": "Page cache can be configured to perform usage sampling of loaded pages that can be used to construct active load profile. According to that profile pages can be reloaded on the restart, replication, etc. This setting allows disabling that behavior. This feature available in Neo4j Enterprise Edition.",
              "value": "true"
            },
            "dbms.active_database": {
              "description": "Name of the database to load",
              "value": "graph.db"
            },
            "dbms.tx_state.memory_allocation": {
              "description": "Defines whether memory for transaction state should be allocated on- or off-heap.",
              "value": "ON_HEAP"
            },
            "unsupported.dbms.block_size.strings": {
              "description": "Specifies the block size for storing strings. This parameter is only honored when the store is created, otherwise it is ignored. Note that each character in a string occupies two bytes, meaning that e.g a block size of 120 will hold a 60 character long string before overflowing into a second block. Also note that each block carries a ~10B of overhead so record size on disk will be slightly larger than the configured block size",
              "value": "120"
            },
            "unsupported.cypher.compiler_tracing": {
              "description": "Enable tracing of compilation in cypher.",
              "value": "false"
            },
            "dbms.connector.https.listen_address": {
              "description": "Address the connector should bind to.",
              "value": "0.0.0.0:7473"
            },
            "dbms.logs.timezone": {
              "description": "Database logs timezone.",
              "value": "UTC"
            },
            "metrics.csv.rotation.size": {
              "description": "The file size in bytes at which the csv files will auto-rotate. If set to zero then no rotation will occur. Accepts a binary suffix `k`, `m` or `g`.",
              "value": "10485760"
            },
            "causal_clustering.transaction_advertised_address": {
              "description": "Advertised hostname/IP address and port for the transaction shipping server.",
              "value": "10.142.0.4:6000"
            },
            "dbms.security.ldap.authorization.user_search_filter": {
              "description": "The LDAP search filter to search for a user principal when LDAP authorization is enabled. The filter should contain the placeholder token {0} which will be substituted for the user principal.",
              "value": "(&(objectClass=*)(uid={0}))"
            },
            "causal_clustering.id_alloc_state_size": {
              "description": "The maximum file size before the ID allocation file is rotated (in unit of entries)",
              "value": "1000"
            },
            "causal_clustering.relationship_type_token_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP_TYPE_TOKEN IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "32"
            },
            "dbms.auto_index.relationships.keys": {
              "description": "A list of property names (comma separated) that will be indexed by default. This applies to _relationships_ only.",
              "value": "[]"
            },
            "ha.leave_timeout": {
              "description": "Timeout for waiting for cluster leave to finish. Defaults to ha.broadcast_timeout.",
              "value": "30000ms"
            },
            "causal_clustering.in_flight_cache.max_bytes": {
              "description": "The maximum number of bytes in the in-flight cache.",
              "value": "2147483648"
            },
            "causal_clustering.transaction_listen_address": {
              "description": "Network interface and port for the transaction shipping server to listen on. Please note that it is also possible to run the backup client against this port so always limit access to it via the firewall and configure an ssl policy.",
              "value": "0.0.0.0:6000"
            },
            "unsupported.cypher.enable_morsel_runtime_trace": {
              "description": "Enable tracing of morsel runtime scheduler.",
              "value": "false"
            },
            "dbms.directories.plugins": {
              "description": "Location of the database plugin directory. Compiled Java JAR files that contain database procedures will be loaded if they are placed in this directory.",
              "value": "/var/lib/neo4j/plugins"
            },
            "metrics.jvm.buffers.enabled": {
              "description": "Enable reporting metrics about the buffer pools.",
              "value": "true"
            },
            "causal_clustering.server_groups": {
              "description": "A list of group names for the server used when configuring load balancing and replication policies.",
              "value": "[]"
            },
            "unsupported.dbms.wadl_generation_enabled": {
              "description": "Configuration attribute",
              "value": "false"
            },
            "causal_clustering.ssl_policy": {
              "description": "Name of the SSL policy to be used by the clustering, as defined under the dbms.ssl.policy.* settings. If no policy is configured then the communication will not be secured.",
              "value": null
            },
            "dbms.index.fulltext.default_analyzer": {
              "description": "The name of the analyzer that the fulltext indexes should use by default.",
              "value": "standard"
            },
            "dbms.backup.enabled": {
              "description": "Enable support for running online backups",
              "value": "true"
            },
            "causal_clustering.catchup_batch_size": {
              "description": "The maximum batch size when catching up (in unit of entries)",
              "value": "64"
            },
            "dbms.logs.query.rotation.keep_number": {
              "description": "Maximum number of history files for the query log.",
              "value": "7"
            },
            "causal_clustering.protocol_implementations.compression": {
              "description": "Network compression algorithms that this instance will allow in negotiation as a comma-separated list. Listed in descending order of preference for incoming connections. An empty list implies no compression. For outgoing connections this merely specifies the allowed set of algorithms and the preference of the  remote peer will be used for making the decision. Allowable values: [Gzip,Snappy,Snappy_validating,LZ4,LZ4_high_compression,LZ_validating,LZ4_high_compression_validating]",
              "value": "[]"
            },
            "dbms.read_only": {
              "description": "Only allow read operations from this Neo4j instance. This mode still requires write access to the directory for lock purposes.",
              "value": "false"
            },
            "dbms.logs.query.runtime_logging_enabled": {
              "description": "Logs which runtime that was used to run the query",
              "value": "false"
            },
            "dbms.tx_log.rotation.retention_policy": {
              "description": "Make Neo4j keep the logical transaction logs for being able to backup the database. Can be used for specifying the threshold to prune logical logs after. For example \"10 days\" will prune logical logs that only contains transactions older than 10 days from the current time, or \"100k txs\" will keep the 100k latest transactions and prune any older transactions.",
              "value": "7 days"
            },
            "dbms.security.auth_lock_time": {
              "description": "The amount of time user account should be locked after a configured number of unsuccessful authentication attempts. The locked out user will not be able to log in until the lock period expires, even if correct credentials are provided. Setting this configuration option to a low value is not recommended because it might make it easier for an attacker to brute force the password.",
              "value": "5000ms"
            },
            "dbms.logs.query.threshold": {
              "description": "If the execution of query takes more time than this threshold, the query is logged - provided query logging is enabled. Defaults to 0 seconds, that is all queries are logged.",
              "value": "0ms"
            },
            "dbms.ssl.policy.<policyname>.private_key_password": {
              "description": "The password for the private key.",
              "value": null
            },
            "dbms.windows_service_name": {
              "description": "Name of the Windows Service.",
              "value": "neo4j"
            },
            "dbms.security.procedures.roles": {
              "description": "This provides a finer level of control over which roles can execute procedures than the `dbms.security.procedures.default_allowed` setting. For example: `+dbms.security.procedures.roles=apoc.convert.*:reader;apoc.load.json*:writer;apoc.trigger.add:TriggerHappy+` will allow the role `reader` to execute all procedures in the `apoc.convert` namespace, the role `writer` to execute all procedures in the `apoc.load` namespace that starts with `json` and the role `TriggerHappy` to execute the specific procedure `apoc.trigger.add`. Procedures not matching any of these patterns will be subject to the `dbms.security.procedures.default_allowed` setting.\nDeprecated: This will be replaced by dynamic configuration in the system graph in 4.0, including a migration step for the existing setting value.",
              "value": ""
            },
            "ha.initial_hosts": {
              "description": "A comma-separated list of other members of the cluster to join.",
              "value": null
            },
            "dbms.security.plugin.authentication_enabled": {
              "description": "Enable authentication via plugin authentication providers.",
              "value": "false"
            },
            "dbms.ssl.policy.<policyname>.public_certificate": {
              "description": "X.509 certificate (chain) of this server in PEM format.",
              "value": "public.crt"
            },
            "dbms.allow_format_migration": {
              "description": "Whether to allow a store upgrade in case the current version of the database starts against an older store version. Setting this to `true` does not guarantee successful upgrade, it just allows an upgrade to be performed.",
              "value": "false"
            },
            "unsupported.dbms.udc.source": {
              "description": "Configuration attribute",
              "value": "maven"
            },
            "unsupported.dbms.db.spatial.crs.cartesian-3d.y.max": {
              "description": "The maximum y value for the index extents for 3D cartesian-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "1000000.0"
            },
            "dbms.threads.worker_count": {
              "description": "Number of Neo4j worker threads, your OS might enforce a lower limit than the maximum value specified here.",
              "value": "4"
            },
            "dbms.connector.http.enabled": {
              "description": "Enable this connector.",
              "value": "true"
            },
            "metrics.bolt.messages.enabled": {
              "description": "Enable reporting metrics about Bolt Protocol message processing.",
              "value": "true"
            },
            "dbms.mode": {
              "description": "Configure the operating mode of the database -- 'SINGLE' for stand-alone operation, 'HA' for operating as a member in an HA cluster, 'ARBITER' for a cluster member with no database in an HA cluster, 'CORE' for operating as a core member of a Causal Cluster, or 'READ_REPLICA' for operating as a read replica member of a Causal Cluster.",
              "value": "CORE"
            },
            "unsupported.dbms.executiontime_limit.time": {
              "description": "If execution time limiting is enabled in the database, this configures the maximum request execution time. Please use dbms.transaction.timeout instead.",
              "value": null
            },
            "dbms.checkpoint": {
              "description": "Configures the general policy for when check-points should occur. The default policy is the 'periodic' check-point policy, as specified by the 'dbms.checkpoint.interval.tx' and 'dbms.checkpoint.interval.time' settings. The Neo4j Enterprise Edition provides two alternative policies: The first is the 'continuous' check-point policy, which will ignore those settings and run the check-point process all the time. The second is the 'volumetric' check-point policy, which makes a best-effort at check-pointing often enough so that the database doesn't get too far behind on deleting old transaction logs in accordance with the 'dbms.tx_log.rotation.retention_policy' setting.",
              "value": "periodic"
            },
            "unsupported.dbms.security.module": {
              "description": "Configuration attribute",
              "value": "enterprise-security-module"
            },
            "dbms.index.fulltext.eventually_consistent": {
              "description": "Whether or not fulltext indexes should be eventually consistent by default or not.",
              "value": "false"
            },
            "dbms.logs.http.rotation.keep_number": {
              "description": "Number of HTTP logs to keep.",
              "value": "5"
            },
            "unsupported.dbms.console_module.engines": {
              "description": "Configuration attribute",
              "value": "[SHELL]"
            },
            "metrics.neo4j.enabled": {
              "description": "The default enablement value for all Neo4j specific support metrics. Set this to `false` to turn off all Neo4j specific metrics by default. The individual `metrics.neo4j.*` metrics can then be turned on selectively.",
              "value": "true"
            },
            "causal_clustering.raft_listen_address": {
              "description": "Network interface and port for the RAFT server to listen on.",
              "value": "0.0.0.0:7000"
            },
            "dbms.security.ldap.authentication.mechanism": {
              "description": "LDAP authentication mechanism. This is one of `simple` or a SASL mechanism supported by JNDI, for example `DIGEST-MD5`. `simple` is basic username and password authentication and SASL is used for more advanced mechanisms. See RFC 2251 LDAPv3 documentation for more details.",
              "value": "simple"
            },
            "ha.paxos_timeout": {
              "description": "Default value for all Paxos timeouts. This setting controls the default value for the ha.phase1_timeout, ha.phase2_timeout and ha.election_timeout settings. If it is not given a value it defaults to ha.default_timeout and will implicitly change if ha.default_timeout changes. This is an advanced parameter which should only be changed if specifically advised by Neo4j Professional Services.",
              "value": "5000ms"
            },
            "unsupported.dbms.db.spatial.crs.cartesian.y.max": {
              "description": "The maximum y value for the index extents for 2D cartesian spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "1000000.0"
            },
            "dbms.security.ldap.connection_timeout": {
              "description": "The timeout for establishing an LDAP connection. If a connection with the LDAP server cannot be established within the given time the attempt is aborted. A value of 0 means to use the network protocol's (i.e., TCP's) timeout value.",
              "value": "30000ms"
            },
            "dbms.record_format": {
              "description": "Database record format. Valid values: `standard`, `high_limit`. The `high_limit` formatis available for Enterprise Edition only. It is required if you have a graph that is larger than 34 billion nodes, 34 billion relationships, or 68 billion properties. A change of the record format is irreversible. Certain operations may suffer from a performance penalty of up to 10%, which is why this format is not switched on by default.",
              "value": ""
            },
            "unsupported.dbms.discoverable_bolt_routing_address": {
              "description": "Publicly discoverable bolt+routing:// URI to use for Neo4j Drivers wanting to access a cluster that this instance is a member of. Only applicable to causal clusters.",
              "value": ""
            },
            "ha.strict_initial_hosts": {
              "description": "Configuration attribute",
              "value": "false"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84-3d.x.max": {
              "description": "The maximum x value for the index extents for 3D wgs-84-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "180.0"
            },
            "ha.internal_role_switch_timeout": {
              "description": "Timeout for waiting for internal conditions during state switch, like for transactions to complete, before switching to master or slave.",
              "value": "10000ms"
            },
            "dbms.security.property_level.enabled": {
              "description": "Set to true to enable property level security.",
              "value": "false"
            },
            "causal_clustering.raft_log_rotation_size": {
              "description": "RAFT log rotation size",
              "value": "262144000"
            },
            "ha.data_chunk_size": {
              "description": "Max size of the data chunks that flows between master and slaves in HA. Bigger size may increase throughput, but may also be more sensitive to variations in bandwidth, whereas lower size increases tolerance for bandwidth variations.",
              "value": "2097152"
            },
            "causal_clustering.connect-randomly-to-server-group": {
              "description": "Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy. The connect-randomly-to-server-group strategy is used if the list of strategies (`causal_clustering.upstream_selection_strategy`) includes the value `connect-randomly-to-server-group`. ",
              "value": "[]"
            },
            "dbms.ssl.policy.<policyname>.revoked_dir": {
              "description": "Path to directory of CRLs (Certificate Revocation Lists) in PEM format.",
              "value": "revoked"
            },
            "causal_clustering.string_block_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of STRING_BLOCK IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "unsupported.dbms.directories.auth": {
              "description": "Configuration attribute",
              "value": "/var/lib/neo4j/data/dbms"
            },
            "dbms.directories.data": {
              "description": "Path of the data directory. You must not configure more than one Neo4j installation to use the same data directory.",
              "value": "/var/lib/neo4j/data"
            },
            "dbms.logs.gc.enabled": {
              "description": "Enable GC Logging",
              "value": "false"
            },
            "causal_clustering.kubernetes.address": {
              "description": "Address for Kubernetes API",
              "value": "kubernetes.default.svc:443"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84-3d.z.min": {
              "description": "The minimum z value for the index extents for 3D wgs-84-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-1000000.0"
            },
            "unsupported.dbms.edition": {
              "description": "Configuration attribute",
              "value": "enterprise"
            },
            "dbms.track_query_cpu_time": {
              "description": "Enables or disables tracking of how much time a query spends actively executing on the CPU. Calling `dbms.listQueries` will display the time. This can also be logged in the query log by using `log_queries_detailed_time_logging_enabled`.",
              "value": "false"
            },
            "dbms.ssl.policy.<policyname>.ciphers": {
              "description": "Restrict allowed ciphers.",
              "value": null
            },
            "unsupported.cypher.idp_solver_table_threshold": {
              "description": "To improve IDP query planning time, we can restrict the internal planning table size, triggering compaction of candidate plans. The smaller the threshold the faster the planning, but the higher the risk of sub-optimal plans.",
              "value": "128"
            },
            "dbms.logs.http.rotation.size": {
              "description": "Size of each HTTP log that is kept.",
              "value": "20971520"
            },
            "dbms.logs.user.rotation.keep_number": {
              "description": "Maximum number of history files for the user log.",
              "value": "7"
            },
            "causal_clustering.cluster_topology_refresh": {
              "description": "Time between scanning the cluster to refresh current server's view of topology",
              "value": "5000ms"
            },
            "dbms.security.log_successful_authentication": {
              "description": "Set to log successful authentication events to the security log. If this is set to `false` only failed authentication events will be logged, which could be useful if you find that the successful events spam the logs too much, and you do not require full auditing capability.",
              "value": "true"
            },
            "dbms.logs.query.enabled": {
              "description": "Log executed queries that take longer than the configured threshold, dbms.logs.query.threshold. Log entries are by default written to the file _query.log_ located in the Logs directory. For location of the Logs directory, see <<file-locations>>. This feature is available in the Neo4j Enterprise Edition.",
              "value": "false"
            },
            "causal_clustering.label_token_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of LABEL_TOKEN IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "32"
            },
            "dbms.security.ldap.referral": {
              "description": "The LDAP referral behavior when creating a connection. This is one of `follow`, `ignore` or `throw`.\n\n* `follow` automatically follows any referrals\n* `ignore` ignores any referrals\n* `throw` throws an exception, which will lead to authentication failure",
              "value": "follow"
            },
            "dbms.checkpoint.interval.time": {
              "description": "Configures the time interval between check-points. The database will not check-point more often than this (unless check pointing is triggered by a different event), but might check-point less often than this interval, if performing a check-point takes longer time than the configured interval. A check-point is a point in the transaction logs, from which recovery would start from. Longer check-point intervals typically means that recovery will take longer to complete in case of a crash. On the other hand, a longer check-point interval can also reduce the I/O load that the database places on the system, as each check-point implies a flushing and forcing of all the store files.",
              "value": "900000ms"
            },
            "dbms.security.http_access_control_allow_origin": {
              "description": "Value of the Access-Control-Allow-Origin header sent over any HTTP or HTTPS connector. This defaults to '*', which allows broadest compatibility. Note that any URI provided here limits HTTP/HTTPS access to that URI only.",
              "value": "*"
            },
            "unsupported.dbms.db.spatial.crs.cartesian-3d.z.min": {
              "description": "The minimum z value for the index extents for 3D cartesian-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-1000000.0"
            },
            "dbms.logs.user.path": {
              "description": "Path to the user log file.",
              "value": "/var/log/neo4j/neo4j.log"
            },
            "dbms.ssl.policy.<policyname>.allow_key_generation": {
              "description": "Allows the generation of a private key and associated self-signed certificate. Only performed when both objects cannot be found.",
              "value": "false"
            },
            "dbms.logs.user.rotation.delay": {
              "description": "Minimum time interval after last rotation of the user log before it may be rotated again.",
              "value": "300000ms"
            },
            "unsupported.cypher.task_wait": {
              "description": "Duration in milliseconds that parallel runtime waits on a task before trying another task",
              "value": "30000"
            },
            "metrics.neo4j.logrotation.enabled": {
              "description": "Enable reporting metrics about the Neo4j log rotation; when it occurs and how much time it takes to complete.",
              "value": "true"
            },
            "browser.post_connect_cmd": {
              "description": "Commands to be run when Neo4j Browser successfully connects to this server. Separate multiple commands with semi-colon.",
              "value": ""
            },
            "unsupported.vm_pause_monitor.stall_alert_threshold": {
              "description": "Configuration attribute",
              "value": "100ms"
            },
            "metrics.neo4j.causal_clustering.enabled": {
              "description": "Enable reporting metrics about Causal Clustering mode.",
              "value": "true"
            },
            "causal_clustering.node_labels_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of NODE_LABELS IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "dbms.security.ldap.authentication_enabled": {
              "description": "Enable authentication via settings configurable LDAP authentication provider.",
              "value": "false"
            },
            "dbms.logs.security.level": {
              "description": "Security log level threshold.",
              "value": "INFO"
            },
            "dbms.logs.http.enabled": {
              "description": "Enable HTTP request logging.",
              "value": "false"
            },
            "unsupported.dbms.db.spatial.crs.cartesian-3d.x.max": {
              "description": "The maximum x value for the index extents for 3D cartesian-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "1000000.0"
            },
            "dbms.tx_log.rotation.size": {
              "description": "Specifies at which file size the logical log will auto-rotate. Minimum accepted value is 1M. ",
              "value": "262144000"
            },
            "dbms.security.allow_csv_import_from_file_urls": {
              "description": "Determines if Cypher will allow using file URLs when loading data using `LOAD CSV`. Setting this value to `false` will cause Neo4j to fail `LOAD CSV` clauses that load data from the file system.",
              "value": "true"
            },
            "dbms.logs.http.path": {
              "description": "Path to HTTP request log.",
              "value": "/var/log/neo4j/http.log"
            },
            "dbms.security.ldap.use_starttls": {
              "description": "Use secure communication with the LDAP server using opportunistic TLS. First an initial insecure connection will be made with the LDAP server, and a STARTTLS command will be issued to negotiate an upgrade of the connection to TLS before initiating authentication.",
              "value": "false"
            },
            "dbms.import.csv.legacy_quote_escaping": {
              "description": "Selects whether to conform to the standard https://tools.ietf.org/html/rfc4180 for interpreting escaped quotation characters in CSV files loaded using `LOAD CSV`. Setting this to `false` will use the standard, interpreting repeated quotes '\"\"' as a single in-lined quote, while `true` will use the legacy convention originally supported in Neo4j 3.0 and 3.1, allowing a backslash to include quotes in-lined in fields.",
              "value": "true"
            },
            "unsupported.dbms.index.spatial.curve.extra_levels": {
              "description": "When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. This setting will cause the algorithm to search deeper, reducing false positives.",
              "value": "1"
            },
            "dbms.index.default_schema_provider": {
              "description": "Index provider to use for newly created schema indexes. An index provider may store different value types in separate physical indexes. lucene-1.0: Spatial and temporal value types are stored in native indexes, remaining value types in Lucene index. lucene+native-1.0: Spatial, temporal and number value types are stored in native indexes and remaining value types in Lucene index. lucene+native-2.0: Spatial, temporal, number and string value types are stored in native indexes and remaining value types in Lucene index. native-btree-1.0: All value types and arrays of all value types, even composite keys, are stored in one native index. A native index has faster updates, less heap and CPU usage compared to a Lucene index. A native index has these limitations: Index key (be it single or composite) size limit of 4039 bytes - transaction resulting in index key surpassing that will fail. Reduced performance of CONTAINS and ENDS WITH string index queries, compared to a Lucene index.",
              "value": "native-btree-1.0"
            },
            "cypher.forbid_shortestpath_common_nodes": {
              "description": "This setting is associated with performance optimization. The shortest path algorithm does not work when the start and end nodes are the same. With this setting set to `false` no path will be returned when that happens. The default value of `true` will instead throw an exception. This can happen if you perform a shortestPath search after a cartesian product that might have the same start and end nodes for some of the rows passed to shortestPath. If it is preferable to not experience this exception, and acceptable for results to be missing for those rows, then set this to `false`. If you cannot accept missing results, and really want the shortestPath between two common nodes, then re-write the query using a standard Cypher variable length pattern expression followed by ordering by path length and limiting to one result.",
              "value": "true"
            },
            "causal_clustering.load_balancing.config": {
              "description": "The configuration must be valid for the configured plugin and usually existsunder matching subkeys, e.g. ..config.server_policies.*This is just a top-level placeholder for the plugin-specific configuration.",
              "value": ""
            },
            "metrics.neo4j.checkpointing.enabled": {
              "description": "Enable reporting metrics about Neo4j check pointing; when it occurs and how much time it takes to complete.",
              "value": "true"
            },
            "causal_clustering.protocol_implementations.raft": {
              "description": "Raft protocol implementation versions that this instance will allow in negotiation as a comma-separated list. Order is not relevant: the greatest value will be preferred. An empty list will allow all supported versions",
              "value": "[]"
            },
            "causal_clustering.pull_interval": {
              "description": "Interval of pulling updates from cores.",
              "value": "1000ms"
            },
            "causal_clustering.state_machine_apply_max_batch_size": {
              "description": "The maximum number of operations to be batched during applications of operations in the state machines",
              "value": "16"
            },
            "unsupported.dbms.udc.reg": {
              "description": "Configuration attribute",
              "value": "unreg"
            },
            "ha.heartbeat_timeout": {
              "description": "How long to wait for heartbeats from other instances before marking them as suspects for failure. This value reflects considerations of network latency, expected duration of garbage collection pauses and other factors that can delay message sending and processing. Larger values will result in more stable masters but also will result in longer waits before a failover in case of master failure. This value should not be set to less than twice the ha.heartbeat_interval value otherwise there is a high risk of frequent master switches and possibly branched data occurrence.",
              "value": "40000ms"
            },
            "dbms.ids.reuse.types.override": {
              "description": "Specified names of id types (comma separated) that should be reused. Currently only 'node' and 'relationship' types are supported. ",
              "value": "[RELATIONSHIP, NODE]"
            },
            "dbms.ssl.policy.<policyname>.private_key": {
              "description": "Private PKCS#8 key in PEM format.",
              "value": "private.key"
            },
            "unsupported.dbms.memory.pagecache.pagesize": {
              "description": "Target size for pages of mapped memory. If set to 0, then a reasonable default is chosen, depending on the storage device used.",
              "value": "0"
            },
            "ha.branched_data_copying_strategy": {
              "description": "Strategy for how to order handling of branched data on slaves and copying of the store from the master. The default is copy_then_branch, which, when combined with the keep_last or keep_none branch handling strategies results in a safer branching strategy, as there is always a store present so store failure to copy a store (for example, because of network failure) does not leave the instance without a store.",
              "value": "branch_then_copy"
            },
            "metrics.neo4j.cluster.enabled": {
              "description": "Enable reporting metrics about HA cluster info.",
              "value": "true"
            },
            "causal_clustering.catch_up_client_inactivity_timeout": {
              "description": "The catch up protocol times out if the given duration elapses with no network activity. Every message received by the client from the server extends the time out duration.",
              "value": "600000ms"
            },
            "dbms.security.http_strict_transport_security": {
              "description": "Value of the HTTP Strict-Transport-Security (HSTS) response header. This header tells browsers that a webpage should only be accessed using HTTPS instead of HTTP. It is attached to every HTTPS response. Setting is not set by default so 'Strict-Transport-Security' header is not sent. Value is expected to contain dirictives like 'max-age', 'includeSubDomains' and 'preload'.",
              "value": null
            },
            "dbms.ssl.policy.<policyname>.client_auth": {
              "description": "Client authentication stance.",
              "value": "REQUIRE"
            },
            "dbms.memory.heap.max_size": {
              "description": "Maximum heap size. By default it is calculated based on available system resources.",
              "value": null
            },
            "dbms.connectors.default_listen_address": {
              "description": "Default network interface to listen for incoming connections. To listen for connections on all interfaces, use \"0.0.0.0\". To bind specific connectors to a specific network interfaces, specify the +listen_address+ properties for the specific connector.",
              "value": "0.0.0.0"
            },
            "metrics.csv.rotation.keep_number": {
              "description": "Maximum number of history files for the csv files.",
              "value": "7"
            },
            "dbms.udc.enabled": {
              "description": "Enable the UDC extension.",
              "value": "true"
            },
            "unsupported.dbms.directories.database": {
              "description": "Configuration attribute",
              "value": "/var/lib/neo4j/data/databases/graph.db"
            },
            "dbms.shutdown_transaction_end_timeout": {
              "description": "The maximum amount of time to wait for running transactions to complete before allowing initiated database shutdown to continue",
              "value": "10000ms"
            },
            "causal_clustering.kubernetes.token": {
              "description": "File location of token for Kubernetes API",
              "value": "/var/run/secrets/kubernetes.io/serviceaccount/token"
            },
            "dbms.auto_index.nodes.keys": {
              "description": "A list of property names (comma separated) that will be indexed by default. This applies to _nodes_ only.",
              "value": "[]"
            },
            "causal_clustering.replicated_lock_token_state_size": {
              "description": "The maximum file size before the replicated lock token state file is rotated (in unit of entries)",
              "value": "1000"
            },
            "dbms.logs.query.page_logging_enabled": {
              "description": "Log page hits and page faults for the executed queries being logged.",
              "value": "false"
            },
            "dbms.memory.pagecache.size": {
              "description": "The amount of memory to use for mapping the store files, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g'). If Neo4j is running on a dedicated server, then it is generally recommended to leave about 2-4 gigabytes for the operating system, give the JVM enough heap to hold all your transaction state and query context, and then leave the rest for the page cache. If no page cache memory is configured, then a heuristic setting is computed based on available system resources.",
              "value": null
            },
            "unsupported.dbms.db.spatial.crs.wgs-84-3d.y.max": {
              "description": "The maximum y value for the index extents for 3D wgs-84-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "90.0"
            },
            "dbms.filewatcher.enabled": {
              "description": "Allows the enabling or disabling of the file watcher service. This is an auxiliary service but should be left enabled in almost all cases.",
              "value": "true"
            },
            "unsupported.dbms.console_module.enabled": {
              "description": "Configuration attribute",
              "value": "true"
            },
            "unsupported.cypher.runtime": {
              "description": "Set this to specify the default runtime for the default language version.",
              "value": "default"
            },
            "causal_clustering.property_key_token_name_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of PROPERTY_KEY_TOKEN_NAME IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "dbms.security.ldap.authorization.system_username": {
              "description": "An LDAP system account username to use for authorization searches when `dbms.security.ldap.authorization.use_system_account` is `true`. Note that the `dbms.security.ldap.authentication.user_dn_template` will not be applied to this username, so you may have to specify a full DN.",
              "value": null
            },
            "dbms.security.http_authorization_classes": {
              "description": "Comma-separated list of custom security rules for Neo4j to use.",
              "value": "[]"
            },
            "causal_clustering.raft_in_queue_max_batch_bytes": {
              "description": "Largest batch processed by RAFT in bytes",
              "value": "8388608"
            },
            "causal_clustering.relationship_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "unsupported.dbms.schema.release_lock_while_building_constraint": {
              "description": "Whether or not to release the exclusive schema lock is while building uniqueness constraints index",
              "value": "false"
            },
            "causal_clustering.upstream_selection_strategy": {
              "description": "An ordered list in descending preference of the strategy which read replicas use to choose the upstream server from which to pull transactional updates.",
              "value": "[default]"
            },
            "ha.tx_push_factor": {
              "description": "The amount of slaves the master will ask to replicate a committed transaction. ",
              "value": "1"
            },
            "ha.max_acceptors": {
              "description": "Maximum number of servers to involve when agreeing to membership changes. In very large clusters, the probability of half the cluster failing is low, but protecting against any arbitrary half failing is expensive. Therefore you may wish to set this parameter to a value less than the cluster size.",
              "value": "21"
            },
            "dbms.logs.security.rotation.size": {
              "description": "Threshold for rotation of the security log.",
              "value": "20971520"
            },
            "causal_clustering.enable_pre_voting": {
              "description": "Enable pre-voting extension to the Raft protocol (this is breaking and must match between the core cluster members)",
              "value": "false"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84-3d.x.min": {
              "description": "The minimum x value for the index extents for 3D wgs-84-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-180.0"
            },
            "causal_clustering.raft_in_queue_max_bytes": {
              "description": "Maximum number of bytes in the RAFT in-queue",
              "value": "2147483648"
            },
            "browser.credential_timeout": {
              "description": "Configure the Neo4j Browser to time out logged in users after this idle period. Setting this to 0 indicates no limit.",
              "value": "0ms"
            },
            "causal_clustering.expected_core_cluster_size": {
              "description": "Expected number of Core machines in the cluster before startup",
              "value": "3"
            },
            "causal_clustering.in_flight_cache.max_entries": {
              "description": "The maximum number of entries in the in-flight cache.",
              "value": "1024"
            },
            "dbms.netty.ssl.provider": {
              "description": "Netty SSL provider",
              "value": "JDK"
            },
            "unsupported.dbms.security.ldap.authorization.connection_pooling": {
              "description": "Set to true if connection pooling should be used for authorization searches using the system account.",
              "value": "true"
            },
            "dbms.backup.ssl_policy": {
              "description": "Name of the SSL policy to be used by backup, as defined under the dbms.ssl.policy.* settings. If no policy is configured then the communication will not be secured.",
              "value": null
            },
            "unsupported.dbms.max_http_response_header_size": {
              "description": "Maximum response header size",
              "value": "20480"
            },
            "causal_clustering.middleware.akka.failure_detector.max_sample_size": {
              "description": "Akka cluster phi accrual failure detector. Number of the samples of inter-heartbeat arrival times to adaptively calculate the failure timeout for connections.",
              "value": "1000"
            },
            "dbms.logs.security.path": {
              "description": "Path to the security log file.",
              "value": "/var/log/neo4j/security.log"
            },
            "causal_clustering.middleware.akka.failure_detector.expected_response_after": {
              "description": "Akka cluster phi accrual failure detector. After the heartbeat request has been sent the first failure detection will start after this period, even though no heartbeat message has been received.",
              "value": "1000ms"
            },
            "dbms.backup.address": {
              "description": "Listening server for online backups. The protocol running varies depending on deployment. In a Causal Clustering environment this is the same protocol that runs on causal_clustering.transaction_listen_address. The port range is only respected in a HA or single instance deployment. In Causal Clustering a single port should be used",
              "value": "localhost:6362"
            },
            "unsupported.dbms.block_size.labels": {
              "description": "Specifies the block size for storing labels exceeding in-lined space in node record. This parameter is only honored when the store is created, otherwise it is ignored. Also note that each block carries a ~10B of overhead so record size on disk will be slightly larger than the configured block size",
              "value": "56"
            },
            "dbms.connector.http.listen_address": {
              "description": "Address the connector should bind to.",
              "value": "0.0.0.0:7474"
            },
            "unsupported.vm_pause_monitor.measurement_duration": {
              "description": "Configuration attribute",
              "value": "100ms"
            },
            "unsupported.dbms.directories.neo4j_home": {
              "description": "Root relative to which directory settings are resolved. This is set in code and should never be configured explicitly.",
              "value": "/var/lib/neo4j"
            },
            "unsupported.dbms.tracer": {
              "description": "Configuration attribute",
              "value": null
            },
            "metrics.jvm.gc.enabled": {
              "description": "Enable reporting metrics about the duration of garbage collections",
              "value": "true"
            },
            "unsupported.dbms.kernel_id": {
              "description": "An identifier that uniquely identifies this graph database instance within this JVM. Defaults to an auto-generated number depending on how many instance are started in this JVM.",
              "value": null
            },
            "unsupported.cypher.statistics_divergence_target": {
              "description": "Large databases might change slowly, and so to prevent queries from never being replanned the divergence threshold set by cypher.statistics_divergence_threshold is configured to shrink over time. The algorithm used to manage this change is set by unsupported.cypher.replan_algorithm and will cause the threshold to reach the value set here once the time since the previous replanning has reached unsupported.cypher.target_replan_interval. Setting this value to higher than the cypher.statistics_divergence_threshold will cause the threshold to not decay over time.",
              "value": "0.1"
            },
            "ha.phase2_timeout": {
              "description": "Timeout for Paxos phase 2. If it is not given a value it defaults to ha.paxos_timeout and will implicitly change if ha.paxos_timeout changes. This is an advanced parameter which should only be changed if specifically advised by Neo4j Professional Services. ",
              "value": "5000ms"
            },
            "dbms.index.fulltext.eventually_consistent_index_update_queue_max_length": {
              "description": "The eventually_consistent mode of the fulltext indexes works by queueing up index updates to be applied later in a background thread. This setting sets an upper bound on how many index updates are allowed to be in this queue at any one point in time. When it is reached, the commit process will slow down and wait for the index update applier thread to make some more room in the queue.",
              "value": "10000"
            },
            "causal_clustering.replication_retry_timeout_base": {
              "description": "The initial timeout until replication is retried. The timeout will increase exponentially.",
              "value": "10000ms"
            },
            "unsupported.dbms.security.tls_certificate_file": {
              "description": "Path to the X.509 public certificate to be used by Neo4j for TLS connections",
              "value": "/var/lib/neo4j/certificates/neo4j.cert"
            },
            "unsupported.dbms.index.spatial.curve.top_threshold": {
              "description": "When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. When traversing the tree to this depth, we can stop early based on when the search envelope overlaps the current tile by more than a certain threshold. The threshold is calculated based on depth, from the `top_threshold` at the top of the tree to the `bottom_threshold` at the depth calculated by the area comparison. Setting the top to 0.99 and the bottom to 0.5, for example would mean that if we reached the maximum depth, and the search area overlapped the current tile by more than 50%, we would stop traversing the tree, and return the 1D range for that entire tile to the search set. If the overlap is even higher, we would stop higher in the tree. This technique reduces the number of 1D ranges passed to the underlying space filling curve index. Setting this value to zero turns off this feature.",
              "value": "0.0"
            },
            "dbms.index_sampling.update_percentage": {
              "description": "Percentage of index updates of total index size required before sampling of a given index is triggered",
              "value": "5"
            },
            "dbms.security.causal_clustering_status_auth_enabled": {
              "description": "Require authorization for access to the Causal Clustering status endpoints.",
              "value": "true"
            },
            "dbms.logs.user.rotation.size": {
              "description": "Threshold for rotation of the user log. If set to 0 log rotation is disabled.",
              "value": "0"
            },
            "dbms.index_sampling.sample_size_limit": {
              "description": "Index sampling chunk size limit",
              "value": "8388608"
            },
            "dbms.security.ldap.authentication.cache_enabled": {
              "description": "Determines if the result of authentication via the LDAP server should be cached or not. Caching is used to limit the number of LDAP requests that have to be made over the network for users that have already been authenticated successfully. A user can be authenticated against an existing cache entry (instead of via an LDAP server) as long as it is alive (see `dbms.security.auth_cache_ttl`).\nAn important consequence of setting this to `true` is that Neo4j then needs to cache a hashed version of the credentials in order to perform credentials matching. This hashing is done using a cryptographic hash function together with a random salt. Preferably a conscious decision should be made if this method is considered acceptable by the security standards of the organization in which this Neo4j instance is deployed.",
              "value": "true"
            },
            "dbms.tx_state.off_heap.max_cacheable_block_size": {
              "description": "Defines the maximum size of an off-heap memory block that can be cached to speed up allocations for transaction state data. The value must be a power of 2.",
              "value": "524288"
            },
            "db.temporal.timezone": {
              "description": "Database timezone for temporal functions. All Time and DateTime values that are created without an explicit timezone will use this configured default timezone.",
              "value": "Z"
            },
            "causal_clustering.raft_messages_log_enable": {
              "description": "Enable or disable the dump of all network messages pertaining to the RAFT protocol",
              "value": "false"
            },
            "unsupported.dbms.tx_log.fail_on_corrupted_log_files": {
              "description": "If `true`, Neo4j will abort recovery if any errors are encountered in the logical log. Setting this to `false` will allow Neo4j to restore as much as possible from the corrupted log files and ignore the rest, but, the integrity of the database might be compromised.",
              "value": "true"
            },
            "unsupported.dbms.bolt.outbound_buffer_throttle.high_watermark": {
              "description": "When the size (in bytes) of outbound network buffers, used by bolt's network layer, grows beyond this value bolt channel will advertise itself as unwritable and will block related processing thread until it becomes writable again.",
              "value": "524288"
            },
            "tools.consistency_checker.check_indexes": {
              "description": "This setting is deprecated. See commandline arguments for neoj4-admin check-consistency instead. Perform checks on indexes. Checking indexes is more expensive than checking the native stores, so it may be useful to turn off this check for very large databases.",
              "value": "true"
            },
            "unsupported.dbms.index.spatial.curve.bottom_threshold": {
              "description": "When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. When traversing the tree to this depth, we can stop early based on when the search envelope overlaps the current tile by more than a certain threshold. The threshold is calculated based on depth, from the `top_threshold` at the top of the tree to the `bottom_threshold` at the depth calculated by the area comparison. Setting the top to 0.99 and the bottom to 0.5, for example would mean that if we reached the maximum depth, and the search area overlapped the current tile by more than 50%, we would stop traversing the tree, and return the 1D range for that entire tile to the search set. If the overlap is even higher, we would stop higher in the tree. This technique reduces the number of 1D ranges passed to the underlying space filling curve index. Setting this value to zero turns off this feature.",
              "value": "0.0"
            },
            "dbms.security.native.authorization_enabled": {
              "description": "Enable authorization via native authorization provider.",
              "value": "true"
            },
            "unsupported.dbms.enable_native_schema_index": {
              "description": "Configuration attribute",
              "value": "true"
            },
            "unsupported.dbms.report_configuration": {
              "description": "Print out the effective Neo4j configuration after startup.",
              "value": "false"
            },
            "dbms.directories.tx_log": {
              "description": "Location where Neo4j keeps the logical transaction logs.",
              "value": "/var/lib/neo4j/data/databases/graph.db"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84-3d.y.min": {
              "description": "The minimum y value for the index extents for 3D wgs-84-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-90.0"
            },
            "dbms.security.auth_enabled": {
              "description": "Enable auth requirement to access Neo4j.",
              "value": "true"
            },
            "dbms.security.native.authentication_enabled": {
              "description": "Enable authentication via native authentication provider.",
              "value": "true"
            },
            "ha.election_timeout": {
              "description": "Timeout for waiting for other members to finish a role election. Defaults to ha.paxos_timeout.",
              "value": "5000ms"
            },
            "dbms.index_sampling.background_enabled": {
              "description": "Enable or disable background index sampling",
              "value": "true"
            },
            "causal_clustering.raft_advertised_address": {
              "description": "Advertised hostname/IP address and port for the RAFT server.",
              "value": "10.142.0.4:7000"
            },
            "causal_clustering.user_defined_upstream_strategy": {
              "description": "Configuration of a user-defined upstream selection strategy. The user-defined strategy is used if the list of strategies (`causal_clustering.upstream_selection_strategy`) includes the value `user_defined`. ",
              "value": ""
            },
            "causal_clustering.middleware.akka.failure_detector.heartbeat_interval": {
              "description": "Akka cluster phi accrual failure detector. How often keep-alive heartbeat messages should be sent to each connection.",
              "value": "1000ms"
            },
            "unsupported.dbms.disconnected": {
              "description": "Disable all Bolt protocol connectors. This setting is deprecated and will be removed in 4.0. Please use connector configuration instead.",
              "value": "false"
            },
            "dbms.security.ldap.host": {
              "description": "URL of LDAP server to use for authentication and authorization. The format of the setting is `<protocol>://<hostname>:<port>`, where hostname is the only required field. The supported values for protocol are `ldap` (default) and `ldaps`. The default port for `ldap` is 389 and for `ldaps` 636. For example: `ldaps://ldap.example.com:10389`.\n\nYou may want to consider using STARTTLS (`dbms.security.ldap.use_starttls`) instead of LDAPS for secure connections, in which case the correct protocol is `ldap`.",
              "value": "localhost"
            },
            "unsupported.dbms.discoverable_bolt_address": {
              "description": "Publicly discoverable bolt:// URI to use for Neo4j Drivers wanting to access the data in this particular database instance. Normally this is the same as the advertised address configured for the connector, but this allows manually overriding that default.",
              "value": ""
            },
            "causal_clustering.in_flight_cache.type": {
              "description": "Type of in-flight cache.",
              "value": "CONSECUTIVE"
            },
            "causal_clustering.discovery_implementation": {
              "description": "Select the middleware used for cluster topology discovery",
              "value": "HAZELCAST"
            },
            "ha.learn_timeout": {
              "description": "Timeout for learning values. Defaults to ha.default_timeout.",
              "value": "5000ms"
            },
            "unsupported.dbms.db.spatial.crs.cartesian-3d.z.max": {
              "description": "The maximum z value for the index extents for 3D cartesian-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "1000000.0"
            },
            "causal_clustering.log_shipping_max_lag": {
              "description": "The maximum lag allowed before log shipping pauses (in unit of entries)",
              "value": "256"
            },
            "causal_clustering.middleware.akka.default-parallelism": {
              "description": "Parallelism level of default dispatcher used by Akka based cluster topology discovery, including cluster, replicator, and discovery actors",
              "value": "4"
            },
            "dbms.security.ldap.authentication.use_samaccountname": {
              "description": "Perform authentication with sAMAccountName instead of DN.\nUsing this setting requires `dbms.security.ldap.authorization.system_username` and dbms.security.ldap.authorization.system_password to be used since there is no way to log in through ldap directly with the sAMAccountName, instead the login name will be resolved to a DN that will be used to log in with.",
              "value": "false"
            },
            "unsupported.cypher.replan_algorithm": {
              "description": "Large databases might change slowly, and to prevent queries from never being replanned the divergence threshold set by cypher.statistics_divergence_threshold is configured to shrink over time using the algorithm set here. This will cause the threshold to reach the value set by unsupported.cypher.statistics_divergence_target once the time since the previous replanning has reached the value set in unsupported.cypher.target_replan_interval. Setting the algorithm to 'none' will cause the threshold to not decay over time.",
              "value": "default"
            },
            "dbms.logs.security.rotation.delay": {
              "description": "Minimum time interval after last rotation of the security log before it may be rotated again.",
              "value": "300000ms"
            },
            "causal_clustering.kubernetes.namespace": {
              "description": "File location of namespace for Kubernetes API",
              "value": "/var/run/secrets/kubernetes.io/serviceaccount/namespace"
            },
            "dbms.rest.transaction.idle_timeout": {
              "description": "Timeout for idle transactions in the REST endpoint.",
              "value": "60000ms"
            },
            "ha.slave_read_timeout": {
              "description": "How long a slave will wait for response from master before giving up.",
              "value": "20000ms"
            },
            "browser.retain_connection_credentials": {
              "description": "Configure the Neo4j Browser to store or not store user credentials.",
              "value": "true"
            },
            "unsupported.dbms.bolt.outbound_buffer_throttle.max_duration": {
              "description": "When the total time outbound network buffer based throttle lock is held exceeds this value, the corresponding bolt channel will be aborted. Setting this to 0 will disable this behaviour.",
              "value": "900000ms"
            },
            "unsupported.dbms.ephemeral": {
              "description": "Configuration attribute",
              "value": "false"
            },
            "causal_clustering.global_session_tracker_state_size": {
              "description": "The maximum file size before the global session tracker state file is rotated (in unit of entries)",
              "value": "1000"
            },
            "dbms.logs.query.allocation_logging_enabled": {
              "description": "Log allocated bytes for the executed queries being logged. The logged number is cumulative over the duration of the query, i.e. for memory intense or long-running queries the value may be larger than the current memory allocation. Requires `dbms.track_query_allocation=true`",
              "value": "false"
            },
            "causal_clustering.raft_log_reader_pool_size": {
              "description": "RAFT log reader pool size",
              "value": "8"
            },
            "causal_clustering.discovery_type": {
              "description": "Configure the discovery type used for cluster name resolution",
              "value": "LIST"
            },
            "causal_clustering.raft_term_state_size": {
              "description": "The maximum file size before the term state file is rotated (in unit of entries)",
              "value": "1000"
            },
            "tools.consistency_checker.check_label_scan_store": {
              "description": "This setting is deprecated. See commandline arguments for neoj4-admin check-consistency instead. Perform checks on the label scan store. Checking this store is more expensive than checking the native stores, so it may be useful to turn off this check for very large databases.",
              "value": "true"
            },
            "causal_clustering.raft_messages_log_path": {
              "description": "Path to RAFT messages log.",
              "value": "/var/log/neo4j/raft-messages.log"
            },
            "ha.slave_lock_timeout": {
              "description": "Timeout for taking remote (write) locks on slaves. Defaults to ha.slave_read_timeout.",
              "value": "20000ms"
            },
            "metrics.neo4j.network.enabled": {
              "description": "Enable reporting metrics about the network usage.",
              "value": "true"
            },
            "causal_clustering.discovery_resolution_retry_interval": {
              "description": "The polling interval when attempting to resolve initial_discovery_members from DNS and SRV records.",
              "value": "5000ms"
            },
            "unsupported.dbms.security.auth_store.location": {
              "description": "Configuration attribute",
              "value": null
            },
            "causal_clustering.kubernetes.ca_crt": {
              "description": "File location of CA certificate for Kubernetes API",
              "value": "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
            },
            "causal_clustering.property_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of PROPERTY IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "causal_clustering.refuse_to_be_leader": {
              "description": "Prevents the current instance from volunteering to become Raft leader. Defaults to false, and should only be used in exceptional circumstances by expert users. Using this can result in reduced availability for the cluster.",
              "value": "false"
            },
            "dbms.logs.gc.rotation.size": {
              "description": "Size of each GC log that is kept.",
              "value": "20971520"
            },
            "dbms.security.auth_cache_ttl": {
              "description": "The time to live (TTL) for cached authentication and authorization info when using external auth providers (LDAP or plugin). Setting the TTL to 0 will disable auth caching. Disabling caching while using the LDAP auth provider requires the use of an LDAP system account for resolving authorization information.",
              "value": "600000ms"
            },
            "unsupported.dbms.query.snapshot.retries": {
              "description": "Specifies number or retries that query engine will do to execute query based on stable accessed data snapshot before giving up.",
              "value": "5"
            },
            "causal_clustering.cluster_routing_ttl": {
              "description": "How long drivers should cache the data from the `dbms.cluster.routing.getServers()` procedure.",
              "value": "300000ms"
            },
            "dbms.procedures.kill_query_verbose": {
              "description": "Specifies whether or not dbms.killQueries produces a verbose output, with information about which queries were not found",
              "value": "true"
            },
            "unsupported.dbms.directories.databases.root": {
              "description": "Configuration attribute",
              "value": "/var/lib/neo4j/data/databases"
            },
            "dbms.security.auth_cache_use_ttl": {
              "description": "Enable time-based eviction of the authentication and authorization info cache for external auth providers (LDAP or plugin). Disabling this setting will make the cache live forever and only be evicted when `dbms.security.auth_cache_max_capacity` is exceeded.",
              "value": "true"
            },
            "unsupported.cypher.morsel_size": {
              "description": "The size of the morsels",
              "value": "10000"
            },
            "dbms.logs.gc.rotation.keep_number": {
              "description": "Number of GC logs to keep.",
              "value": "5"
            },
            "dbms.tx_state.max_off_heap_memory": {
              "description": "The maximum amount of off-heap memory that can be used to store transaction state data; it's a total amount of memory shared across all active transactions. Zero means 'unlimited'. Used when dbms.tx_state.memory_allocation is set to 'OFF_HEAP'.",
              "value": "2147483648"
            },
            "ha.max_channels_per_slave": {
              "description": "Maximum number of connections a slave can have to the master.",
              "value": "20"
            },
            "unsupported.ha.instance_name": {
              "description": "Configuration attribute",
              "value": null
            },
            "tools.consistency_checker.check_property_owners": {
              "description": "This setting is deprecated. See commandline arguments for neoj4-admin check-consistency instead. Perform optional additional checking on property ownership. This can detect a theoretical inconsistency where a property could be owned by multiple entities. However, the check is very expensive in time and memory, so it is skipped by default.",
              "value": "false"
            },
            "causal_clustering.kubernetes.label_selector": {
              "description": "LabelSelector for Kubernetes API",
              "value": null
            },
            "cypher.planner": {
              "description": "Set this to specify the default planner for the default language version.",
              "value": "default"
            },
            "causal_clustering.initial_discovery_members": {
              "description": "A comma-separated list of other members of the cluster to join.",
              "value": "[meetup-cluster-core-vm-1:5000, meetup-cluster-core-vm-2:5000, meetup-cluster-core-vm-3:5000]"
            },
            "dbms.tx_state.off_heap.block_cache_size": {
              "description": "Defines the size of the off-heap memory blocks cache. The cache will contain this number of blocks for each block size that is power of two. Thus, maximum amount of memory used by blocks cache can be calculated as 2 * dbms.tx_state.off_heap.max_cacheable_block_size * dbms.tx_state.off_heap.block_cache_size",
              "value": "128"
            },
            "dbms.config.strict_validation": {
              "description": "A strict configuration validation will prevent the database from starting up if unknown configuration options are specified in the neo4j settings namespace (such as dbms., ha., cypher., etc). This is currently false by default but will be true by default in 4.0.",
              "value": "false"
            },
            "unsupported.dbms.lock_manager": {
              "description": "Configuration attribute",
              "value": ""
            },
            "causal_clustering.kubernetes.service_port_name": {
              "description": "Service port name for discovery for Kubernetes API",
              "value": null
            },
            "causal_clustering.node_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of NODE IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "metrics.prefix": {
              "description": "A common prefix for the reported metrics field names. By default, this is either be 'neo4j', or a computed value based on the cluster and instance names, when running in an HA configuration.",
              "value": "neo4j"
            },
            "ha.default_timeout": {
              "description": "Default timeout used for clustering timeouts. Override  specific timeout settings with proper values if necessary. This value is the default value for the ha.heartbeat_interval, ha.paxos_timeout and ha.learn_timeout settings.",
              "value": "5000ms"
            },
            "dbms.security.ldap.authentication.user_dn_template": {
              "description": "LDAP user DN template. An LDAP object is referenced by its distinguished name (DN), and a user DN is an LDAP fully-qualified unique user identifier. This setting is used to generate an LDAP DN that conforms with the LDAP directory's schema from the user principal that is submitted with the authentication token when logging in. The special token {0} is a placeholder where the user principal will be substituted into the DN string.",
              "value": "uid={0},ou=users,dc=example,dc=com"
            },
            "causal_clustering.discovery_listen_address": {
              "description": "Host and port to bind the cluster member discovery management communication.",
              "value": "0.0.0.0:5000"
            },
            "causal_clustering.middleware.akka.failure_detector.monitored_by_nr_of_members": {
              "description": "Akka cluster phi accrual failure detector. Number of member nodes that each member will send heartbeat messages to, i.e. each node will be monitored by this number of other nodes.",
              "value": "5"
            },
            "dbms.transaction.bookmark_ready_timeout": {
              "description": "The maximum amount of time to wait for the database state represented by the bookmark.",
              "value": "30000ms"
            },
            "dbms.allow_upgrade": {
              "description": "Whether to allow an upgrade in case the current version of the database starts against an older version.",
              "value": "true"
            },
            "ha.role_switch_timeout": {
              "description": "Timeout for request threads waiting for instance to become master or slave.",
              "value": "120000ms"
            },
            "dbms.logs.query.path": {
              "description": "Path to the query log file.",
              "value": "/var/log/neo4j/query.log"
            },
            "dbms.security.ldap.authorization_enabled": {
              "description": "Enable authorization via settings configurable LDAP authorization provider.",
              "value": "false"
            },
            "dbms.connectors.default_advertised_address": {
              "description": "Default hostname or IP address the server uses to advertise itself to its connectors. To advertise a specific hostname or IP address for a specific connector, specify the +advertised_address+ property for the specific connector.",
              "value": "node2.cluster.graph.center"
            },
            "dbms.logs.debug.rotation.size": {
              "description": "Threshold for rotation of the debug log.",
              "value": "20971520"
            },
            "ha.branched_data_policy": {
              "description": "Policy for how to handle branched data.",
              "value": "keep_all"
            },
            "causal_clustering.last_applied_state_size": {
              "description": "The maximum file size before the storage file is rotated (in unit of entries)",
              "value": "1000"
            },
            "causal_clustering.relationship_type_token_name_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP_TYPE_TOKEN_NAME IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "causal_clustering.state_machine_flush_window_size": {
              "description": "The number of operations to be processed before the state machines flush to disk",
              "value": "4096"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84.y.max": {
              "description": "The maximum y value for the index extents for 2D wgs-84 spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "90.0"
            },
            "dbms.transaction.monitor.check.interval": {
              "description": "Configures the time interval between transaction monitor checks. Determines how often monitor thread will check transaction for timeout.",
              "value": "2000ms"
            },
            "causal_clustering.middleware_logging.level": {
              "description": "The level of middleware logging",
              "value": "500"
            },
            "unsupported.cypher.expression_engine": {
              "description": "Choose the expression engine. The default is to only compile expressions that are hot, if 'COMPILED' is chosen all expressions will be compiled directly and if 'INTERPRETED' is chosen expressions will never be compiled.",
              "value": "default"
            },
            "unsupported.cypher.target_replan_interval": {
              "description": "Large databases might change slowly, and to prevent queries from never being replanned the divergence threshold set by cypher.statistics_divergence_threshold is configured to shrink over time. The algorithm used to manage this change is set by unsupported.cypher.replan_algorithm and will cause the threshold to reach the value set by unsupported.cypher.statistics_divergence_target once the time since the previous replanning has reached the value set here. Setting this value to less than the value of cypher.min_replan_interval will cause the threshold to not decay over time.",
              "value": "25200000ms"
            },
            "causal_clustering.discovery_advertised_address": {
              "description": "Advertised cluster member discovery management communication.",
              "value": "node2.cluster.graph.center:5000"
            },
            "dbms.ssl.policy.<policyname>.trust_all": {
              "description": "Makes this policy trust all remote parties. Enabling this is not recommended and the trusted directory will be ignored.",
              "value": "false"
            },
            "causal_clustering.database": {
              "description": "The name of the database being hosted by this server instance. This configuration setting may be safely ignored unless deploying a multicluster. Instances may be allocated to distinct sub-clusters by assigning them distinct database names using this setting. For instance if you had 6 instances you could form 2 sub-clusters by assigning half the database name \"foo\", half the name \"bar\". The setting value must match exactly between members of the same sub-cluster. This setting is a one-off: once an instance is configured with a database name it may not be changed in future without using neo4j-admin unbind.",
              "value": "default"
            },
            "browser.remote_content_hostname_whitelist": {
              "description": "Whitelist of hosts for the Neo4j Browser to be allowed to fetch content from.",
              "value": "guides.neo4j.com,localhost"
            },
            "dbms.ssl.policy.<policyname>.tls_versions": {
              "description": "Restrict allowed TLS protocol versions.",
              "value": "[TLSv1.2]"
            },
            "causal_clustering.disable_middleware_logging": {
              "description": "Prevents the network middleware from dumping its own logs. Defaults to true.",
              "value": "true"
            },
            "unsupported.dbms.id_reuse_safe_zone": {
              "description": "Duration for which master will buffer ids and not reuse them to allow slaves read consistently. Slaves will also terminate transactions longer than this duration, when applying received transaction stream, to make sure they do not read potentially inconsistent/reused records.",
              "value": "3600000ms"
            },
            "dbms.directories.metrics": {
              "description": "The target location of the CSV files: a path to a directory wherein a CSV file per reported field  will be written.",
              "value": "/var/lib/neo4j/metrics"
            },
            "dbms.directories.logs": {
              "description": "Path of the logs directory.",
              "value": "/var/log/neo4j"
            },
            "causal_clustering.raft_vote_state_size": {
              "description": "The maximum file size before the vote state file is rotated (in unit of entries)",
              "value": "1000"
            },
            "unsupported.dbms.executiontime_limit.enabled": {
              "description": "Please use dbms.transaction.timeout instead.",
              "value": "false"
            },
            "cypher.lenient_create_relationship": {
              "description": "Set this to change the behavior for Cypher create relationship when the start or end node is missing. By default this fails the query and stops execution, but by setting this flag the create operation is simply not performed and execution continues.",
              "value": "false"
            },
            "causal_clustering.raft_log_pruning_frequency": {
              "description": "RAFT log pruning frequency",
              "value": "600000ms"
            },
            "dbms.security.ldap.authorization.system_password": {
              "description": "An LDAP system account password to use for authorization searches when `dbms.security.ldap.authorization.use_system_account` is `true`.",
              "value": null
            },
            "dbms.directories.import": {
              "description": "Sets the root directory for file URLs used with the Cypher `LOAD CSV` clause. This must be set to a single directory, restricting access to only those files within that directory and its subdirectories.",
              "value": "/var/lib/neo4j/import"
            },
            "causal_clustering.unknown_address_logging_throttle": {
              "description": "Throttle limit for logging unknown cluster member address",
              "value": "10000ms"
            },
            "dbms.security.ldap.authorization.group_to_role_mapping": {
              "description": "An authorization mapping from LDAP group names to Neo4j role names. The map should be formatted as a semicolon separated list of key-value pairs, where the key is the LDAP group name and the value is a comma separated list of corresponding role names. For example: group1=role1;group2=role2;group3=role3,role4,role5\n\nYou could also use whitespaces and quotes around group names to make this mapping more readable, for example: \n\n----\n+dbms.security.ldap.authorization.group_to_role_mapping+=\\\n         \"cn=Neo4j Read Only,cn=users,dc=example,dc=com\"      = reader;    \\\n         \"cn=Neo4j Read-Write,cn=users,dc=example,dc=com\"     = publisher; \\\n         \"cn=Neo4j Schema Manager,cn=users,dc=example,dc=com\" = architect; \\\n         \"cn=Neo4j Administrator,cn=users,dc=example,dc=com\"  = admin\n----\n\nDeprecated: This will be replaced by dynamic configuration in the system graph in 4.0, including a migration step for the existing setting value. +\n",
              "value": null
            },
            "metrics.jvm.threads.enabled": {
              "description": "Enable reporting metrics about the current number of threads running.",
              "value": "true"
            },
            "ha.slave_only": {
              "description": "Whether this instance should only participate as slave in cluster. If set to `true`, it will never be elected as master.",
              "value": "false"
            },
            "dbms.directories.run": {
              "description": "Path of the run directory. This directory holds Neo4j's runtime state, such as a pidfile when it is running in the background. The pidfile is created when starting neo4j and removed when stopping it. It may be placed on an in-memory filesystem such as tmpfs.",
              "value": "/var/run/neo4j"
            },
            "cypher.forbid_exhaustive_shortestpath": {
              "description": "This setting is associated with performance optimization. Set this to `true` in situations where it is preferable to have any queries using the 'shortestPath' function terminate as soon as possible with no answer, rather than potentially running for a long time attempting to find an answer (even if there is no path to be found). For most queries, the 'shortestPath' algorithm will return the correct answer very quickly. However there are some cases where it is possible that the fast bidirectional breadth-first search algorithm will find no results even if they exist. This can happen when the predicates in the `WHERE` clause applied to 'shortestPath' cannot be applied to each step of the traversal, and can only be applied to the entire path. When the query planner detects these special cases, it will plan to perform an exhaustive depth-first search if the fast algorithm finds no paths. However, the exhaustive search may be orders of magnitude slower than the fast algorithm. If it is critical that queries terminate as soon as possible, it is recommended that this option be set to `true`, which means that Neo4j will never consider using the exhaustive search for shortestPath queries. However, please note that if no paths are found, an error will be thrown at run time, which will need to be handled by the application.",
              "value": "false"
            },
            "dbms.directories.lib": {
              "description": "Path of the lib directory",
              "value": "/usr/share/neo4j/lib"
            },
            "unsupported.cypher.expression_recompilation_limit": {
              "description": "Number of uses before an expression is considered for compilation",
              "value": "1"
            },
            "unsupported.dbms.udc.host": {
              "description": "Configuration attribute",
              "value": "udc.neo4j.org"
            },
            "dbms.logs.security.rotation.keep_number": {
              "description": "Maximum number of history files for the security log.",
              "value": "7"
            },
            "ha.phase1_timeout": {
              "description": "Timeout for Paxos phase 1. If it is not given a value it defaults to ha.paxos_timeout and will implicitly change if ha.paxos_timeout changes. This is an advanced parameter which should only be changed if specifically advised by Neo4j Professional Services. ",
              "value": "5000ms"
            },
            "dbms.jvm.additional": {
              "description": "Additional JVM arguments. Argument order can be significant. To use a Java commercial feature, the argument to unlock commercial features must precede the argument to enable the specific feature in the config value string. For example, to use Flight Recorder, `-XX:+UnlockCommercialFeatures` must come before `-XX:+FlightRecorder`.",
              "value": "-Dunsupported.dbms.udc.source=gcloud-CORE"
            },
            "dbms.security.plugin.authorization_enabled": {
              "description": "Enable authorization via plugin authorization providers.",
              "value": "false"
            },
            "ha.tx_push_strategy": {
              "description": "Push strategy of a transaction to a slave during commit.",
              "value": "fixed_ascending"
            },
            "causal_clustering.join_catch_up_timeout": {
              "description": "Time out for a new member to catch up",
              "value": "600000ms"
            },
            "dbms.security.auth_cache_max_capacity": {
              "description": "The maximum capacity for authentication and authorization caches (respectively).",
              "value": "10000"
            },
            "unsupported.dbms.bolt.outbound_buffer_throttle": {
              "description": "Whether to apply network level outbound network buffer based throttling",
              "value": "true"
            },
            "unsupported.dbms.bolt.inbound_message_throttle.high_watermark": {
              "description": "When the number of queued inbound messages grows beyond this value, reading from underlying channel will be paused (no more inbound messages will be available) until queued number of messages drops below the configured low watermark value.",
              "value": "300"
            },
            "metrics.prometheus.enabled": {
              "description": "Set to `true` to enable the Prometheus endpoint",
              "value": "false"
            },
            "metrics.csv.interval": {
              "description": "The reporting interval for the CSV files. That is, how often new rows with numbers are appended to the CSV files.",
              "value": "3000ms"
            },
            "causal_clustering.protocol_implementations.catchup": {
              "description": "Catchup protocol implementation versions that this instance will allow in negotiation as a comma-separated list. Order is not relevant: the greatest value will be preferred. An empty list will allow all supported versions",
              "value": "[]"
            },
            "causal_clustering.raft_log_prune_strategy": {
              "description": "RAFT log pruning strategy",
              "value": "1g size"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84.x.max": {
              "description": "The maximum x value for the index extents for 2D wgs-84 spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "180.0"
            },
            "causal_clustering.read_replica_transaction_applier_batch_size": {
              "description": "Maximum transaction batch size for read replicas when applying transactions pulled from core servers.",
              "value": "64"
            },
            "cypher.hints_error": {
              "description": "Set this to specify the behavior when Cypher planner or runtime hints cannot be fulfilled. If true, then non-conformance will result in an error, otherwise only a warning is generated.",
              "value": "false"
            },
            "dbms.index_searcher_cache_size": {
              "description": "The maximum number of open Lucene index searchers.",
              "value": "2147483647"
            },
            "cypher.min_replan_interval": {
              "description": "The minimum time between possible cypher query replanning events. After this time, the graph statistics will be evaluated, and if they have changed by more than the value set by cypher.statistics_divergence_threshold, the query will be replanned. If the statistics have not changed sufficiently, the same interval will need to pass before the statistics will be evaluated again. Each time they are evaluated, the divergence threshold will be reduced slightly until it reaches 10% after 7h, so that even moderately changing databases will see query replanning after a sufficiently long time interval.",
              "value": "10000ms"
            },
            "dbms.security.auth_providers": {
              "description": "A list of security authentication and authorization providers containing the users and roles. They will be queried in the given order when login is attempted.",
              "value": "[native]"
            },
            "dbms.directories.certificates": {
              "description": "Directory for storing certificates to be used by Neo4j for TLS connections",
              "value": "/var/lib/neo4j/certificates"
            },
            "dbms.ssl.policy.<policyname>.trusted_dir": {
              "description": "Path to directory of X.509 certificates in PEM format for trusted parties.",
              "value": "trusted"
            },
            "metrics.csv.enabled": {
              "description": "Set to `true` to enable exporting metrics to CSV files",
              "value": "true"
            },
            "unsupported.dbms.security.tls_key_file": {
              "description": "Path to the X.509 private key to be used by Neo4j for TLS connections",
              "value": "/var/lib/neo4j/certificates/neo4j.key"
            },
            "dbms.label_index": {
              "description": "Backend to use for label --> nodes index",
              "value": "NATIVE"
            },
            "causal_clustering.store_copy_backoff_max_wait": {
              "description": "Maximum backoff timeout for store copy requests",
              "value": "5000ms"
            },
            "causal_clustering.schema_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of SCHEMA IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "metrics.neo4j.counts.enabled": {
              "description": "Enable reporting metrics about approximately how many entities are in the database; nodes, relationships, properties, etc.",
              "value": "true"
            },
            "metrics.enabled": {
              "description": "The default enablement value for all the supported metrics. Set this to `false` to turn off all metrics by default. The individual settings can then be used to selectively re-enable specific metrics.",
              "value": "true"
            },
            "causal_clustering.load_balancing.plugin": {
              "description": "The load balancing plugin to use.",
              "value": "server_policies"
            },
            "dbms.logs.debug.rotation.delay": {
              "description": "Minimum time interval after last rotation of the debug log before it may be rotated again.",
              "value": "300000ms"
            },
            "ha.heartbeat_interval": {
              "description": "How often heartbeat messages should be sent. Defaults to ha.default_timeout.",
              "value": "5000ms"
            },
            "dbms.logs.debug.level": {
              "description": "Debug log level threshold.",
              "value": "INFO"
            },
            "unsupported.dbms.bolt.inbound_message_throttle.low_watermark": {
              "description": "When the number of queued inbound messages, previously reached configured high watermark value, drops below this value, reading from underlying channel will be enabled and any pending messages will start queuing again.",
              "value": "100"
            },
            "browser.allow_outgoing_connections": {
              "description": "Configure the policy for outgoing Neo4j Browser connections.",
              "value": "true"
            },
            "dbms.track_query_allocation": {
              "description": "Enables or disables tracking of how many bytes are allocated by the execution of a query. Calling `dbms.listQueries` will display the time. This can also be logged in the query log by using `log_queries_allocation_logging_enabled`.",
              "value": "false"
            },
            "unsupported.dbms.jmx_module.enabled": {
              "description": "Configuration attribute",
              "value": "true"
            },
            "dbms.index_sampling.buffer_size": {
              "description": "Size of buffer used by index sampling. This configuration setting is no longer applicable as from Neo4j 3.0.3. Please use dbms.index_sampling.sample_size_limit instead.",
              "value": "67108864"
            },
            "causal_clustering.raft_in_queue_max_batch": {
              "description": "Largest batch processed by RAFT in number of entries",
              "value": "128"
            },
            "unsupported.cypher.plan_with_minimum_cardinality_estimates": {
              "description": "Enable using minimum cardinality estimates in the Cypher cost planner, so that cardinality estimates for logical plan operators are not allowed to go below certain thresholds even when the statistics give smaller numbers. This is especially useful for large import queries that write nodes and relationships into an empty or small database, where the generated query plan needs to be able to scale beyond the initial statistics. Otherwise, when this is disabled, the statistics on an empty or tiny database may lead the cost planner to for example pick a scan over an index seek, even when an index exists, because of a lower estimated cost.",
              "value": "true"
            },
            "causal_clustering.replication_retry_timeout_limit": {
              "description": "The upper limit for the exponentially incremented retry timeout.",
              "value": "60000ms"
            },
            "ha.host.data": {
              "description": "Hostname and port to bind the HA server.",
              "value": "0.0.0.0:6001-6011"
            },
            "unsupported.dbms.db.spatial.crs.cartesian.x.min": {
              "description": "The minimum x value for the index extents for 2D cartesian spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-1000000.0"
            }
          }
        },
        {
          "name": "java.lang:name=Compressed Class Space,type=MemoryPool",
          "attributes": {
            "UsageThresholdCount": {
              "description": "UsageThresholdCount",
              "value": 0
            },
            "Usage": {
              "description": "Usage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 14983168,
                  "used": 14083368,
                  "max": 1073741824
                }
              }
            },
            "MemoryManagerNames": {
              "description": "MemoryManagerNames",
              "value": [
                "Metaspace Manager"
              ]
            },
            "UsageThresholdSupported": {
              "description": "UsageThresholdSupported",
              "value": true
            },
            "UsageThreshold": {
              "description": "UsageThreshold",
              "value": 0
            },
            "CollectionUsageThresholdCount": {
              "description": "CollectionUsageThresholdCount",
              "value": null
            },
            "PeakUsage": {
              "description": "PeakUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 14983168,
                  "used": 14083368,
                  "max": 1073741824
                }
              }
            },
            "UsageThresholdExceeded": {
              "description": "UsageThresholdExceeded",
              "value": false
            },
            "CollectionUsageThreshold": {
              "description": "CollectionUsageThreshold",
              "value": null
            },
            "Name": {
              "description": "Name",
              "value": "Compressed Class Space"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=Compressed Class Space,type=MemoryPool"
            },
            "Type": {
              "description": "Type",
              "value": "NON_HEAP"
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionUsageThresholdSupported": {
              "description": "CollectionUsageThresholdSupported",
              "value": false
            },
            "CollectionUsage": {
              "description": "CollectionUsage",
              "value": null
            },
            "CollectionUsageThresholdExceeded": {
              "description": "CollectionUsageThresholdExceeded",
              "value": null
            }
          }
        },
        {
          "name": "java.lang:type=Memory",
          "attributes": {
            "ObjectPendingFinalizationCount": {
              "description": "ObjectPendingFinalizationCount",
              "value": 0
            },
            "Verbose": {
              "description": "Verbose",
              "value": false
            },
            "HeapMemoryUsage": {
              "description": "HeapMemoryUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 247463936,
                  "committed": 3919577088,
                  "used": 3317898288,
                  "max": 3942645760
                }
              }
            },
            "NonHeapMemoryUsage": {
              "description": "NonHeapMemoryUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 2555904,
                  "committed": 184639488,
                  "used": 178432160,
                  "max": -1
                }
              }
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:type=Memory"
            }
          }
        },
        {
          "name": "java.lang:name=G1 Eden Space,type=MemoryPool",
          "attributes": {
            "UsageThresholdCount": {
              "description": "UsageThresholdCount",
              "value": null
            },
            "Usage": {
              "description": "Usage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 15728640,
                  "committed": 1931476992,
                  "used": 1711276032,
                  "max": -1
                }
              }
            },
            "MemoryManagerNames": {
              "description": "MemoryManagerNames",
              "value": [
                "G1 Old Generation",
                "G1 Young Generation"
              ]
            },
            "UsageThresholdSupported": {
              "description": "UsageThresholdSupported",
              "value": false
            },
            "UsageThreshold": {
              "description": "UsageThreshold",
              "value": null
            },
            "CollectionUsageThresholdCount": {
              "description": "CollectionUsageThresholdCount",
              "value": 0
            },
            "PeakUsage": {
              "description": "PeakUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 15728640,
                  "committed": 2463105024,
                  "used": 2345664512,
                  "max": -1
                }
              }
            },
            "UsageThresholdExceeded": {
              "description": "UsageThresholdExceeded",
              "value": null
            },
            "CollectionUsageThreshold": {
              "description": "CollectionUsageThreshold",
              "value": 0
            },
            "Name": {
              "description": "Name",
              "value": "G1 Eden Space"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=G1 Eden Space,type=MemoryPool"
            },
            "Type": {
              "description": "Type",
              "value": "HEAP"
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionUsageThresholdSupported": {
              "description": "CollectionUsageThresholdSupported",
              "value": true
            },
            "CollectionUsage": {
              "description": "CollectionUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 15728640,
                  "committed": 1931476992,
                  "used": 0,
                  "max": -1
                }
              }
            },
            "CollectionUsageThresholdExceeded": {
              "description": "CollectionUsageThresholdExceeded",
              "value": false
            }
          }
        },
        {
          "name": "java.nio:name=mapped,type=BufferPool",
          "attributes": {
            "TotalCapacity": {
              "description": "TotalCapacity",
              "value": 0
            },
            "MemoryUsed": {
              "description": "MemoryUsed",
              "value": 0
            },
            "Count": {
              "description": "Count",
              "value": 0
            },
            "Name": {
              "description": "Name",
              "value": "mapped"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.nio:name=mapped,type=BufferPool"
            }
          }
        },
        {
          "name": "com.sun.management:type=DiagnosticCommand",
          "attributes": {}
        },
        {
          "name": "com.sun.management:type=HotSpotDiagnostic",
          "attributes": {
            "DiagnosticOptions": {
              "description": "DiagnosticOptions",
              "value": [
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "HeapDumpBeforeFullGC",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "HeapDumpAfterFullGC",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "HeapDumpOnOutOfMemoryError",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "HeapDumpPath",
                    "writeable": true,
                    "value": "",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "CMSAbortablePrecleanWaitMillis",
                    "writeable": true,
                    "value": "100",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "CMSWaitDuration",
                    "writeable": true,
                    "value": "2000",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "CMSTriggerInterval",
                    "writeable": true,
                    "value": "-1",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintGC",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintGCDetails",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintGCDateStamps",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintGCTimeStamps",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintGCID",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintClassHistogramBeforeFullGC",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintClassHistogramAfterFullGC",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintClassHistogram",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "MinHeapFreeRatio",
                    "writeable": true,
                    "value": "40",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "MaxHeapFreeRatio",
                    "writeable": true,
                    "value": "70",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintConcurrentLocks",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                }
              ]
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "com.sun.management:type=HotSpotDiagnostic"
            }
          }
        }
      ],
      "configuration": {
        "bolt.ssl_policy": "default",
        "browser.allow_outgoing_connections": "true",
        "browser.credential_timeout": "0ms",
        "browser.post_connect_cmd": "",
        "browser.remote_content_hostname_whitelist": "guides.neo4j.com,localhost",
        "browser.retain_connection_credentials": "true",
        "causal_clustering.array_block_id_allocation_size": "1024",
        "causal_clustering.catch_up_client_inactivity_timeout": "600000ms",
        "causal_clustering.catchup_batch_size": "64",
        "causal_clustering.cluster_allow_reads_on_followers": "true",
        "causal_clustering.cluster_routing_ttl": "300000ms",
        "causal_clustering.cluster_topology_refresh": "5000ms",
        "causal_clustering.connect-randomly-to-server-group": "[]",
        "causal_clustering.database": "default",
        "causal_clustering.disable_middleware_logging": "true",
        "causal_clustering.discovery_advertised_address": "node2.cluster.graph.center:5000",
        "causal_clustering.discovery_listen_address": "0.0.0.0:5000",
        "causal_clustering.discovery_type": "LIST",
        "causal_clustering.enable_pre_voting": "false",
        "causal_clustering.expected_core_cluster_size": "3",
        "causal_clustering.global_session_tracker_state_size": "1000",
        "causal_clustering.handshake_timeout": "20000ms",
        "causal_clustering.id_alloc_state_size": "1000",
        "causal_clustering.in_flight_cache.max_bytes": "2147483648",
        "causal_clustering.in_flight_cache.max_entries": "1024",
        "causal_clustering.in_flight_cache.type": "CONSECUTIVE",
        "causal_clustering.initial_discovery_members": "[meetup-cluster-core-vm-1:5000, meetup-cluster-core-vm-2:5000, meetup-cluster-core-vm-3:5000]",
        "causal_clustering.join_catch_up_timeout": "600000ms",
        "causal_clustering.kubernetes.address": "kubernetes.default.svc:443",
        "causal_clustering.kubernetes.ca_crt": "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt",
        "causal_clustering.kubernetes.label_selector": "",
        "causal_clustering.kubernetes.namespace": "/var/run/secrets/kubernetes.io/serviceaccount/namespace",
        "causal_clustering.kubernetes.service_port_name": "",
        "causal_clustering.kubernetes.token": "/var/run/secrets/kubernetes.io/serviceaccount/token",
        "causal_clustering.label_token_id_allocation_size": "32",
        "causal_clustering.label_token_name_id_allocation_size": "1024",
        "causal_clustering.last_applied_state_size": "1000",
        "causal_clustering.leader_election_timeout": "7000ms",
        "causal_clustering.load_balancing.config": "",
        "causal_clustering.load_balancing.plugin": "server_policies",
        "causal_clustering.load_balancing.shuffle": "true",
        "causal_clustering.log_shipping_max_lag": "256",
        "causal_clustering.middleware_logging.level": "500",
        "causal_clustering.minimum_core_cluster_size_at_formation": "3",
        "causal_clustering.minimum_core_cluster_size_at_runtime": "3",
        "causal_clustering.multi_dc_license": "false",
        "causal_clustering.neostore_block_id_allocation_size": "1024",
        "causal_clustering.node_id_allocation_size": "1024",
        "causal_clustering.node_labels_id_allocation_size": "1024",
        "causal_clustering.property_id_allocation_size": "1024",
        "causal_clustering.property_key_token_id_allocation_size": "32",
        "causal_clustering.property_key_token_name_id_allocation_size": "1024",
        "causal_clustering.protocol_implementations.catchup": "[]",
        "causal_clustering.protocol_implementations.compression": "[]",
        "causal_clustering.protocol_implementations.raft": "[]",
        "causal_clustering.pull_interval": "1000ms",
        "causal_clustering.raft_advertised_address": "10.142.0.4:7000",
        "causal_clustering.raft_in_queue_max_batch_bytes": "8388608",
        "causal_clustering.raft_in_queue_max_bytes": "2147483648",
        "causal_clustering.raft_listen_address": "0.0.0.0:7000",
        "causal_clustering.raft_log_implementation": "SEGMENTED",
        "causal_clustering.raft_log_prune_strategy": "1g size",
        "causal_clustering.raft_log_pruning_frequency": "600000ms",
        "causal_clustering.raft_log_reader_pool_size": "8",
        "causal_clustering.raft_log_rotation_size": "262144000",
        "causal_clustering.raft_membership_state_size": "1000",
        "causal_clustering.raft_term_state_size": "1000",
        "causal_clustering.raft_vote_state_size": "1000",
        "causal_clustering.read_replica_time_to_live": "60000ms",
        "causal_clustering.refuse_to_be_leader": "false",
        "causal_clustering.relationship_group_id_allocation_size": "1024",
        "causal_clustering.relationship_id_allocation_size": "1024",
        "causal_clustering.relationship_type_token_id_allocation_size": "32",
        "causal_clustering.relationship_type_token_name_id_allocation_size": "1024",
        "causal_clustering.replicated_lock_token_state_size": "1000",
        "causal_clustering.replication_retry_timeout_base": "10000ms",
        "causal_clustering.replication_retry_timeout_limit": "60000ms",
        "causal_clustering.schema_id_allocation_size": "1024",
        "causal_clustering.server_groups": "[]",
        "causal_clustering.ssl_policy": "",
        "causal_clustering.state_machine_apply_max_batch_size": "16",
        "causal_clustering.state_machine_flush_window_size": "4096",
        "causal_clustering.store_copy_max_retry_time_per_request": "1200000ms",
        "causal_clustering.string_block_id_allocation_size": "1024",
        "causal_clustering.transaction_advertised_address": "10.142.0.4:6000",
        "causal_clustering.transaction_listen_address": "0.0.0.0:6000",
        "causal_clustering.unknown_address_logging_throttle": "10000ms",
        "causal_clustering.upstream_selection_strategy": "[default]",
        "causal_clustering.user_defined_upstream_strategy": "",
        "cypher.default_language_version": "default",
        "cypher.forbid_exhaustive_shortestpath": "false",
        "cypher.forbid_shortestpath_common_nodes": "true",
        "cypher.hints_error": "false",
        "cypher.lenient_create_relationship": "false",
        "cypher.min_replan_interval": "10000ms",
        "cypher.planner": "default",
        "cypher.statistics_divergence_threshold": "0.75",
        "db.temporal.timezone": "Z",
        "dbms.active_database": "graph.db",
        "dbms.allow_format_migration": "false",
        "dbms.allow_upgrade": "true",
        "dbms.backup.address": "localhost:6362",
        "dbms.backup.enabled": "true",
        "dbms.backup.ssl_policy": "",
        "dbms.checkpoint": "periodic",
        "dbms.checkpoint.interval.time": "900000ms",
        "dbms.checkpoint.interval.tx": "100000",
        "dbms.checkpoint.iops.limit": "300",
        "dbms.config.strict_validation": "false",
        "dbms.connector.bolt.enabled": "true",
        "dbms.connector.bolt.listen_address": "0.0.0.0:7687",
        "dbms.connector.bolt.tls_level": "REQUIRED",
        "dbms.connector.http.enabled": "true",
        "dbms.connector.http.listen_address": "0.0.0.0:7474",
        "dbms.connector.https.enabled": "true",
        "dbms.connector.https.listen_address": "0.0.0.0:7473",
        "dbms.connectors.default_advertised_address": "node2.cluster.graph.center",
        "dbms.connectors.default_listen_address": "0.0.0.0",
        "dbms.db.timezone": "UTC",
        "dbms.directories.certificates": "/var/lib/neo4j/certificates",
        "dbms.directories.data": "/var/lib/neo4j/data",
        "dbms.directories.import": "/var/lib/neo4j/import",
        "dbms.directories.lib": "/usr/share/neo4j/lib",
        "dbms.directories.logs": "/var/log/neo4j",
        "dbms.directories.metrics": "/var/lib/neo4j/metrics",
        "dbms.directories.plugins": "/var/lib/neo4j/plugins",
        "dbms.directories.run": "/var/run/neo4j",
        "dbms.directories.tx_log": "/var/lib/neo4j/data/databases/graph.db",
        "dbms.filewatcher.enabled": "true",
        "dbms.ids.reuse.types.override": "[RELATIONSHIP, NODE]",
        "dbms.import.csv.buffer_size": "2097152",
        "dbms.import.csv.legacy_quote_escaping": "true",
        "dbms.index.default_schema_provider": "native-btree-1.0",
        "dbms.index.fulltext.default_analyzer": "standard",
        "dbms.index.fulltext.eventually_consistent": "false",
        "dbms.index.fulltext.eventually_consistent_index_update_queue_max_length": "10000",
        "dbms.index_sampling.background_enabled": "true",
        "dbms.index_sampling.buffer_size": "67108864",
        "dbms.index_sampling.sample_size_limit": "8388608",
        "dbms.index_sampling.update_percentage": "5",
        "dbms.index_searcher_cache_size": "2147483647",
        "dbms.jvm.additional": "-Dunsupported.dbms.udc.source=gcloud-CORE",
        "dbms.lock.acquisition.timeout": "0ms",
        "dbms.logs.debug.level": "INFO",
        "dbms.logs.debug.path": "/var/log/neo4j/debug.log",
        "dbms.logs.debug.rotation.delay": "300000ms",
        "dbms.logs.debug.rotation.keep_number": "7",
        "dbms.logs.debug.rotation.size": "20971520",
        "dbms.logs.gc.enabled": "false",
        "dbms.logs.gc.options": "-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintPromotionFailure -XX:+PrintTenuringDistribution",
        "dbms.logs.gc.rotation.keep_number": "5",
        "dbms.logs.gc.rotation.size": "20971520",
        "dbms.logs.http.enabled": "false",
        "dbms.logs.http.path": "/var/log/neo4j/http.log",
        "dbms.logs.http.rotation.keep_number": "5",
        "dbms.logs.http.rotation.size": "20971520",
        "dbms.logs.query.allocation_logging_enabled": "false",
        "dbms.logs.query.enabled": "false",
        "dbms.logs.query.page_logging_enabled": "false",
        "dbms.logs.query.parameter_logging_enabled": "true",
        "dbms.logs.query.path": "/var/log/neo4j/query.log",
        "dbms.logs.query.rotation.keep_number": "7",
        "dbms.logs.query.rotation.size": "20971520",
        "dbms.logs.query.runtime_logging_enabled": "false",
        "dbms.logs.query.threshold": "0ms",
        "dbms.logs.query.time_logging_enabled": "false",
        "dbms.logs.security.level": "INFO",
        "dbms.logs.security.path": "/var/log/neo4j/security.log",
        "dbms.logs.security.rotation.delay": "300000ms",
        "dbms.logs.security.rotation.keep_number": "7",
        "dbms.logs.security.rotation.size": "20971520",
        "dbms.logs.timezone": "UTC",
        "dbms.logs.user.path": "/var/log/neo4j/neo4j.log",
        "dbms.logs.user.rotation.delay": "300000ms",
        "dbms.logs.user.rotation.keep_number": "7",
        "dbms.logs.user.rotation.size": "0",
        "dbms.logs.user.stdout_enabled": "true",
        "dbms.memory.heap.initial_size": "",
        "dbms.memory.heap.max_size": "",
        "dbms.memory.pagecache.size": "",
        "dbms.memory.pagecache.swapper": "",
        "dbms.mode": "CORE",
        "dbms.netty.ssl.provider": "JDK",
        "dbms.procedures.kill_query_verbose": "true",
        "dbms.query_cache_size": "1000",
        "dbms.read_only": "false",
        "dbms.record_format": "",
        "dbms.relationship_grouping_threshold": "50",
        "dbms.rest.transaction.idle_timeout": "60000ms",
        "dbms.security.allow_csv_import_from_file_urls": "true",
        "dbms.security.auth_cache_max_capacity": "10000",
        "dbms.security.auth_cache_ttl": "600000ms",
        "dbms.security.auth_cache_use_ttl": "true",
        "dbms.security.auth_enabled": "true",
        "dbms.security.auth_lock_time": "5000ms",
        "dbms.security.auth_max_failed_attempts": "3",
        "dbms.security.auth_provider": "native",
        "dbms.security.causal_clustering_status_auth_enabled": "true",
        "dbms.security.ha_status_auth_enabled": "true",
        "dbms.security.http_access_control_allow_origin": "*",
        "dbms.security.http_authorization_classes": "[]",
        "dbms.security.http_strict_transport_security": "",
        "dbms.security.ldap.authentication.cache_enabled": "true",
        "dbms.security.ldap.authentication.mechanism": "simple",
        "dbms.security.ldap.authentication.use_samaccountname": "false",
        "dbms.security.ldap.authentication.user_dn_template": "uid={0},ou=users,dc=example,dc=com",
        "dbms.security.ldap.authorization.group_membership_attributes": "[memberOf]",
        "dbms.security.ldap.authorization.group_to_role_mapping": "",
        "dbms.security.ldap.authorization.system_password": "",
        "dbms.security.ldap.authorization.system_username": "",
        "dbms.security.ldap.authorization.use_system_account": "false",
        "dbms.security.ldap.authorization.user_search_base": "ou=users,dc=example,dc=com",
        "dbms.security.ldap.authorization.user_search_filter": "(&(objectClass=*)(uid={0}))",
        "dbms.security.ldap.connection_timeout": "30000ms",
        "dbms.security.ldap.host": "localhost",
        "dbms.security.ldap.read_timeout": "30000ms",
        "dbms.security.ldap.referral": "follow",
        "dbms.security.ldap.use_starttls": "false",
        "dbms.security.log_successful_authentication": "true",
        "dbms.security.procedures.default_allowed": "",
        "dbms.security.procedures.roles": "",
        "dbms.security.procedures.unrestricted": "\"apoc.*,algo.*\"",
        "dbms.security.procedures.whitelist": "*",
        "dbms.security.property_level.blacklist": "",
        "dbms.security.property_level.enabled": "false",
        "dbms.shutdown_transaction_end_timeout": "10000ms",
        "dbms.ssl.policy.<policyname>.allow_key_generation": "false",
        "dbms.ssl.policy.<policyname>.base_directory": "",
        "dbms.ssl.policy.<policyname>.ciphers": "",
        "dbms.ssl.policy.<policyname>.client_auth": "REQUIRE",
        "dbms.ssl.policy.<policyname>.private_key": "private.key",
        "dbms.ssl.policy.<policyname>.public_certificate": "public.crt",
        "dbms.ssl.policy.<policyname>.revoked_dir": "revoked",
        "dbms.ssl.policy.<policyname>.tls_versions": "[TLSv1.2]",
        "dbms.ssl.policy.<policyname>.trust_all": "false",
        "dbms.ssl.policy.<policyname>.trusted_dir": "trusted",
        "dbms.ssl.policy.<policyname>.verify_hostname": "false",
        "dbms.threads.worker_count": "4",
        "dbms.track_query_allocation": "false",
        "dbms.track_query_cpu_time": "false",
        "dbms.transaction.bookmark_ready_timeout": "30000ms",
        "dbms.transaction.monitor.check.interval": "2000ms",
        "dbms.transaction.timeout": "0ms",
        "dbms.tx_log.rotation.retention_policy": "7 days",
        "dbms.tx_log.rotation.size": "262144000",
        "dbms.tx_state.max_off_heap_memory": "2147483648",
        "dbms.tx_state.memory_allocation": "ON_HEAP",
        "dbms.tx_state.off_heap.block_cache_size": "128",
        "dbms.tx_state.off_heap.max_cacheable_block_size": "524288",
        "dbms.udc.enabled": "true",
        "dbms.unmanaged_extension_classes": "[]",
        "dbms.windows_service_name": "neo4j",
        "ha.allow_init_cluster": "true",
        "ha.branched_data_copying_strategy": "branch_then_copy",
        "ha.branched_data_policy": "keep_all",
        "ha.broadcast_timeout": "30000ms",
        "ha.configuration_timeout": "1000ms",
        "ha.data_chunk_size": "2097152",
        "ha.default_timeout": "5000ms",
        "ha.election_timeout": "5000ms",
        "ha.heartbeat_interval": "5000ms",
        "ha.heartbeat_timeout": "40000ms",
        "ha.host.coordination": "0.0.0.0:5001-5099",
        "ha.host.data": "0.0.0.0:6001-6011",
        "ha.initial_hosts": "",
        "ha.internal_role_switch_timeout": "10000ms",
        "ha.join_timeout": "30000ms",
        "ha.learn_timeout": "5000ms",
        "ha.leave_timeout": "30000ms",
        "ha.max_acceptors": "21",
        "ha.max_channels_per_slave": "20",
        "ha.paxos_timeout": "5000ms",
        "ha.phase1_timeout": "5000ms",
        "ha.phase2_timeout": "5000ms",
        "ha.pull_batch_size": "100",
        "ha.pull_interval": "10000ms",
        "ha.role_switch_timeout": "120000ms",
        "ha.server_id": "",
        "ha.slave_lock_timeout": "20000ms",
        "ha.slave_only": "false",
        "ha.slave_read_timeout": "20000ms",
        "ha.tx_push_factor": "1",
        "ha.tx_push_strategy": "fixed_ascending",
        "https.ssl_policy": "legacy",
        "metrics.bolt.messages.enabled": "true",
        "metrics.csv.enabled": "true",
        "metrics.csv.interval": "3000ms",
        "metrics.csv.rotation.keep_number": "7",
        "metrics.csv.rotation.size": "10485760",
        "metrics.cypher.replanning.enabled": "true",
        "metrics.enabled": "true",
        "metrics.graphite.enabled": "false",
        "metrics.graphite.interval": "3000ms",
        "metrics.graphite.server": ":2003",
        "metrics.jvm.buffers.enabled": "true",
        "metrics.jvm.gc.enabled": "true",
        "metrics.jvm.memory.enabled": "true",
        "metrics.jvm.threads.enabled": "true",
        "metrics.neo4j.causal_clustering.enabled": "true",
        "metrics.neo4j.checkpointing.enabled": "true",
        "metrics.neo4j.cluster.enabled": "true",
        "metrics.neo4j.counts.enabled": "true",
        "metrics.neo4j.enabled": "true",
        "metrics.neo4j.logrotation.enabled": "true",
        "metrics.neo4j.network.enabled": "true",
        "metrics.neo4j.pagecache.enabled": "true",
        "metrics.neo4j.server.enabled": "true",
        "metrics.neo4j.tx.enabled": "true",
        "metrics.prefix": "neo4j",
        "metrics.prometheus.enabled": "false",
        "metrics.prometheus.endpoint": "localhost:2004",
        "tools.consistency_checker.check_graph": "true",
        "tools.consistency_checker.check_indexes": "true",
        "tools.consistency_checker.check_label_scan_store": "true",
        "tools.consistency_checker.check_property_owners": "false"
      },
      "apoc": {
        "version": "Neo4jError: Unknown function 'apoc.version' (line 1, column 8 (offset: 7))\n\"RETURN apoc.version() as value\"\n        ^"
      },
      "nodes": {
        "count": 6673172
      },
      "schema": {
        "labels": [
          "NAryTree",
          "Hub",
          "MergeNode",
          "Spoke",
          "Leaf",
          "Customer",
          "RawWriteNode",
          "Address",
          "SimpleWrite",
          "Node",
          "FatNode",
          "Test",
          "Fictional",
          "Interval",
          "ScaleInstance",
          "ChordInstance",
          "Chord",
          "Scale",
          "Tone",
          "Rando",
          "P",
          "TestNode",
          "Canary",
          "User",
          "Tweet",
          "Hashtag",
          "Source"
        ]
      },
      "algo": {
        "version": "Neo4jError: Unknown function 'algo.version' (line 1, column 8 (offset: 7))\n\"RETURN algo.version() as value\"\n        ^"
      }
    },
    {
      "basics": {
        "address": "bolt://node3.cluster.graph.center:7687",
        "procotols": [
          "bolt",
          "http",
          "https"
        ],
        "role": "LEADER",
        "database": "default",
        "id": "ef1ba51b-f929-46f4-a910-9e7525bddb09",
        "label": "node3",
        "dbms": {
          "name": "Neo4j Kernel",
          "versions": [
            "3.5.0"
          ],
          "edition": "enterprise",
          "nativeAuth": true,
          "authEnabled": "true"
        },
        "performance": {
          "stdev": 202.5658825145372,
          "mean": 165.1304347826087,
          "median": 68,
          "mode": [
            46
          ],
          "min": 44,
          "max": 670,
          "errors": {},
          "observations": [
            {
              "x": "2019-03-03T01:17:30.435Z",
              "y": 665
            },
            {
              "x": "2019-03-03T01:17:30.880Z",
              "y": 92
            },
            {
              "x": "2019-03-03T01:17:30.995Z",
              "y": 94
            },
            {
              "x": "2019-03-03T01:17:31.062Z",
              "y": 159
            },
            {
              "x": "2019-03-03T01:17:31.162Z",
              "y": 258
            },
            {
              "x": "2019-03-03T01:17:31.301Z",
              "y": 395
            },
            {
              "x": "2019-03-03T01:17:31.463Z",
              "y": 555
            },
            {
              "x": "2019-03-03T01:17:31.580Z",
              "y": 670
            },
            {
              "x": "2019-03-03T01:17:31.931Z",
              "y": 49
            },
            {
              "x": "2019-03-03T01:17:32.045Z",
              "y": 46
            },
            {
              "x": "2019-03-03T01:17:32.179Z",
              "y": 109
            },
            {
              "x": "2019-03-03T01:17:32.209Z",
              "y": 44
            },
            {
              "x": "2019-03-03T01:17:32.977Z",
              "y": 45
            },
            {
              "x": "2019-03-03T01:17:33.090Z",
              "y": 45
            },
            {
              "x": "2019-03-03T01:17:33.259Z",
              "y": 48
            },
            {
              "x": "2019-03-03T01:17:33.293Z",
              "y": 114
            },
            {
              "x": "2019-03-03T01:17:33.346Z",
              "y": 44
            },
            {
              "x": "2019-03-03T01:17:33.532Z",
              "y": 68
            },
            {
              "x": "2019-03-03T01:17:33.627Z",
              "y": 47
            },
            {
              "x": "2019-03-03T01:17:34.024Z",
              "y": 46
            },
            {
              "x": "2019-03-03T01:17:34.137Z",
              "y": 46
            },
            {
              "x": "2019-03-03T01:17:34.305Z",
              "y": 46
            },
            {
              "x": "2019-03-03T01:17:34.407Z",
              "y": 113
            }
          ]
        }
      },
      "users": [
        {
          "username": "neo4j",
          "flags": [],
          "roles": [
            "admin"
          ]
        },
        {
          "username": "reader",
          "flags": [],
          "roles": [
            "reader"
          ]
        },
        {
          "username": "testevent",
          "flags": [],
          "roles": []
        },
        {
          "username": "arepa",
          "flags": [],
          "roles": []
        },
        {
          "username": "ship",
          "flags": [],
          "roles": [
            "architect",
            "halindemo",
            "reader"
          ]
        },
        {
          "username": "test-newuser",
          "flags": [],
          "roles": [
            "halindemo",
            "testnewrole",
            "testy35role"
          ]
        },
        {
          "username": "halin",
          "flags": [],
          "roles": [
            "reader"
          ]
        }
      ],
      "roles": [
        {
          "role": "aa",
          "users": []
        },
        {
          "role": "editor",
          "users": []
        },
        {
          "role": "halindemo",
          "users": [
            "ship",
            "test-newuser"
          ]
        },
        {
          "role": "testy35role",
          "users": [
            "test-newuser"
          ]
        },
        {
          "role": "reader",
          "users": [
            "halin",
            "reader",
            "ship"
          ]
        },
        {
          "role": "architect",
          "users": [
            "ship"
          ]
        },
        {
          "role": "admin",
          "users": [
            "neo4j"
          ]
        },
        {
          "role": "publisher",
          "users": []
        },
        {
          "role": "Node2Role",
          "users": []
        },
        {
          "role": "testrole4",
          "users": []
        },
        {
          "role": "testnewrole",
          "users": [
            "test-newuser"
          ]
        }
      ],
      "indexes": [
        {
          "description": "INDEX ON :Address(city)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "city"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(cityPrefix)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "cityPrefix"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(country)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "country"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(countryCode)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "countryCode"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(county)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "county"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(created)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "created"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(location)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "location"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(score)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "score"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(secondaryAddress)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "secondaryAddress"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(state)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "state"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(stateAbbr)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "stateAbbr"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(streetAddress)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "streetAddress"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(streetName)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "streetName"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(streetPrefix)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "streetPrefix"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Address(zip)",
          "label": null,
          "tokenNames": [
            "Address"
          ],
          "properties": [
            "zip"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Chord(name)",
          "label": null,
          "tokenNames": [
            "Chord"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :ChordInstance(name)",
          "label": null,
          "tokenNames": [
            "ChordInstance"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Customer(created)",
          "label": null,
          "tokenNames": [
            "Customer"
          ],
          "properties": [
            "created"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Customer(email)",
          "label": null,
          "tokenNames": [
            "Customer"
          ],
          "properties": [
            "email"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Customer(id)",
          "label": null,
          "tokenNames": [
            "Customer"
          ],
          "properties": [
            "id"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Customer(name)",
          "label": null,
          "tokenNames": [
            "Customer"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Customer(score)",
          "label": null,
          "tokenNames": [
            "Customer"
          ],
          "properties": [
            "score"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Customer(username)",
          "label": null,
          "tokenNames": [
            "Customer"
          ],
          "properties": [
            "username"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :FatNode(data)",
          "label": null,
          "tokenNames": [
            "FatNode"
          ],
          "properties": [
            "data"
          ],
          "state": "FAILED",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :Hashtag(name)",
          "label": null,
          "tokenNames": [
            "Hashtag"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Interval(name)",
          "label": null,
          "tokenNames": [
            "Interval"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Leaf(val)",
          "label": null,
          "tokenNames": [
            "Leaf"
          ],
          "properties": [
            "val"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :MergeNode(id)",
          "label": null,
          "tokenNames": [
            "MergeNode"
          ],
          "properties": [
            "id"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :NAryTree(val)",
          "label": null,
          "tokenNames": [
            "NAryTree"
          ],
          "properties": [
            "val"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Node(id)",
          "label": null,
          "tokenNames": [
            "Node"
          ],
          "properties": [
            "id"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "1.0",
            "key": "native-btree"
          }
        },
        {
          "description": "INDEX ON :P(id)",
          "label": null,
          "tokenNames": [
            "P"
          ],
          "properties": [
            "id"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Rando(id)",
          "label": null,
          "tokenNames": [
            "Rando"
          ],
          "properties": [
            "id"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Scale(name)",
          "label": null,
          "tokenNames": [
            "Scale"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :ScaleInstance(name)",
          "label": null,
          "tokenNames": [
            "ScaleInstance"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Tone(name)",
          "label": null,
          "tokenNames": [
            "Tone"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Tweet(text)",
          "label": null,
          "tokenNames": [
            "Tweet"
          ],
          "properties": [
            "text"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :User(name)",
          "label": null,
          "tokenNames": [
            "User"
          ],
          "properties": [
            "name"
          ],
          "state": "ONLINE",
          "type": "node_label_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        },
        {
          "description": "INDEX ON :Fictional(id)",
          "label": null,
          "tokenNames": [
            "Fictional"
          ],
          "properties": [
            "id"
          ],
          "state": "ONLINE",
          "type": "node_unique_property",
          "provider": {
            "version": "2.0",
            "key": "lucene+native"
          }
        }
      ],
      "constraints": [
        {
          "idx": 0,
          "description": "CONSTRAINT ON ( fictional:Fictional ) ASSERT (fictional.id) IS NODE KEY"
        }
      ],
      "JMX": [
        {
          "name": "org.neo4j:instance=kernel#0,name=Kernel",
          "attributes": {
            "KernelVersion": {
              "description": "The version of Neo4j",
              "value": "neo4j-kernel, version: 3.5.0,78fb2c3fb974d4cc4ce4a7803283e2eb776305ff"
            },
            "ReadOnly": {
              "description": "Whether this is a read only instance",
              "value": false
            },
            "StoreId": {
              "description": "An identifier that, together with store creation time, uniquely identifies this Neo4j graph store.",
              "value": "4c06975e6b81247d"
            },
            "KernelStartTime": {
              "description": "The time from which this Neo4j instance was in operational mode.",
              "value": 1545251521655
            },
            "DatabaseName": {
              "description": "The name of the mounted database",
              "value": "graph.db"
            },
            "MBeanQuery": {
              "description": "An ObjectName that can be used as a query for getting all management beans for this Neo4j instance.",
              "value": "org.neo4j:instance=kernel#0,name=*"
            },
            "StoreLogVersion": {
              "description": "The current version of the Neo4j store logical log.",
              "value": 41
            },
            "StoreCreationDate": {
              "description": "The time when this Neo4j graph store was created.",
              "value": 1537200614306
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Causal Clustering",
          "attributes": {
            "Role": {
              "description": "The current role this member has in the cluster",
              "value": "LEADER"
            },
            "ReplicatedStateSize": {
              "description": "The total amount of disk space used by the replicated states, in bytes",
              "value": 27804
            },
            "RaftLogSize": {
              "description": "The total amount of disk space used by the raft log, in bytes",
              "value": 1157978761
            }
          }
        },
        {
          "name": "JMImplementation:type=MBeanServerDelegate",
          "attributes": {
            "ImplementationName": {
              "description": "The JMX implementation name (the name of this product)",
              "value": "JMX"
            },
            "MBeanServerId": {
              "description": "The MBean server agent identification",
              "value": "meetup-cluster-core-vm-3_1545251480881"
            },
            "ImplementationVersion": {
              "description": "The JMX implementation version (the version of this product).",
              "value": "1.8.0_191-8u191-b12-0ubuntu0.16.04.1-b12"
            },
            "SpecificationVersion": {
              "description": "The version of the JMX specification implemented by this product.",
              "value": "1.4"
            },
            "SpecificationVendor": {
              "description": "The vendor of the JMX specification implemented by this product.",
              "value": "Oracle Corporation"
            },
            "SpecificationName": {
              "description": "The full name of the JMX specification implemented by this product.",
              "value": "Java Management Extensions"
            },
            "ImplementationVendor": {
              "description": "the JMX implementation vendor (the vendor of this product).",
              "value": "Oracle Corporation"
            }
          }
        },
        {
          "name": "java.lang:type=Runtime",
          "attributes": {
            "SpecVendor": {
              "description": "SpecVendor",
              "value": "Oracle Corporation"
            },
            "ClassPath": {
              "description": "ClassPath",
              "value": "/var/lib/neo4j/plugins:/etc/neo4j:/usr/share/neo4j/lib/concurrentlinkedhashmap-lru-1.4.2.jar:/usr/share/neo4j/lib/ssl-config-core_2.11-0.2.3.jar:/usr/share/neo4j/lib/jersey-core-1.19.3.jar:/usr/share/neo4j/lib/neo4j-auth-plugin-api-3.5.0.jar:/usr/share/neo4j/lib/jetty-util-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-fulltext-index-3.5.0.jar:/usr/share/neo4j/lib/neo4j-com-3.5.0.jar:/usr/share/neo4j/lib/akka-actor_2.11-2.5.14.jar:/usr/share/neo4j/lib/config-1.3.3.jar:/usr/share/neo4j/lib/ast-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/akka-protobuf_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-diagnostics-3.5.0.jar:/usr/share/neo4j/lib/jetty-webapp-9.4.11.v20180605.jar:/usr/share/neo4j/lib/jProcesses-1.6.4.jar:/usr/share/neo4j/lib/jetty-servlet-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-graphdb-api-3.5.0.jar:/usr/share/neo4j/lib/jsr311-api-1.1.2.r612.jar:/usr/share/neo4j/lib/neo4j-resource-3.5.0.jar:/usr/share/neo4j/lib/jaxb-core-2.3.0.1.jar:/usr/share/neo4j/lib/neo4j-cypher-ir-3.5-3.5.0.jar:/usr/share/neo4j/lib/bcprov-jdk15on-1.60.jar:/usr/share/neo4j/lib/neo4j-management-3.5.0.jar:/usr/share/neo4j/lib/jackson-mapper-asl-1.9.13.jar:/usr/share/neo4j/lib/jetty-security-9.4.11.v20180605.jar:/usr/share/neo4j/lib/jackson-jaxrs-1.9.13.jar:/usr/share/neo4j/lib/neo4j-command-line-3.5.0.jar:/usr/share/neo4j/lib/neo4j-ha-3.5.0.jar:/usr/share/neo4j/lib/jaxb-api-2.3.0.jar:/usr/share/neo4j/lib/shiro-crypto-cipher-1.4.0.jar:/usr/share/neo4j/lib/neo4j-server-enterprise-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-util-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-cypher-compiled-expressions-3.5.0.jar:/usr/share/neo4j/lib/neo4j-server-3.5.0.jar:/usr/share/neo4j/lib/neo4j-io-3.5.0.jar:/usr/share/neo4j/lib/scala-parser-combinators_2.11-1.1.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-spi-3.5-3.5.0.jar:/usr/share/neo4j/lib/shiro-core-1.4.0.jar:/usr/share/neo4j/lib/jline-2.14.3.jar:/usr/share/neo4j/lib/scallop_2.11-2.1.1.jar:/usr/share/neo4j/lib/txw2-2.3.0.1.jar:/usr/share/neo4j/lib/istack-commons-runtime-3.0.5.jar:/usr/share/neo4j/lib/akka-cluster_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-common-3.5.0.jar:/usr/share/neo4j/lib/neo4j-server-commercial-3.5.0.jar:/usr/share/neo4j/lib/util-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/opencsv-2.3.jar:/usr/share/neo4j/lib/neo4j-index-3.5.0.jar:/usr/share/neo4j/lib/jetty-server-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-concurrent-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-kernel-api-3.5.0.jar:/usr/share/neo4j/lib/asm-analysis-6.2.jar:/usr/share/neo4j/lib/neo4j-security-enterprise-3.5.0.jar:/usr/share/neo4j/lib/neo4j-causal-clustering-3.5.0.jar:/usr/share/neo4j/lib/neo4j-dbms-3.5.0.jar:/usr/share/neo4j/lib/parser-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/neo4j-cypher-frontend-2.3-2.3.12.jar:/usr/share/neo4j/lib/neo4j-values-3.5.0.jar:/usr/share/neo4j/lib/netty-3.9.9.Final.jar:/usr/share/neo4j/lib/neo4j-cypher-slotted-runtime-3.5.0.jar:/usr/share/neo4j/lib/akka-cluster-tools_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-cypher-3.5.0.jar:/usr/share/neo4j/lib/commons-configuration-1.10.jar:/usr/share/neo4j/lib/bcpkix-jdk15on-1.60.jar:/usr/share/neo4j/lib/commons-lang-2.6.jar:/usr/share/neo4j/lib/server-api-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-compiler-3.1-3.1.9.jar:/usr/share/neo4j/lib/neo4j-enterprise-kernel-3.5.0.jar:/usr/share/neo4j/lib/shiro-config-core-1.4.0.jar:/usr/share/neo4j/lib/neo4j-unsafe-3.5.0.jar:/usr/share/neo4j/lib/asm-tree-6.2.jar:/usr/share/neo4j/lib/jaxb-runtime-2.3.0.1.jar:/usr/share/neo4j/lib/stax-ex-1.7.8.jar:/usr/share/neo4j/lib/neo4j-csv-3.5.0.jar:/usr/share/neo4j/lib/neo4j-kernel-3.5.0.jar:/usr/share/neo4j/lib/shiro-crypto-hash-1.4.0.jar:/usr/share/neo4j/lib/jetty-io-9.4.11.v20180605.jar:/usr/share/neo4j/lib/jackson-core-asl-1.9.13.jar:/usr/share/neo4j/lib/jersey-server-1.19.3.jar:/usr/share/neo4j/lib/akka-stream_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-cypher-runtime-util-3.5.0.jar:/usr/share/neo4j/lib/shiro-event-1.4.0.jar:/usr/share/neo4j/lib/jersey-servlet-1.19.3.jar:/usr/share/neo4j/lib/WMI4Java-1.6.1.jar:/usr/share/neo4j/lib/hazelcast-all-3.7.8.jar:/usr/share/neo4j/lib/metrics-core-4.0.2.jar:/usr/share/neo4j/lib/parboiled-core-1.1.7.jar:/usr/share/neo4j/lib/neo4j-spatial-index-3.5.0.jar:/usr/share/neo4j/lib/rewriting-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/neo4j-udc-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-physical-planning-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-3.5-3.5.0.jar:/usr/share/neo4j/lib/neo4j-codegen-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-morsel-runtime-3.5.0.jar:/usr/share/neo4j/lib/reactive-streams-1.0.2.jar:/usr/share/neo4j/lib/neo4j-import-tool-3.5.0.jar:/usr/share/neo4j/lib/akka-remote_2.11-2.5.14.jar:/usr/share/neo4j/lib/lucene-analyzers-common-5.5.5.jar:/usr/share/neo4j/lib/neo4j-logging-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-logical-plans-3.5-3.5.0.jar:/usr/share/neo4j/lib/front-end-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/scala-java8-compat_2.11-0.7.0.jar:/usr/share/neo4j/lib/parboiled-scala_2.11-1.1.7.jar:/usr/share/neo4j/lib/simpleclient_httpserver-0.4.0.jar:/usr/share/neo4j/lib/neo4j-query-logging-3.5.0.jar:/usr/share/neo4j/lib/commons-text-1.4.jar:/usr/share/neo4j/lib/simpleclient-0.4.0.jar:/usr/share/neo4j/lib/lucene-core-5.5.5.jar:/usr/share/neo4j/lib/netty-all-4.1.30.Final.jar:/usr/share/neo4j/lib/neo4j-causal-clustering-commercial-3.5.0.jar:/usr/share/neo4j/lib/slf4j-api-1.7.25.jar:/usr/share/neo4j/lib/commons-collections-3.2.2.jar:/usr/share/neo4j/lib/neo4j-lucene-upgrade-3.5.0.jar:/usr/share/neo4j/lib/eclipse-collections-9.2.0.jar:/usr/share/neo4j/lib/neo4j-consistency-check-3.5.0.jar:/usr/share/neo4j/lib/neo4j-kernel-commercial-3.5.0.jar:/usr/share/neo4j/lib/neo4j-backup-3.5.0.jar:/usr/share/neo4j/lib/neo4j-configuration-3.5.0.jar:/usr/share/neo4j/lib/neo4j-commercial-3.5.0.jar:/usr/share/neo4j/lib/neo4j-security-3.5.0.jar:/usr/share/neo4j/lib/commons-compress-1.18.jar:/usr/share/neo4j/lib/kiama_2.11-2.1.0.jar:/usr/share/neo4j/lib/neo4j-cypher-frontend-3.1-3.1.9.jar:/usr/share/neo4j/lib/neo4j-cypher-ir-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-cypher-logical-plans-3.4-3.4.9.jar:/usr/share/neo4j/lib/eclipse-collections-api-9.2.0.jar:/usr/share/neo4j/lib/neo4j-security-commercial-3.5.0.jar:/usr/share/neo4j/lib/openCypher-frontend-1-3.4.9.jar:/usr/share/neo4j/lib/simpleclient_common-0.4.0.jar:/usr/share/neo4j/lib/commons-logging-1.1.1.jar:/usr/share/neo4j/lib/commons-beanutils-1.9.3.jar:/usr/share/neo4j/lib/caffeine-2.6.2.jar:/usr/share/neo4j/lib/neo4j-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-compiler-2.3-2.3.12.jar:/usr/share/neo4j/lib/aeron-client-1.9.1.jar:/usr/share/neo4j/lib/metrics-graphite-4.0.2.jar:/usr/share/neo4j/lib/activation-1.1.1.jar:/usr/share/neo4j/lib/expressions-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/jetty-client-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-jmx-3.5.0.jar:/usr/share/neo4j/lib/neo4j-browser-3.2.13.jar:/usr/share/neo4j/lib/neo4j-graph-algo-3.5.0.jar:/usr/share/neo4j/lib/neo4j-graph-matching-3.1.9.jar:/usr/share/neo4j/lib/neo4j-cluster-3.5.0.jar:/usr/share/neo4j/lib/neo4j-collections-3.5.0.jar:/usr/share/neo4j/lib/lz4-1.3.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-spi-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-lucene-index-3.5.0.jar:/usr/share/neo4j/lib/FastInfoset-1.2.13.jar:/usr/share/neo4j/lib/shiro-lang-1.4.0.jar:/usr/share/neo4j/lib/commons-io-2.6.jar:/usr/share/neo4j/lib/neo4j-cypher-interpreted-runtime-3.5.0.jar:/usr/share/neo4j/lib/simpleclient_dropwizard-0.4.0.jar:/usr/share/neo4j/lib/neo4j-legacy-3.5.0.jar:/usr/share/neo4j/lib/scala-reflect-2.11.12.jar:/usr/share/neo4j/lib/agrona-0.9.17.jar:/usr/share/neo4j/lib/shiro-crypto-core-1.4.0.jar:/usr/share/neo4j/lib/neo4j-enterprise-cypher-3.5.0.jar:/usr/share/neo4j/lib/akka-distributed-data_2.11-2.5.14.jar:/usr/share/neo4j/lib/shiro-config-ogdl-1.4.0.jar:/usr/share/neo4j/lib/asm-util-6.2.jar:/usr/share/neo4j/lib/jetty-http-9.4.11.v20180605.jar:/usr/share/neo4j/lib/lucene-codecs-5.5.5.jar:/usr/share/neo4j/lib/neo4j-bolt-3.5.0.jar:/usr/share/neo4j/lib/lucene-queryparser-5.5.5.jar:/usr/share/neo4j/lib/scala-library-2.11.12.jar:/usr/share/neo4j/lib/neo4j-ssl-3.5.0.jar:/usr/share/neo4j/lib/jetty-xml-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-procedure-api-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-expression-3.4-3.4.9.jar:/usr/share/neo4j/lib/jPowerShell-1.9.jar:/usr/share/neo4j/lib/shiro-cache-1.4.0.jar:/usr/share/neo4j/lib/javax.servlet-api-3.1.0.jar:/usr/share/neo4j/lib/neo4j-metrics-3.5.0.jar:/usr/share/neo4j/lib/slf4j-nop-1.7.25.jar:/usr/share/neo4j/lib/commons-lang3-3.8.jar:/usr/share/neo4j/lib/asm-6.2.jar:/usr/share/neo4j/lib/aeron-driver-1.9.1.jar:/var/lib/neo4j/plugins/*"
            },
            "InputArguments": {
              "description": "InputArguments",
              "value": [
                "-Xms4g",
                "-Xmx4g",
                "-XX:+UseG1GC",
                "-XX:-OmitStackTraceInFastThrow",
                "-XX:+AlwaysPreTouch",
                "-XX:+UnlockExperimentalVMOptions",
                "-XX:+TrustFinalNonStaticFields",
                "-XX:+DisableExplicitGC",
                "-Djdk.tls.ephemeralDHKeySize=2048",
                "-Djdk.tls.rejectClientInitiatedRenegotiation=true",
                "-Dunsupported.dbms.udc.source=gcloud-CORE",
                "-Dfile.encoding=UTF-8"
              ]
            },
            "Uptime": {
              "description": "Uptime",
              "value": 6324403733
            },
            "VmName": {
              "description": "VmName",
              "value": "OpenJDK 64-Bit Server VM"
            },
            "StartTime": {
              "description": "StartTime",
              "value": 1545251462710
            },
            "SpecName": {
              "description": "SpecName",
              "value": "Java Virtual Machine Specification"
            },
            "VmVersion": {
              "description": "VmVersion",
              "value": "25.191-b12"
            },
            "ManagementSpecVersion": {
              "description": "ManagementSpecVersion",
              "value": "1.2"
            },
            "Name": {
              "description": "Name",
              "value": "2120@meetup-cluster-core-vm-3"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:type=Runtime"
            },
            "VmVendor": {
              "description": "VmVendor",
              "value": "Oracle Corporation"
            },
            "LibraryPath": {
              "description": "LibraryPath",
              "value": "/usr/java/packages/lib/amd64:/usr/lib/x86_64-linux-gnu/jni:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/usr/lib/jni:/lib:/usr/lib"
            },
            "BootClassPath": {
              "description": "BootClassPath",
              "value": "/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/rt.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jfr.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/classes"
            },
            "SpecVersion": {
              "description": "SpecVersion",
              "value": "1.8"
            },
            "SystemProperties": {
              "description": "SystemProperties",
              "value": {
                "[sun.io.unicode.encoding]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "UnicodeLittle",
                    "key": "sun.io.unicode.encoding"
                  }
                },
                "[awt.toolkit]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "sun.awt.X11.XToolkit",
                    "key": "awt.toolkit"
                  }
                },
                "[sun.java.command]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "com.neo4j.server.enterprise.CommercialEntryPoint --home-dir=/var/lib/neo4j --config-dir=/etc/neo4j",
                    "key": "sun.java.command"
                  }
                },
                "[file.separator]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/",
                    "key": "file.separator"
                  }
                },
                "[sun.arch.data.model]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "64",
                    "key": "sun.arch.data.model"
                  }
                },
                "[java.vm.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "25.191-b12",
                    "key": "java.vm.version"
                  }
                },
                "[java.class.path]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/var/lib/neo4j/plugins:/etc/neo4j:/usr/share/neo4j/lib/concurrentlinkedhashmap-lru-1.4.2.jar:/usr/share/neo4j/lib/ssl-config-core_2.11-0.2.3.jar:/usr/share/neo4j/lib/jersey-core-1.19.3.jar:/usr/share/neo4j/lib/neo4j-auth-plugin-api-3.5.0.jar:/usr/share/neo4j/lib/jetty-util-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-fulltext-index-3.5.0.jar:/usr/share/neo4j/lib/neo4j-com-3.5.0.jar:/usr/share/neo4j/lib/akka-actor_2.11-2.5.14.jar:/usr/share/neo4j/lib/config-1.3.3.jar:/usr/share/neo4j/lib/ast-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/akka-protobuf_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-diagnostics-3.5.0.jar:/usr/share/neo4j/lib/jetty-webapp-9.4.11.v20180605.jar:/usr/share/neo4j/lib/jProcesses-1.6.4.jar:/usr/share/neo4j/lib/jetty-servlet-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-graphdb-api-3.5.0.jar:/usr/share/neo4j/lib/jsr311-api-1.1.2.r612.jar:/usr/share/neo4j/lib/neo4j-resource-3.5.0.jar:/usr/share/neo4j/lib/jaxb-core-2.3.0.1.jar:/usr/share/neo4j/lib/neo4j-cypher-ir-3.5-3.5.0.jar:/usr/share/neo4j/lib/bcprov-jdk15on-1.60.jar:/usr/share/neo4j/lib/neo4j-management-3.5.0.jar:/usr/share/neo4j/lib/jackson-mapper-asl-1.9.13.jar:/usr/share/neo4j/lib/jetty-security-9.4.11.v20180605.jar:/usr/share/neo4j/lib/jackson-jaxrs-1.9.13.jar:/usr/share/neo4j/lib/neo4j-command-line-3.5.0.jar:/usr/share/neo4j/lib/neo4j-ha-3.5.0.jar:/usr/share/neo4j/lib/jaxb-api-2.3.0.jar:/usr/share/neo4j/lib/shiro-crypto-cipher-1.4.0.jar:/usr/share/neo4j/lib/neo4j-server-enterprise-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-util-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-cypher-compiled-expressions-3.5.0.jar:/usr/share/neo4j/lib/neo4j-server-3.5.0.jar:/usr/share/neo4j/lib/neo4j-io-3.5.0.jar:/usr/share/neo4j/lib/scala-parser-combinators_2.11-1.1.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-spi-3.5-3.5.0.jar:/usr/share/neo4j/lib/shiro-core-1.4.0.jar:/usr/share/neo4j/lib/jline-2.14.3.jar:/usr/share/neo4j/lib/scallop_2.11-2.1.1.jar:/usr/share/neo4j/lib/txw2-2.3.0.1.jar:/usr/share/neo4j/lib/istack-commons-runtime-3.0.5.jar:/usr/share/neo4j/lib/akka-cluster_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-common-3.5.0.jar:/usr/share/neo4j/lib/neo4j-server-commercial-3.5.0.jar:/usr/share/neo4j/lib/util-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/opencsv-2.3.jar:/usr/share/neo4j/lib/neo4j-index-3.5.0.jar:/usr/share/neo4j/lib/jetty-server-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-concurrent-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-kernel-api-3.5.0.jar:/usr/share/neo4j/lib/asm-analysis-6.2.jar:/usr/share/neo4j/lib/neo4j-security-enterprise-3.5.0.jar:/usr/share/neo4j/lib/neo4j-causal-clustering-3.5.0.jar:/usr/share/neo4j/lib/neo4j-dbms-3.5.0.jar:/usr/share/neo4j/lib/parser-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/neo4j-cypher-frontend-2.3-2.3.12.jar:/usr/share/neo4j/lib/neo4j-values-3.5.0.jar:/usr/share/neo4j/lib/netty-3.9.9.Final.jar:/usr/share/neo4j/lib/neo4j-cypher-slotted-runtime-3.5.0.jar:/usr/share/neo4j/lib/akka-cluster-tools_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-cypher-3.5.0.jar:/usr/share/neo4j/lib/commons-configuration-1.10.jar:/usr/share/neo4j/lib/bcpkix-jdk15on-1.60.jar:/usr/share/neo4j/lib/commons-lang-2.6.jar:/usr/share/neo4j/lib/server-api-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-compiler-3.1-3.1.9.jar:/usr/share/neo4j/lib/neo4j-enterprise-kernel-3.5.0.jar:/usr/share/neo4j/lib/shiro-config-core-1.4.0.jar:/usr/share/neo4j/lib/neo4j-unsafe-3.5.0.jar:/usr/share/neo4j/lib/asm-tree-6.2.jar:/usr/share/neo4j/lib/jaxb-runtime-2.3.0.1.jar:/usr/share/neo4j/lib/stax-ex-1.7.8.jar:/usr/share/neo4j/lib/neo4j-csv-3.5.0.jar:/usr/share/neo4j/lib/neo4j-kernel-3.5.0.jar:/usr/share/neo4j/lib/shiro-crypto-hash-1.4.0.jar:/usr/share/neo4j/lib/jetty-io-9.4.11.v20180605.jar:/usr/share/neo4j/lib/jackson-core-asl-1.9.13.jar:/usr/share/neo4j/lib/jersey-server-1.19.3.jar:/usr/share/neo4j/lib/akka-stream_2.11-2.5.14.jar:/usr/share/neo4j/lib/neo4j-cypher-runtime-util-3.5.0.jar:/usr/share/neo4j/lib/shiro-event-1.4.0.jar:/usr/share/neo4j/lib/jersey-servlet-1.19.3.jar:/usr/share/neo4j/lib/WMI4Java-1.6.1.jar:/usr/share/neo4j/lib/hazelcast-all-3.7.8.jar:/usr/share/neo4j/lib/metrics-core-4.0.2.jar:/usr/share/neo4j/lib/parboiled-core-1.1.7.jar:/usr/share/neo4j/lib/neo4j-spatial-index-3.5.0.jar:/usr/share/neo4j/lib/rewriting-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/neo4j-udc-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-physical-planning-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-3.5-3.5.0.jar:/usr/share/neo4j/lib/neo4j-codegen-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-morsel-runtime-3.5.0.jar:/usr/share/neo4j/lib/reactive-streams-1.0.2.jar:/usr/share/neo4j/lib/neo4j-import-tool-3.5.0.jar:/usr/share/neo4j/lib/akka-remote_2.11-2.5.14.jar:/usr/share/neo4j/lib/lucene-analyzers-common-5.5.5.jar:/usr/share/neo4j/lib/neo4j-logging-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-logical-plans-3.5-3.5.0.jar:/usr/share/neo4j/lib/front-end-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/scala-java8-compat_2.11-0.7.0.jar:/usr/share/neo4j/lib/parboiled-scala_2.11-1.1.7.jar:/usr/share/neo4j/lib/simpleclient_httpserver-0.4.0.jar:/usr/share/neo4j/lib/neo4j-query-logging-3.5.0.jar:/usr/share/neo4j/lib/commons-text-1.4.jar:/usr/share/neo4j/lib/simpleclient-0.4.0.jar:/usr/share/neo4j/lib/lucene-core-5.5.5.jar:/usr/share/neo4j/lib/netty-all-4.1.30.Final.jar:/usr/share/neo4j/lib/neo4j-causal-clustering-commercial-3.5.0.jar:/usr/share/neo4j/lib/slf4j-api-1.7.25.jar:/usr/share/neo4j/lib/commons-collections-3.2.2.jar:/usr/share/neo4j/lib/neo4j-lucene-upgrade-3.5.0.jar:/usr/share/neo4j/lib/eclipse-collections-9.2.0.jar:/usr/share/neo4j/lib/neo4j-consistency-check-3.5.0.jar:/usr/share/neo4j/lib/neo4j-kernel-commercial-3.5.0.jar:/usr/share/neo4j/lib/neo4j-backup-3.5.0.jar:/usr/share/neo4j/lib/neo4j-configuration-3.5.0.jar:/usr/share/neo4j/lib/neo4j-commercial-3.5.0.jar:/usr/share/neo4j/lib/neo4j-security-3.5.0.jar:/usr/share/neo4j/lib/commons-compress-1.18.jar:/usr/share/neo4j/lib/kiama_2.11-2.1.0.jar:/usr/share/neo4j/lib/neo4j-cypher-frontend-3.1-3.1.9.jar:/usr/share/neo4j/lib/neo4j-cypher-ir-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-cypher-logical-plans-3.4-3.4.9.jar:/usr/share/neo4j/lib/eclipse-collections-api-9.2.0.jar:/usr/share/neo4j/lib/neo4j-security-commercial-3.5.0.jar:/usr/share/neo4j/lib/openCypher-frontend-1-3.4.9.jar:/usr/share/neo4j/lib/simpleclient_common-0.4.0.jar:/usr/share/neo4j/lib/commons-logging-1.1.1.jar:/usr/share/neo4j/lib/commons-beanutils-1.9.3.jar:/usr/share/neo4j/lib/caffeine-2.6.2.jar:/usr/share/neo4j/lib/neo4j-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-compiler-2.3-2.3.12.jar:/usr/share/neo4j/lib/aeron-client-1.9.1.jar:/usr/share/neo4j/lib/metrics-graphite-4.0.2.jar:/usr/share/neo4j/lib/activation-1.1.1.jar:/usr/share/neo4j/lib/expressions-9.0-9.0.20181030.jar:/usr/share/neo4j/lib/jetty-client-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-jmx-3.5.0.jar:/usr/share/neo4j/lib/neo4j-browser-3.2.13.jar:/usr/share/neo4j/lib/neo4j-graph-algo-3.5.0.jar:/usr/share/neo4j/lib/neo4j-graph-matching-3.1.9.jar:/usr/share/neo4j/lib/neo4j-cluster-3.5.0.jar:/usr/share/neo4j/lib/neo4j-collections-3.5.0.jar:/usr/share/neo4j/lib/lz4-1.3.0.jar:/usr/share/neo4j/lib/neo4j-cypher-planner-spi-3.4-3.4.9.jar:/usr/share/neo4j/lib/neo4j-lucene-index-3.5.0.jar:/usr/share/neo4j/lib/FastInfoset-1.2.13.jar:/usr/share/neo4j/lib/shiro-lang-1.4.0.jar:/usr/share/neo4j/lib/commons-io-2.6.jar:/usr/share/neo4j/lib/neo4j-cypher-interpreted-runtime-3.5.0.jar:/usr/share/neo4j/lib/simpleclient_dropwizard-0.4.0.jar:/usr/share/neo4j/lib/neo4j-legacy-3.5.0.jar:/usr/share/neo4j/lib/scala-reflect-2.11.12.jar:/usr/share/neo4j/lib/agrona-0.9.17.jar:/usr/share/neo4j/lib/shiro-crypto-core-1.4.0.jar:/usr/share/neo4j/lib/neo4j-enterprise-cypher-3.5.0.jar:/usr/share/neo4j/lib/akka-distributed-data_2.11-2.5.14.jar:/usr/share/neo4j/lib/shiro-config-ogdl-1.4.0.jar:/usr/share/neo4j/lib/asm-util-6.2.jar:/usr/share/neo4j/lib/jetty-http-9.4.11.v20180605.jar:/usr/share/neo4j/lib/lucene-codecs-5.5.5.jar:/usr/share/neo4j/lib/neo4j-bolt-3.5.0.jar:/usr/share/neo4j/lib/lucene-queryparser-5.5.5.jar:/usr/share/neo4j/lib/scala-library-2.11.12.jar:/usr/share/neo4j/lib/neo4j-ssl-3.5.0.jar:/usr/share/neo4j/lib/jetty-xml-9.4.11.v20180605.jar:/usr/share/neo4j/lib/neo4j-procedure-api-3.5.0.jar:/usr/share/neo4j/lib/neo4j-cypher-expression-3.4-3.4.9.jar:/usr/share/neo4j/lib/jPowerShell-1.9.jar:/usr/share/neo4j/lib/shiro-cache-1.4.0.jar:/usr/share/neo4j/lib/javax.servlet-api-3.1.0.jar:/usr/share/neo4j/lib/neo4j-metrics-3.5.0.jar:/usr/share/neo4j/lib/slf4j-nop-1.7.25.jar:/usr/share/neo4j/lib/commons-lang3-3.8.jar:/usr/share/neo4j/lib/asm-6.2.jar:/usr/share/neo4j/lib/aeron-driver-1.9.1.jar:/var/lib/neo4j/plugins/*",
                    "key": "java.class.path"
                  }
                },
                "[path.separator]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": ":",
                    "key": "path.separator"
                  }
                },
                "[java.vendor]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Oracle Corporation",
                    "key": "java.vendor"
                  }
                },
                "[java.awt.graphicsenv]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "sun.awt.X11GraphicsEnvironment",
                    "key": "java.awt.graphicsenv"
                  }
                },
                "[java.ext.dirs]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/ext:/usr/java/packages/lib/ext",
                    "key": "java.ext.dirs"
                  }
                },
                "[hazelcast.socket.bind.any]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "false",
                    "key": "hazelcast.socket.bind.any"
                  }
                },
                "[os.name]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Linux",
                    "key": "os.name"
                  }
                },
                "[jdk.tls.rejectClientInitiatedRenegotiation]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "true",
                    "key": "jdk.tls.rejectClientInitiatedRenegotiation"
                  }
                },
                "[java.class.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "52.0",
                    "key": "java.class.version"
                  }
                },
                "[user.dir]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/",
                    "key": "user.dir"
                  }
                },
                "[line.separator]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "\n",
                    "key": "line.separator"
                  }
                },
                "[hazelcast.wait.seconds.before.join]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "1",
                    "key": "hazelcast.wait.seconds.before.join"
                  }
                },
                "[java.io.tmpdir]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/tmp",
                    "key": "java.io.tmpdir"
                  }
                },
                "[java.vm.specification.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "1.8",
                    "key": "java.vm.specification.version"
                  }
                },
                "[java.runtime.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "1.8.0_191-8u191-b12-0ubuntu0.16.04.1-b12",
                    "key": "java.runtime.version"
                  }
                },
                "[sun.management.compiler]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "HotSpot 64-Bit Tiered Compilers",
                    "key": "sun.management.compiler"
                  }
                },
                "[hazelcast.phone.home.enabled]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "false",
                    "key": "hazelcast.phone.home.enabled"
                  }
                },
                "[java.specification.name]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Java Platform API Specification",
                    "key": "java.specification.name"
                  }
                },
                "[java.home]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/usr/lib/jvm/java-8-openjdk-amd64/jre",
                    "key": "java.home"
                  }
                },
                "[sun.cpu.isalist]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "",
                    "key": "sun.cpu.isalist"
                  }
                },
                "[user.timezone]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Etc/UTC",
                    "key": "user.timezone"
                  }
                },
                "[sun.java.launcher]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "SUN_STANDARD",
                    "key": "sun.java.launcher"
                  }
                },
                "[java.specification.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "1.8",
                    "key": "java.specification.version"
                  }
                },
                "[unsupported.dbms.udc.source]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "gcloud-CORE",
                    "key": "unsupported.dbms.udc.source"
                  }
                },
                "[java.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "1.8.0_191",
                    "key": "java.version"
                  }
                },
                "[file.encoding]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "UTF-8",
                    "key": "file.encoding"
                  }
                },
                "[java.runtime.name]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "OpenJDK Runtime Environment",
                    "key": "java.runtime.name"
                  }
                },
                "[java.specification.vendor]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Oracle Corporation",
                    "key": "java.specification.vendor"
                  }
                },
                "[java.vendor.url.bug]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "http://bugreport.sun.com/bugreport/",
                    "key": "java.vendor.url.bug"
                  }
                },
                "[java.vendor.url]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "http://java.oracle.com/",
                    "key": "java.vendor.url"
                  }
                },
                "[file.encoding.pkg]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "sun.io",
                    "key": "file.encoding.pkg"
                  }
                },
                "[jetty.git.hash]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "d5fc0523cfa96bfebfbda19606cad384d772f04c",
                    "key": "jetty.git.hash"
                  }
                },
                "[jdk.tls.ephemeralDHKeySize]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "2048",
                    "key": "jdk.tls.ephemeralDHKeySize"
                  }
                },
                "[java.endorsed.dirs]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/endorsed",
                    "key": "java.endorsed.dirs"
                  }
                },
                "[os.version]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "4.15.0-1017-gcp",
                    "key": "os.version"
                  }
                },
                "[java.vm.specification.name]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Java Virtual Machine Specification",
                    "key": "java.vm.specification.name"
                  }
                },
                "[user.name]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "neo4j",
                    "key": "user.name"
                  }
                },
                "[user.country]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "US",
                    "key": "user.country"
                  }
                },
                "[java.vm.vendor]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Oracle Corporation",
                    "key": "java.vm.vendor"
                  }
                },
                "[hazelcast.shutdownhook.enabled]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "false",
                    "key": "hazelcast.shutdownhook.enabled"
                  }
                },
                "[java.library.path]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/usr/java/packages/lib/amd64:/usr/lib/x86_64-linux-gnu/jni:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/usr/lib/jni:/lib:/usr/lib",
                    "key": "java.library.path"
                  }
                },
                "[sun.os.patch.level]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "unknown",
                    "key": "sun.os.patch.level"
                  }
                },
                "[user.language]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "en",
                    "key": "user.language"
                  }
                },
                "[sun.boot.library.path]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/amd64",
                    "key": "sun.boot.library.path"
                  }
                },
                "[java.vm.name]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "OpenJDK 64-Bit Server VM",
                    "key": "java.vm.name"
                  }
                },
                "[sun.nio.ch.bugLevel]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "",
                    "key": "sun.nio.ch.bugLevel"
                  }
                },
                "[hazelcast.logging.type]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "none",
                    "key": "hazelcast.logging.type"
                  }
                },
                "[sun.cpu.endian]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "little",
                    "key": "sun.cpu.endian"
                  }
                },
                "[java.vm.info]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "mixed mode",
                    "key": "java.vm.info"
                  }
                },
                "[os.arch]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "amd64",
                    "key": "os.arch"
                  }
                },
                "[user.home]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/var/lib/neo4j",
                    "key": "user.home"
                  }
                },
                "[sun.boot.class.path]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/rt.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jfr.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/classes",
                    "key": "sun.boot.class.path"
                  }
                },
                "[java.vm.specification.vendor]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "Oracle Corporation",
                    "key": "java.vm.specification.vendor"
                  }
                },
                "[sun.jnu.encoding]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "UTF-8",
                    "key": "sun.jnu.encoding"
                  }
                },
                "[java.awt.printerjob]": {
                  "description": "java.util.Map<java.lang.String, java.lang.String>",
                  "properties": {
                    "value": "sun.print.PSPrinterJob",
                    "key": "java.awt.printerjob"
                  }
                }
              }
            },
            "BootClassPathSupported": {
              "description": "BootClassPathSupported",
              "value": true
            }
          }
        },
        {
          "name": "java.lang:type=Threading",
          "attributes": {
            "ThreadAllocatedMemorySupported": {
              "description": "ThreadAllocatedMemorySupported",
              "value": true
            },
            "ThreadContentionMonitoringEnabled": {
              "description": "ThreadContentionMonitoringEnabled",
              "value": false
            },
            "TotalStartedThreadCount": {
              "description": "TotalStartedThreadCount",
              "value": 16570
            },
            "CurrentThreadUserTime": {
              "description": "CurrentThreadUserTime",
              "value": 1800000000
            },
            "CurrentThreadCpuTimeSupported": {
              "description": "CurrentThreadCpuTimeSupported",
              "value": true
            },
            "AllThreadIds": {
              "description": "AllThreadIds",
              "value": [
                16581,
                16580,
                16549,
                16465,
                16333,
                16331,
                16330,
                15889,
                15463,
                15200,
                15197,
                15195,
                15059,
                14498,
                13033,
                12872,
                12817,
                11825,
                11806,
                3437,
                1768,
                742,
                128,
                127,
                126,
                123,
                122,
                121,
                120,
                115,
                114,
                113,
                112,
                111,
                102,
                98,
                97,
                95,
                94,
                93,
                90,
                87,
                85,
                84,
                82,
                76,
                75,
                73,
                71,
                70,
                69,
                67,
                65,
                64,
                63,
                62,
                61,
                60,
                59,
                58,
                57,
                56,
                14,
                55,
                54,
                53,
                48,
                47,
                46,
                45,
                44,
                43,
                42,
                41,
                27,
                19,
                26,
                25,
                24,
                23,
                22,
                21,
                20,
                40,
                34,
                36,
                35,
                33,
                32,
                31,
                30,
                29,
                28,
                18,
                15,
                13,
                12,
                5,
                3,
                2
              ]
            },
            "PeakThreadCount": {
              "description": "PeakThreadCount",
              "value": 227
            },
            "ThreadAllocatedMemoryEnabled": {
              "description": "ThreadAllocatedMemoryEnabled",
              "value": true
            },
            "CurrentThreadCpuTime": {
              "description": "CurrentThreadCpuTime",
              "value": 2347510977
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:type=Threading"
            },
            "ThreadCpuTimeSupported": {
              "description": "ThreadCpuTimeSupported",
              "value": true
            },
            "ThreadContentionMonitoringSupported": {
              "description": "ThreadContentionMonitoringSupported",
              "value": true
            },
            "ThreadCount": {
              "description": "ThreadCount",
              "value": 100
            },
            "ThreadCpuTimeEnabled": {
              "description": "ThreadCpuTimeEnabled",
              "value": true
            },
            "ObjectMonitorUsageSupported": {
              "description": "ObjectMonitorUsageSupported",
              "value": true
            },
            "SynchronizerUsageSupported": {
              "description": "SynchronizerUsageSupported",
              "value": true
            },
            "DaemonThreadCount": {
              "description": "DaemonThreadCount",
              "value": 62
            }
          }
        },
        {
          "name": "java.lang:type=OperatingSystem",
          "attributes": {
            "OpenFileDescriptorCount": {
              "description": "OpenFileDescriptorCount",
              "value": 954
            },
            "CommittedVirtualMemorySize": {
              "description": "CommittedVirtualMemorySize",
              "value": 17097699328
            },
            "FreePhysicalMemorySize": {
              "description": "FreePhysicalMemorySize",
              "value": 298102784
            },
            "SystemLoadAverage": {
              "description": "SystemLoadAverage",
              "value": 0.03
            },
            "Arch": {
              "description": "Arch",
              "value": "amd64"
            },
            "ProcessCpuLoad": {
              "description": "ProcessCpuLoad",
              "value": 0.11111111111111112
            },
            "TotalPhysicalMemorySize": {
              "description": "TotalPhysicalMemorySize",
              "value": 15762874368
            },
            "FreeSwapSpaceSize": {
              "description": "FreeSwapSpaceSize",
              "value": 0
            },
            "Name": {
              "description": "Name",
              "value": "Linux"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:type=OperatingSystem"
            },
            "TotalSwapSpaceSize": {
              "description": "TotalSwapSpaceSize",
              "value": 0
            },
            "ProcessCpuTime": {
              "description": "ProcessCpuTime",
              "value": 119643340000000
            },
            "MaxFileDescriptorCount": {
              "description": "MaxFileDescriptorCount",
              "value": 60000
            },
            "SystemCpuLoad": {
              "description": "SystemCpuLoad",
              "value": 0.08888888888888889
            },
            "Version": {
              "description": "Version",
              "value": "4.15.0-1017-gcp"
            },
            "AvailableProcessors": {
              "description": "AvailableProcessors",
              "value": 4
            }
          }
        },
        {
          "name": "java.lang:name=Code Cache,type=MemoryPool",
          "attributes": {
            "UsageThresholdCount": {
              "description": "UsageThresholdCount",
              "value": 0
            },
            "Usage": {
              "description": "Usage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 2555904,
                  "committed": 76283904,
                  "used": 75577280,
                  "max": 251658240
                }
              }
            },
            "MemoryManagerNames": {
              "description": "MemoryManagerNames",
              "value": [
                "CodeCacheManager"
              ]
            },
            "UsageThresholdSupported": {
              "description": "UsageThresholdSupported",
              "value": true
            },
            "UsageThreshold": {
              "description": "UsageThreshold",
              "value": 0
            },
            "CollectionUsageThresholdCount": {
              "description": "CollectionUsageThresholdCount",
              "value": null
            },
            "PeakUsage": {
              "description": "PeakUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 2555904,
                  "committed": 76283904,
                  "used": 75580288,
                  "max": 251658240
                }
              }
            },
            "UsageThresholdExceeded": {
              "description": "UsageThresholdExceeded",
              "value": false
            },
            "CollectionUsageThreshold": {
              "description": "CollectionUsageThreshold",
              "value": null
            },
            "Name": {
              "description": "Name",
              "value": "Code Cache"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=Code Cache,type=MemoryPool"
            },
            "Type": {
              "description": "Type",
              "value": "NON_HEAP"
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionUsageThresholdSupported": {
              "description": "CollectionUsageThresholdSupported",
              "value": false
            },
            "CollectionUsage": {
              "description": "CollectionUsage",
              "value": null
            },
            "CollectionUsageThresholdExceeded": {
              "description": "CollectionUsageThresholdExceeded",
              "value": null
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Primitive count",
          "attributes": {
            "NumberOfRelationshipIdsInUse": {
              "description": "An estimation of the number of relationships used in this Neo4j instance",
              "value": 4111389
            },
            "NumberOfPropertyIdsInUse": {
              "description": "An estimation of the number of properties used in this Neo4j instance",
              "value": 17122624
            },
            "NumberOfNodeIdsInUse": {
              "description": "An estimation of the number of nodes used in this Neo4j instance",
              "value": 9273411
            },
            "NumberOfRelationshipTypeIdsInUse": {
              "description": "The number of relationship types used in this Neo4j instance",
              "value": 66
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Memory Mapping",
          "attributes": {
            "MemoryPools": {
              "description": "Get information about each pool of memory mapped regions from store files with memory mapping enabled",
              "value": []
            }
          }
        },
        {
          "name": "java.nio:name=direct,type=BufferPool",
          "attributes": {
            "TotalCapacity": {
              "description": "TotalCapacity",
              "value": 8738348
            },
            "MemoryUsed": {
              "description": "MemoryUsed",
              "value": 8738349
            },
            "Count": {
              "description": "Count",
              "value": 66
            },
            "Name": {
              "description": "Name",
              "value": "direct"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.nio:name=direct,type=BufferPool"
            }
          }
        },
        {
          "name": "java.lang:type=Compilation",
          "attributes": {
            "TotalCompilationTime": {
              "description": "TotalCompilationTime",
              "value": 314804
            },
            "CompilationTimeMonitoringSupported": {
              "description": "CompilationTimeMonitoringSupported",
              "value": true
            },
            "Name": {
              "description": "Name",
              "value": "HotSpot 64-Bit Tiered Compilers"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:type=Compilation"
            }
          }
        },
        {
          "name": "java.lang:name=G1 Young Generation,type=GarbageCollector",
          "attributes": {
            "MemoryPoolNames": {
              "description": "MemoryPoolNames",
              "value": [
                "G1 Eden Space",
                "G1 Survivor Space"
              ]
            },
            "LastGcInfo": {
              "description": "LastGcInfo",
              "value": {
                "description": "CompositeType for GC info for G1 Young Generation",
                "properties": {
                  "duration": 93,
                  "memoryUsageBeforeGc": {
                    "[G1 Survivor Space]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 0,
                            "committed": 8388608,
                            "used": 8388608,
                            "max": -1
                          }
                        },
                        "key": "G1 Survivor Space"
                      }
                    },
                    "[Metaspace]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 0,
                            "committed": 114745344,
                            "used": 109039600,
                            "max": -1
                          }
                        },
                        "key": "Metaspace"
                      }
                    },
                    "[G1 Eden Space]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 226492416,
                            "committed": 2313158656,
                            "used": 2202009600,
                            "max": -1
                          }
                        },
                        "key": "G1 Eden Space"
                      }
                    },
                    "[Compressed Class Space]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 0,
                            "committed": 15945728,
                            "used": 14886928,
                            "max": 1073741824
                          }
                        },
                        "key": "Compressed Class Space"
                      }
                    },
                    "[G1 Old Gen]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 4068474880,
                            "committed": 1973420032,
                            "used": 1608169984,
                            "max": 4294967296
                          }
                        },
                        "key": "G1 Old Gen"
                      }
                    },
                    "[Code Cache]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 2555904,
                            "committed": 75759616,
                            "used": 75102784,
                            "max": 251658240
                          }
                        },
                        "key": "Code Cache"
                      }
                    }
                  },
                  "GcThreadCount": 10,
                  "startTime": 6324387939,
                  "endTime": 6324388032,
                  "id": 1357,
                  "memoryUsageAfterGc": {
                    "[G1 Survivor Space]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 0,
                            "committed": 8388608,
                            "used": 8388608,
                            "max": -1
                          }
                        },
                        "key": "G1 Survivor Space"
                      }
                    },
                    "[Metaspace]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 0,
                            "committed": 114745344,
                            "used": 109039600,
                            "max": -1
                          }
                        },
                        "key": "Metaspace"
                      }
                    },
                    "[G1 Eden Space]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 226492416,
                            "committed": 2313158656,
                            "used": 0,
                            "max": -1
                          }
                        },
                        "key": "G1 Eden Space"
                      }
                    },
                    "[Compressed Class Space]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 0,
                            "committed": 15945728,
                            "used": 14886928,
                            "max": 1073741824
                          }
                        },
                        "key": "Compressed Class Space"
                      }
                    },
                    "[G1 Old Gen]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 4068474880,
                            "committed": 1973420032,
                            "used": 1607123976,
                            "max": 4294967296
                          }
                        },
                        "key": "G1 Old Gen"
                      }
                    },
                    "[Code Cache]": {
                      "description": "Map<java.lang.String,java.lang.management.MemoryUsage>",
                      "properties": {
                        "value": {
                          "description": "java.lang.management.MemoryUsage",
                          "properties": {
                            "init": 2555904,
                            "committed": 75759616,
                            "used": 75102784,
                            "max": 251658240
                          }
                        },
                        "key": "Code Cache"
                      }
                    }
                  }
                }
              }
            },
            "CollectionTime": {
              "description": "CollectionTime",
              "value": 137404
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionCount": {
              "description": "CollectionCount",
              "value": 1357
            },
            "Name": {
              "description": "Name",
              "value": "G1 Young Generation"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=G1 Young Generation,type=GarbageCollector"
            }
          }
        },
        {
          "name": "java.lang:name=CodeCacheManager,type=MemoryManager",
          "attributes": {
            "MemoryPoolNames": {
              "description": "MemoryPoolNames",
              "value": [
                "Code Cache"
              ]
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "Name": {
              "description": "Name",
              "value": "CodeCacheManager"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=CodeCacheManager,type=MemoryManager"
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Index sampler",
          "attributes": {}
        },
        {
          "name": "java.lang:name=G1 Old Gen,type=MemoryPool",
          "attributes": {
            "UsageThresholdCount": {
              "description": "UsageThresholdCount",
              "value": 0
            },
            "Usage": {
              "description": "Usage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 4068474880,
                  "committed": 1973420032,
                  "used": 1607123976,
                  "max": 4294967296
                }
              }
            },
            "MemoryManagerNames": {
              "description": "MemoryManagerNames",
              "value": [
                "G1 Old Generation"
              ]
            },
            "UsageThresholdSupported": {
              "description": "UsageThresholdSupported",
              "value": true
            },
            "UsageThreshold": {
              "description": "UsageThreshold",
              "value": 0
            },
            "CollectionUsageThresholdCount": {
              "description": "CollectionUsageThresholdCount",
              "value": 0
            },
            "PeakUsage": {
              "description": "PeakUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 4068474880,
                  "committed": 4068474880,
                  "used": 2003827744,
                  "max": 4294967296
                }
              }
            },
            "UsageThresholdExceeded": {
              "description": "UsageThresholdExceeded",
              "value": false
            },
            "CollectionUsageThreshold": {
              "description": "CollectionUsageThreshold",
              "value": 0
            },
            "Name": {
              "description": "Name",
              "value": "G1 Old Gen"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=G1 Old Gen,type=MemoryPool"
            },
            "Type": {
              "description": "Type",
              "value": "HEAP"
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionUsageThresholdSupported": {
              "description": "CollectionUsageThresholdSupported",
              "value": true
            },
            "CollectionUsage": {
              "description": "CollectionUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 4068474880,
                  "committed": 0,
                  "used": 0,
                  "max": 4294967296
                }
              }
            },
            "CollectionUsageThresholdExceeded": {
              "description": "CollectionUsageThresholdExceeded",
              "value": false
            }
          }
        },
        {
          "name": "java.util.logging:type=Logging",
          "attributes": {
            "LoggerNames": {
              "description": "LoggerNames",
              "value": [
                "com.sun.jersey.server.impl.application.WebApplicationImpl",
                "javax.management.notification",
                "javax.management.timer",
                "com.sun.jersey.spi.inject.Errors",
                "com.sun.jersey.core.spi.component.ProviderServices",
                "com.sun.jersey.spi.container.ContainerResponse",
                "javax.management.modelmbean",
                "io.netty.channel.AbstractChannel",
                "com.sun.jersey.api.core.ResourceConfig",
                "com.sun.jersey.server.impl.application.ResourceMethodDispatcherFactory",
                "io.netty.util.concurrent.AbstractEventExecutor",
                "io.netty.util.NetUtil",
                "com.sun.jersey.server.impl.application.RootResourceUriRules",
                "io.netty.util.internal.PlatformDependent",
                "io.netty.util.internal.SystemPropertyUtil",
                "com.sun.jersey.server.impl.model.method.dispatch.MultipartFormDispatchProvider",
                "javax.management.mbeanserver",
                "io.netty.channel.socket.nio.NioServerSocketChannel",
                "io.netty.util.concurrent.SingleThreadEventExecutor",
                "io.netty.util.internal.PlatformDependent0",
                "com.sun.jersey.spi.service.ServiceFinder",
                "com.sun.jersey.core.impl.provider.entity.EntityHolderReader",
                "com.sun.jersey.server.impl.cdi.CDIComponentProviderFactoryInitializer",
                "global",
                "io.netty.util.ReferenceCountUtil",
                "com.sun.jersey.server.impl.resource.PerRequestFactory",
                "io.netty.channel.ChannelInitializer",
                "io.netty.util.internal.InternalThreadLocalMap",
                "com.sun.jersey.server.impl.managedbeans.ManagedBeanComponentProviderFactoryInitilizer",
                "io.netty.util.Recycler",
                "io.netty.util.concurrent.GlobalEventExecutor",
                "io.netty.channel.nio.NioEventLoop",
                "io.netty.channel.socket.nio.NioSocketChannel",
                "javax.management.snmp",
                "javax.management",
                "com.sun.jersey.server.impl.container.filter.FilterFactory",
                "io.netty.util.ResourceLeakDetector",
                "io.netty.util.concurrent.DefaultPromise",
                "io.netty.channel.MultithreadEventLoopGroup",
                "javax.management.misc",
                "io.netty.channel.AbstractChannelHandlerContext",
                "io.netty.buffer.ByteBufUtil",
                "com.sun.jersey.server.impl.wadl.WadlFactory",
                "io.netty.channel.DefaultChannelId",
                "javax.management.monitor",
                "io.netty.channel.DefaultChannelPipeline",
                "io.netty.buffer.PooledByteBufAllocator",
                "io.netty.bootstrap.Bootstrap",
                "io.netty.bootstrap.ServerBootstrap",
                "javax.management.mlet",
                "io.netty.util.concurrent.DefaultPromise.rejectedExecution",
                "com.github.benmanes.caffeine.cache.BoundedLocalCache",
                "com.github.benmanes.caffeine.cache.Caffeine",
                "com.sun.jersey.core.reflection.ReflectionHelper",
                "io.netty.resolver.AddressResolverGroup",
                "com.sun.jersey.server.impl.ejb.EJBComponentProviderFactoryInitilizer",
                "io.netty.util.ResourceLeakDetectorFactory",
                "com.sun.jersey.server.impl.modelapi.annotation.IntrospectionModeller",
                "javax.management.relation",
                "io.netty.util.internal.CleanerJava6",
                "com.sun.jersey.spi.container.servlet.WebComponent",
                "com.sun.jersey.server.impl.application.CloseableServiceFactory",
                "com.sun.jersey.core.impl.provider.xml.DocumentBuilderFactoryProvider",
                "io.netty.util.internal.MacAddressUtil",
                "javax.management.snmp.daemon",
                "io.netty.buffer.AbstractByteBuf",
                "io.netty.handler.stream.ChunkedWriteHandler",
                "io.netty.buffer.PoolThreadCache",
                "sun.net.www.protocol.http.HttpURLConnection",
                "io.netty.channel.nio.AbstractNioChannel",
                "com.sun.jersey.spi.container.ContainerRequest",
                "com.sun.jersey.core.spi.component.ProviderFactory",
                "io.netty.channel.ChannelOutboundBuffer",
                "com.sun.jersey.server.impl.monitoring.GlassFishMonitoringInitializer",
                ""
              ]
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.util.logging:type=Logging"
            }
          }
        },
        {
          "name": "java.lang:name=G1 Old Generation,type=GarbageCollector",
          "attributes": {
            "MemoryPoolNames": {
              "description": "MemoryPoolNames",
              "value": [
                "G1 Eden Space",
                "G1 Survivor Space",
                "G1 Old Gen"
              ]
            },
            "LastGcInfo": {
              "description": "LastGcInfo",
              "value": null
            },
            "CollectionTime": {
              "description": "CollectionTime",
              "value": 0
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionCount": {
              "description": "CollectionCount",
              "value": 0
            },
            "Name": {
              "description": "Name",
              "value": "G1 Old Generation"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=G1 Old Generation,type=GarbageCollector"
            }
          }
        },
        {
          "name": "java.lang:type=ClassLoading",
          "attributes": {
            "LoadedClassCount": {
              "description": "LoadedClassCount",
              "value": 20468
            },
            "UnloadedClassCount": {
              "description": "UnloadedClassCount",
              "value": 346
            },
            "Verbose": {
              "description": "Verbose",
              "value": false
            },
            "TotalLoadedClassCount": {
              "description": "TotalLoadedClassCount",
              "value": 20814
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:type=ClassLoading"
            }
          }
        },
        {
          "name": "java.lang:name=Metaspace Manager,type=MemoryManager",
          "attributes": {
            "MemoryPoolNames": {
              "description": "MemoryPoolNames",
              "value": [
                "Metaspace",
                "Compressed Class Space"
              ]
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "Name": {
              "description": "Name",
              "value": "Metaspace Manager"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=Metaspace Manager,type=MemoryManager"
            }
          }
        },
        {
          "name": "java.lang:name=G1 Survivor Space,type=MemoryPool",
          "attributes": {
            "UsageThresholdCount": {
              "description": "UsageThresholdCount",
              "value": null
            },
            "Usage": {
              "description": "Usage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 8388608,
                  "used": 8388608,
                  "max": -1
                }
              }
            },
            "MemoryManagerNames": {
              "description": "MemoryManagerNames",
              "value": [
                "G1 Old Generation",
                "G1 Young Generation"
              ]
            },
            "UsageThresholdSupported": {
              "description": "UsageThresholdSupported",
              "value": false
            },
            "UsageThreshold": {
              "description": "UsageThreshold",
              "value": null
            },
            "CollectionUsageThresholdCount": {
              "description": "CollectionUsageThresholdCount",
              "value": 0
            },
            "PeakUsage": {
              "description": "PeakUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 159383552,
                  "used": 159383552,
                  "max": -1
                }
              }
            },
            "UsageThresholdExceeded": {
              "description": "UsageThresholdExceeded",
              "value": null
            },
            "CollectionUsageThreshold": {
              "description": "CollectionUsageThreshold",
              "value": 0
            },
            "Name": {
              "description": "Name",
              "value": "G1 Survivor Space"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=G1 Survivor Space,type=MemoryPool"
            },
            "Type": {
              "description": "Type",
              "value": "HEAP"
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionUsageThresholdSupported": {
              "description": "CollectionUsageThresholdSupported",
              "value": true
            },
            "CollectionUsage": {
              "description": "CollectionUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 8388608,
                  "used": 8388608,
                  "max": -1
                }
              }
            },
            "CollectionUsageThresholdExceeded": {
              "description": "CollectionUsageThresholdExceeded",
              "value": false
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Transactions",
          "attributes": {
            "NumberOfRolledBackTransactions": {
              "description": "The total number of rolled back transactions",
              "value": 126
            },
            "LastCommittedTxId": {
              "description": "The id of the latest committed transaction",
              "value": 541593
            },
            "NumberOfOpenTransactions": {
              "description": "The number of currently open transactions",
              "value": 1
            },
            "NumberOfOpenedTransactions": {
              "description": "The total number started transactions",
              "value": 3945447
            },
            "PeakNumberOfConcurrentTransactions": {
              "description": "The highest number of transactions ever opened concurrently",
              "value": 97
            },
            "NumberOfCommittedTransactions": {
              "description": "The total number of committed transactions",
              "value": 3945320
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Store file sizes",
          "attributes": {
            "LogicalLogSize": {
              "description": "The amount of disk space used by the current Neo4j logical log, in bytes.",
              "value": 243711119
            },
            "StringStoreSize": {
              "description": "The amount of disk space used to store string properties, in bytes.",
              "value": 523640832
            },
            "ArrayStoreSize": {
              "description": "The amount of disk space used to store array properties, in bytes.",
              "value": 10982948864
            },
            "RelationshipStoreSize": {
              "description": "The amount of disk space used to store relationships, in bytes.",
              "value": 145035840
            },
            "PropertyStoreSize": {
              "description": "The amount of disk space used to store properties (excluding string values and array values), in bytes.",
              "value": 702032996
            },
            "NodeStoreSize": {
              "description": "The amount of disk space used to store nodes, in bytes.",
              "value": 139107150
            },
            "TotalStoreSize": {
              "description": "The total disk space used by this Neo4j instance, in bytes.",
              "value": 13130938520
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Diagnostics",
          "attributes": {
            "DiagnosticsProviders": {
              "description": "A list of the ids for the registered diagnostics providers.",
              "value": null
            }
          }
        },
        {
          "name": "org.neo4j.ServerManagement:restartServer=lifecycle",
          "attributes": {}
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Locking",
          "attributes": {
            "NumberOfAvertedDeadlocks": {
              "description": "The number of lock sequences that would have lead to a deadlock situation that Neo4j has detected and averted (by throwing DeadlockDetectedException).",
              "value": -1
            },
            "Locks": {
              "description": "Information about all locks held by Neo4j",
              "value": []
            }
          }
        },
        {
          "name": "java.lang:name=Metaspace,type=MemoryPool",
          "attributes": {
            "UsageThresholdCount": {
              "description": "UsageThresholdCount",
              "value": 0
            },
            "Usage": {
              "description": "Usage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 114745344,
                  "used": 109097408,
                  "max": -1
                }
              }
            },
            "MemoryManagerNames": {
              "description": "MemoryManagerNames",
              "value": [
                "Metaspace Manager"
              ]
            },
            "UsageThresholdSupported": {
              "description": "UsageThresholdSupported",
              "value": true
            },
            "UsageThreshold": {
              "description": "UsageThreshold",
              "value": 0
            },
            "CollectionUsageThresholdCount": {
              "description": "CollectionUsageThresholdCount",
              "value": null
            },
            "PeakUsage": {
              "description": "PeakUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 114745344,
                  "used": 109097408,
                  "max": -1
                }
              }
            },
            "UsageThresholdExceeded": {
              "description": "UsageThresholdExceeded",
              "value": false
            },
            "CollectionUsageThreshold": {
              "description": "CollectionUsageThreshold",
              "value": null
            },
            "Name": {
              "description": "Name",
              "value": "Metaspace"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=Metaspace,type=MemoryPool"
            },
            "Type": {
              "description": "Type",
              "value": "NON_HEAP"
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionUsageThresholdSupported": {
              "description": "CollectionUsageThresholdSupported",
              "value": false
            },
            "CollectionUsage": {
              "description": "CollectionUsage",
              "value": null
            },
            "CollectionUsageThresholdExceeded": {
              "description": "CollectionUsageThresholdExceeded",
              "value": null
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Reports",
          "attributes": {
            "EnvironmentVariables": {
              "description": "Returns a map if the current environment variables",
              "value": "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nNEO4J_CONF=/etc/neo4j\ndbms_directories_metrics=/var/lib/neo4j/metrics\ndbms_security_procedures_unrestricted=\"apoc.*,algo.*\"\ncausal_clustering_transaction_advertised_address=10.142.0.5:6000\ncausal_clustering_expected_core_cluster_size=3 3\nLOGNAME=neo4j\ndbms_backup_enabled=true true\ndbms_security_auth_enabled=true\nPWD=/\ndbms_logs_security_level=INFO INFO\ndbms_directories_logs=/var/log/neo4j\ndbms_connectors_default_listen_address=0.0.0.0 0.0.0.0\nSHELL=/bin/bash\ndbms_connector_https_listen_address=0.0.0.0:7473 0.0.0.0:7473\nha_pull_interval=10\ndbms_connector_bolt_tls_level=REQUIRED REQUIRED\nINTERNAL_IP_ADDR=10.142.0.5\ncausal_clustering_raft_advertised_address=10.142.0.5:7000\ndbms_ssl_policy_default_allow_key_generation=false\ndbms_connector_bolt_enabled=true true\ndbms_allow_upgrade=true\ndbms_ssl_policy_default_base_directory=/var/lib/neo4j/certificates\nINTERNAL_HOSTNAME=meetup-cluster-core-vm-3.c.testbed-187316.internal\ncausal_clustering_initial_discovery_members=meetup-cluster-core-vm-1:5000,meetup-cluster-core-vm-2:5000,meetup-cluster-core-vm-3:5000 meetup-cluster-core-vm-1:5000,meetup-cluster-core-vm-2:5000,meetup-cluster-core-vm-3:5000\nSHLVL=1\ndbms_connector_bolt_listen_address=0.0.0.0:7687 0.0.0.0:7687\ndbms_ssl_policy_default_client_auth=NONE\ndbms_connectors_default_advertised_address=node3.cluster.graph.center\ndbms_connector_https_enabled=true true\ndbms_connector_http_listen_address=0.0.0.0:7474 0.0.0.0:7474\ncausal_clustering_discovery_type=LIST LIST\nNEO4J_HOME=/var/lib/neo4j\ndbms_memory_pagecache_size=8g\ndbms_jvm_additional=-XX:+UseG1GC -XX:-OmitStackTraceInFastThrow -XX:+AlwaysPreTouch -XX:+UnlockExperimentalVMOptions -XX:+TrustFinalNonStaticFields -XX:+DisableExplicitGC -Djdk.tls.ephemeralDHKeySize=2048 -Djdk.tls.rejectClientInitiatedRenegotiation=true -Dunsupported.dbms.udc.source=gcloud-CORE\nbolt_ssl_policy=default\ndbms_logs_http_enabled=false false\nLANG=en_US.UTF-8\ndbms_windows_service_name=neo4j\ncausal_clustering_discovery_listen_address=0.0.0.0:5000 0.0.0.0:5000\ndbms_backup_address=localhost:6362 localhost:6362\ndbms_directories_data=/var/lib/neo4j/data\ndbms_connector_http_enabled=true true\nEXTERNAL_IP_ADDR=35.185.85.173\ndbms_directories_certificates=/var/lib/neo4j/certificates\nINSTANCE_API=http://metadata.google.internal/computeMetadata/v1/instance\ndbms_ssl_policy_default_private_key=/var/lib/neo4j/certificates/neo4j.key\ndbms_logs_gc_enabled=false false\ndbms_ssl_policy_default_revoked_dir=/var/lib/neo4j/certificates/revoked\nUSER=neo4j\ndbms_security_allow_csv_import_from_file_urls=true true\ndbms_ssl_policy_default_public_certificate=/var/lib/neo4j/certificates/neo4j.cert\ndbms_directories_run=/var/run/neo4j\ndbms_directories_import=/var/lib/neo4j/import\ndbms_directories_plugins=/var/lib/neo4j/plugins\ndbms_memory_heap_max_size=4g\ndbms_directories_lib=/usr/share/neo4j/lib\ndbms_memory_heap_initial_size=4g\nHOME=/var/lib/neo4j\ndbms_mode=CORE CORE\n"
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Page cache",
          "attributes": {
            "Hits": {
              "description": "Number of page hits. How often requested data was found in memory.",
              "value": 107725469438
            },
            "FileUnmappings": {
              "description": "Number of files that have been unmapped from the page cache.",
              "value": 177
            },
            "FileMappings": {
              "description": "Number of files that have been mapped into the page cache.",
              "value": 276
            },
            "Faults": {
              "description": "Number of page faults. How often requested data was not found in memory and had to be loaded.",
              "value": 1501813
            },
            "EvictionExceptions": {
              "description": "Number of exceptions caught during page eviction. This number should be zero, or at least not growing, in a healthy database. Otherwise it could indicate drive failure, storage space, or permission problems.",
              "value": 0
            },
            "BytesWritten": {
              "description": "Number of bytes written to durable storage.",
              "value": 5017963416
            },
            "Flushes": {
              "description": "Number of page flushes. How many dirty pages have been written to durable storage.",
              "value": 44731
            },
            "UsageRatio": {
              "description": "The percentage of used pages. Will return NaN if it cannot be determined.",
              "value": 0.9997185242629213
            },
            "Unpins": {
              "description": "Number of page unpins. How many pages have been accessed and are not accessed anymore (monitoring must be enabled separately).",
              "value": 107726935002
            },
            "Evictions": {
              "description": "Number of page evictions. How many pages have been removed from memory to make room for other pages.",
              "value": 457612
            },
            "BytesRead": {
              "description": "Number of bytes read from durable storage.",
              "value": 8073894993
            },
            "Pins": {
              "description": "Number of page pins. How many pages have been accessed (monitoring must be enabled separately).",
              "value": 142301646463
            },
            "HitRatio": {
              "description": "Ratio of hits to the total number of lookups in the page cache",
              "value": 0.9999860590808174
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Store sizes",
          "attributes": {
            "CountStoreSize": {
              "description": "Disk space used to store counters, in bytes",
              "value": 12000
            },
            "LabelStoreSize": {
              "description": "Disk space used to store labels, in bytes",
              "value": 89908
            },
            "IndexStoreSize": {
              "description": "Disk space used to store all indices, in bytes",
              "value": 130468979
            },
            "StringStoreSize": {
              "description": "Disk space used to store string properties, in bytes.",
              "value": 523640841
            },
            "ArrayStoreSize": {
              "description": "Disk space used to store array properties, in bytes.",
              "value": 10982948873
            },
            "RelationshipStoreSize": {
              "description": "Disk space used to store relationships, in bytes.",
              "value": 146382991
            },
            "PropertyStoreSize": {
              "description": "Disk space used to store properties (excluding string values and array values), in bytes.",
              "value": 702122913
            },
            "TransactionLogsSize": {
              "description": "Disk space used by the transaction logs, in bytes.",
              "value": 505861828
            },
            "SchemaStoreSize": {
              "description": "Disk space used to store schemas (index and constrain declarations), in bytes",
              "value": 204809
            },
            "NodeStoreSize": {
              "description": "Disk space used to store nodes, in bytes.",
              "value": 139115360
            },
            "TotalStoreSize": {
              "description": "Disk space used by whole store, in bytes.",
              "value": 13130938520
            }
          }
        },
        {
          "name": "org.neo4j:instance=kernel#0,name=Configuration",
          "attributes": {
            "metrics.neo4j.server.enabled": {
              "description": "Enable reporting metrics about Server threading info.",
              "value": "true"
            },
            "unsupported.dbms.index.archive_failed": {
              "description": "Create an archive of an index before re-creating it if failing to load on startup.",
              "value": "false"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84-3d.z.max": {
              "description": "The maximum z value for the index extents for 3D wgs-84-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "1000000.0"
            },
            "metrics.graphite.server": {
              "description": "The hostname or IP address of the Graphite server",
              "value": ":2003"
            },
            "unsupported.ha.cluster_name": {
              "description": "The name of a cluster.",
              "value": "neo4j.ha"
            },
            "unsupported.dbms.db.spatial.crs.cartesian-3d.y.min": {
              "description": "The minimum y value for the index extents for 3D cartesian-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-1000000.0"
            },
            "unsupported.dbms.max_http_request_header_size": {
              "description": "Maximum request header size",
              "value": "20480"
            },
            "causal_clustering.discovery_resolution_timeout": {
              "description": "Configures the time after which we give up trying to resolve a DNS/SRV record into a list of initial discovery members.",
              "value": "300000ms"
            },
            "tools.consistency_checker.check_graph": {
              "description": "This setting is deprecated. See commandline arguments for neoj4-admin check-consistency instead. Perform checks between nodes, relationships, properties, types and tokens.",
              "value": "true"
            },
            "dbms.memory.heap.initial_size": {
              "description": "Initial heap size. By default it is calculated based on available system resources.",
              "value": "4g"
            },
            "dbms.ssl.policy.<policyname>.base_directory": {
              "description": "The mandatory base directory for cryptographic objects of this policy. It is also possible to override each individual configuration with absolute paths.",
              "value": null
            },
            "dbms.security.auth_provider": {
              "description": "The authentication and authorization provider that contains both the users and roles. This can be one of the built-in `native` or `ldap` providers, or it can be an externally provided plugin, with a custom name prefixed by `plugin-`, i.e. `plugin-<AUTH_PROVIDER_NAME>`. ",
              "value": "native"
            },
            "dbms.checkpoint.interval.tx": {
              "description": "Configures the transaction interval between check-points. The database will not check-point more often  than this (unless check pointing is triggered by a different event), but might check-point less often than this interval, if performing a check-point takes longer time than the configured interval. A check-point is a point in the transaction logs, from which recovery would start from. Longer check-point intervals typically means that recovery will take longer to complete in case of a crash. On the other hand, a longer check-point interval can also reduce the I/O load that the database places on the system, as each check-point implies a flushing and forcing of all the store files.  The default is '100000' for a check-point every 100000 transactions.",
              "value": "100000"
            },
            "hazelcast.license_key": {
              "description": "Hazelcast license key",
              "value": null
            },
            "ha.join_timeout": {
              "description": "Timeout for joining a cluster. Defaults to ha.broadcast_timeout. Note that if the timeout expires during cluster formation, the operator may have to restart the instance or instances.",
              "value": "30000ms"
            },
            "ha.configuration_timeout": {
              "description": "Timeout for waiting for configuration from an existing cluster member during cluster join.",
              "value": "1000ms"
            },
            "dbms.memory.pagecache.swapper": {
              "description": "Specify which page swapper to use for doing paged IO. This is only used when integrating with proprietary storage technology.",
              "value": null
            },
            "causal_clustering.relationship_group_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP_GROUP IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "ha.host.coordination": {
              "description": "Host and port to bind the cluster management communication.",
              "value": "0.0.0.0:5001-5099"
            },
            "causal_clustering.minimum_core_cluster_size_at_formation": {
              "description": "Minimum number of Core machines in the cluster at formation. The expected_core_cluster size setting is used when bootstrapping the cluster on first formation. A cluster will not form without the configured amount of cores and this should in general be configured to the full and fixed amount. When using multi-clustering (configuring multiple distinct database names across core hosts), this setting is used to define the minimum size of *each* sub-cluster at formation.",
              "value": "3"
            },
            "dbms.query_cache_size": {
              "description": "The number of Cypher query execution plans that are cached.",
              "value": "1000"
            },
            "ha.allow_init_cluster": {
              "description": "Whether to allow this instance to create a cluster if unable to join.",
              "value": "true"
            },
            "bolt.ssl_policy": {
              "description": "Specify the SSL policy to use for the encrypted bolt connections.",
              "value": "default"
            },
            "metrics.jvm.memory.enabled": {
              "description": "Enable reporting metrics about the memory usage.",
              "value": "true"
            },
            "metrics.neo4j.pagecache.enabled": {
              "description": "Enable reporting metrics about the Neo4j page cache; page faults, evictions, flushes, exceptions, etc.",
              "value": "true"
            },
            "dbms.security.procedures.default_allowed": {
              "description": "The default role that can execute all procedures and user-defined functions that are not covered by the `dbms.security.procedures.roles` setting. If the `dbms.security.procedures.default_allowed` setting is the empty string (default), procedures will be executed according to the same security rules as normal Cypher statements.\n\nDeprecated: This will be replaced by dynamic configuration in the system graph in 4.0, including a migration step for the existing setting value.",
              "value": ""
            },
            "dbms.connector.bolt.listen_address": {
              "description": "Address the connector should bind to.",
              "value": "0.0.0.0:7687"
            },
            "unsupported.dbms.counts_store_rotation_timeout": {
              "description": "Maximum time to wait for active transaction completion when rotating counts store",
              "value": "600000ms"
            },
            "causal_clustering.cluster_allow_reads_on_followers": {
              "description": "Configure if the `dbms.cluster.routing.getServers()` procedure should include followers as read endpoints or return only read replicas. Note: if there are no read replicas in the cluster, followers are returned as read end points regardless the value of this setting. Defaults to true so that followers are available for read-only queries in a typical heterogeneous setup.",
              "value": "true"
            },
            "causal_clustering.raft_log_implementation": {
              "description": "RAFT log implementation",
              "value": "SEGMENTED"
            },
            "unsupported.dbms.uris.rest": {
              "description": "Configuration attribute",
              "value": "/db/data"
            },
            "causal_clustering.multi_dc_license": {
              "description": "Enable multi-data center features. Requires appropriate licensing.",
              "value": "false"
            },
            "dbms.db.timezone": {
              "description": "Database timezone. Among other things, this setting influences which timezone the logs and monitoring procedures use.",
              "value": "UTC"
            },
            "dbms.logs.debug.path": {
              "description": "Path to the debug log file.",
              "value": "/var/log/neo4j/debug.log"
            },
            "dbms.connector.bolt.enabled": {
              "description": "Enable this connector.",
              "value": "true"
            },
            "unsupported.dbms.logs.debug.debug_loggers": {
              "description": "Debug log contexts that should output debug level logging",
              "value": "[org.neo4j.diagnostics, org.neo4j.cluster.protocol, org.neo4j.kernel.ha]"
            },
            "dbms.logs.query.parameter_logging_enabled": {
              "description": "Log parameters for the executed queries being logged.",
              "value": "true"
            },
            "dbms.auto_index.nodes.enabled": {
              "description": "Controls the auto indexing feature for nodes. Setting it to `false` shuts it down, while `true` enables it by default for properties listed in the dbms.auto_index.nodes.keys setting.",
              "value": "false"
            },
            "unsupported.cypher.idp_solver_duration_threshold": {
              "description": "To improve IDP query planning time, we can restrict the internal planning loop duration, triggering more frequent compaction of candidate plans. The smaller the threshold the faster the planning, but the higher the risk of sub-optimal plans.",
              "value": "1000"
            },
            "unsupported.dbms.multi_threaded_schema_index_population_enabled": {
              "description": "Configuration attribute",
              "value": "true"
            },
            "dbms.relationship_grouping_threshold": {
              "description": "Relationship count threshold for considering a node to be dense",
              "value": "50"
            },
            "causal_clustering.load_balancing.shuffle": {
              "description": "Enables shuffling of the returned load balancing result.",
              "value": "true"
            },
            "unsupported.dbms.db.spatial.crs.cartesian.y.min": {
              "description": "The minimum y value for the index extents for 2D cartesian spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-1000000.0"
            },
            "dbms.logs.user.stdout_enabled": {
              "description": "Send user logs to the process stdout. If this is disabled then logs will instead be sent to the file _neo4j.log_ located in the logs directory. For location of the Logs directory, see <<file-locations>>.",
              "value": "true"
            },
            "dbms.security.ldap.authorization.group_membership_attributes": {
              "description": "A list of attribute names on a user object that contains groups to be used for mapping to roles when LDAP authorization is enabled.",
              "value": "[memberOf]"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84.y.min": {
              "description": "The minimum y value for the index extents for 2D wgs-84 spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-90.0"
            },
            "cypher.default_language_version": {
              "description": "Set this to specify the default parser (language version).",
              "value": "default"
            },
            "unsupported.dbms.uris.browser": {
              "description": "Configuration attribute",
              "value": "/browser/"
            },
            "causal_clustering.middleware.akka.failure_detector.threshold": {
              "description": "Akka cluster phi accrual failure detector. Defines the failure detector threshold. A low threshold is prone to generate many wrong suspicions but ensures a quick detection in the event of a real crash. Conversely, a high threshold generates fewer mistakes but needs more time to detect actual crashes.",
              "value": "10.0"
            },
            "causal_clustering.minimum_core_cluster_size_at_runtime": {
              "description": "Minimum number of Core machines required to be available at runtime. The consensus group size (core machines successfully voted into the Raft) can shrink and grow dynamically but bounded on the lower end at this number. The intention is in almost all cases for users to leave this setting alone. If you have 5 machines then you can survive failures down to 3 remaining, e.g. with 2 dead members. The three remaining can still vote another replacement member in successfully up to a total of 6 (2 of which are still dead) and then after this, one of the superfluous dead members will be immediately and automatically voted out (so you are left with 5 members in the consensus group, 1 of which is currently dead). Operationally you can now bring the last machine up by bringing in another replacement or repairing the dead one. When using multi-clustering (configuring multiple distinct database names across core hosts), this setting is used to define the minimum size of *each* sub-cluster at runtime.",
              "value": "3"
            },
            "dbms.logs.debug.rotation.keep_number": {
              "description": "Maximum number of history files for the debug log.",
              "value": "7"
            },
            "causal_clustering.raft_in_queue_size": {
              "description": "Maximum number of entries in the RAFT in-queue",
              "value": "1024"
            },
            "https.ssl_policy": {
              "description": "SSL policy name.",
              "value": "legacy"
            },
            "causal_clustering.neostore_block_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of NEOSTORE_BLOCK IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "dbms.lock.acquisition.timeout": {
              "description": "The maximum time interval within which lock should be acquired.",
              "value": "0ms"
            },
            "ha.broadcast_timeout": {
              "description": "Timeout for broadcasting values in cluster. Must consider end-to-end duration of Paxos algorithm. This value is the default value for the ha.join_timeout and ha.leave_timeout settings.",
              "value": "30000ms"
            },
            "unsupported.dbms.record_id_batch_size": {
              "description": "Specifies the size of id batches local to each transaction when committing. Committing a transaction which contains changes most often results in new data records being created. For each record a new id needs to be generated from an id generator. It's more efficient to allocate a batch of ids from the contended id generator, which the transaction holds and generates ids from while creating these new records. This setting specifies how big those batches are. Remaining ids are freed back to id generator on clean shutdown.",
              "value": "20"
            },
            "metrics.graphite.enabled": {
              "description": "Set to `true` to enable exporting metrics to Graphite.",
              "value": "false"
            },
            "dbms.security.ldap.authorization.user_search_base": {
              "description": "The name of the base object or named context to search for user objects when LDAP authorization is enabled. A common case is that this matches the last part of `dbms.security.ldap.authentication.user_dn_template`.",
              "value": "ou=users,dc=example,dc=com"
            },
            "ha.pull_batch_size": {
              "description": "Size of batches of transactions applied on slaves when pulling from master",
              "value": "100"
            },
            "causal_clustering.label_token_name_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of LABEL_TOKEN_NAME IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "metrics.cypher.replanning.enabled": {
              "description": "Enable reporting metrics about number of occurred replanning events.",
              "value": "true"
            },
            "dbms.logs.query.time_logging_enabled": {
              "description": "Log detailed time information for the executed queries being logged. Requires `dbms.track_query_cpu_time=true`",
              "value": "false"
            },
            "unsupported.dbms.id_generator_fast_rebuild_enabled": {
              "description": "Use a quick approach for rebuilding the ID generators. This give quicker recovery time, but will limit the ability to reuse the space of deleted entities.",
              "value": "true"
            },
            "unsupported.dbms.block_size.array_properties": {
              "description": "Specifies the block size for storing arrays. This parameter is only honored when the store is created, otherwise it is ignored. Also note that each block carries a ~10B of overhead so record size on disk will be slightly larger than the configured block size",
              "value": "120"
            },
            "dbms.import.csv.buffer_size": {
              "description": "The size of the internal buffer in bytes used by `LOAD CSV`. If the csv file contains huge fields this value may have to be increased.",
              "value": "2097152"
            },
            "dbms.ssl.policy.<policyname>.verify_hostname": {
              "description": "When true, this node will verify the hostname of every other instance it connects to by comparing the address it used to connect with it and the patterns described in the remote hosts public certificate Subject Alternative Names",
              "value": "false"
            },
            "causal_clustering.raft_membership_state_size": {
              "description": "The maximum file size before the membership state file is rotated (in unit of entries)",
              "value": "1000"
            },
            "causal_clustering.handshake_timeout": {
              "description": "Time out for protocol negotiation handshake",
              "value": "20000ms"
            },
            "causal_clustering.middleware.akka.sink-parallelism": {
              "description": "Parallelism level of dispatcher used for communication from Akka based cluster topology discovery ",
              "value": "2"
            },
            "dbms.security.procedures.whitelist": {
              "description": "A list of procedures (comma separated) that are to be loaded. The list may contain both fully-qualified procedure names, and partial names with the wildcard '*'. If this setting is left empty no procedures will be loaded.",
              "value": "*"
            },
            "dbms.security.auth_max_failed_attempts": {
              "description": "The maximum number of unsuccessful authentication attempts before imposing a user lock for the configured amount of time.The locked out user will not be able to log in until the lock period expires, even if correct credentials are provided. Setting this configuration option to values less than 3 is not recommended because it might make it easier for an attacker to brute force the password.",
              "value": "3"
            },
            "dbms.security.ldap.authorization.use_system_account": {
              "description": "Perform LDAP search for authorization info using a system account instead of the user's own account.\n\nIf this is set to `false` (default), the search for group membership will be performed directly after authentication using the LDAP context bound with the user's own account. The mapped roles will be cached for the duration of `dbms.security.auth_cache_ttl`, and then expire, requiring re-authentication. To avoid frequently having to re-authenticate sessions you may want to set a relatively long auth cache expiration time together with this option. NOTE: This option will only work if the users are permitted to search for their own group membership attributes in the directory.\n\nIf this is set to `true`, the search will be performed using a special system account user with read access to all the users in the directory. You need to specify the username and password using the settings `dbms.security.ldap.authorization.system_username` and `dbms.security.ldap.authorization.system_password` with this option. Note that this account only needs read access to the relevant parts of the LDAP directory and does not need to have access rights to Neo4j, or any other systems.",
              "value": "false"
            },
            "metrics.prometheus.endpoint": {
              "description": "The hostname and port to use as Prometheus endpoint",
              "value": "localhost:2004"
            },
            "dbms.security.property_level.blacklist": {
              "description": "An authorization mapping for property level access for roles. The map should be formatted as a semicolon separated list of key-value pairs, where the key is the role name and the value is a comma separated list of blacklisted properties. For example: role1=prop1;role2=prop2;role3=prop3,prop4,prop5\n\nYou could also use whitespaces and quotes around group names to make this mapping more readable, for example: dbms.security.property_level.blacklist=\\\n         \"role1\"      = ssn;    \\\n         \"role2\"      = ssn,income; \\\n\nDeprecated: This will be replaced by dynamic configuration in the system graph in 4.0, including a migration step for the existing setting value.",
              "value": null
            },
            "dbms.checkpoint.iops.limit": {
              "description": "Limit the number of IOs the background checkpoint process will consume per second. This setting is advisory, is ignored in Neo4j Community Edition, and is followed to best effort in Enterprise Edition. An IO is in this case a 8 KiB (mostly sequential) write. Limiting the write IO in this way will leave more bandwidth in the IO subsystem to service random-read IOs, which is important for the response time of queries when the database cannot fit entirely in memory. The only drawback of this setting is that longer checkpoint times may lead to slightly longer recovery times in case of a database or system crash. A lower number means lower IO pressure, and consequently longer checkpoint times. The configuration can also be commented out to remove the limitation entirely, and let the checkpointer flush data as fast as the hardware will go. Set this to -1 to disable the IOPS limit.",
              "value": "300"
            },
            "unsupported.dbms.memory.pagecache.warmup.profile.interval": {
              "description": "The profiling frequency for the page cache. Accurate profiles allow the page cache to do active warmup after a restart, reducing the mean time to performance. This feature available in Neo4j Enterprise Edition.",
              "value": "60000ms"
            },
            "dbms.transaction.timeout": {
              "description": "The maximum time interval of a transaction within which it should be completed.",
              "value": "0ms"
            },
            "dbms.logs.gc.options": {
              "description": "GC Logging Options",
              "value": "-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintPromotionFailure -XX:+PrintTenuringDistribution"
            },
            "causal_clustering.read_replica_time_to_live": {
              "description": "Time To Live before read replica is considered unavailable",
              "value": "60000ms"
            },
            "unsupported.dbms.transaction_start_timeout": {
              "description": "The maximum amount of time to wait for the database to become available, when starting a new transaction.",
              "value": "1000ms"
            },
            "causal_clustering.middleware.akka.failure_detector.min_std_deviation": {
              "description": "Akka cluster phi accrual failure detector. Minimum standard deviation to use for the normal distribution in AccrualFailureDetector. Too low standard deviation might result in too much sensitivity for sudden, but normal, deviations in heartbeat inter arrival times.",
              "value": "100ms"
            },
            "dbms.connector.bolt.tls_level": {
              "description": "Encryption level to require this connector to use.",
              "value": "REQUIRED"
            },
            "metrics.neo4j.tx.enabled": {
              "description": "Enable reporting metrics about transactions; number of transactions started, committed, etc.",
              "value": "true"
            },
            "unsupported.dbms.db.spatial.crs.cartesian-3d.x.min": {
              "description": "The minimum x value for the index extents for 3D cartesian-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-1000000.0"
            },
            "causal_clustering.cluster_binding_timeout": {
              "description": "Configures the time after which we give up trying to bind to a cluster formed of the other initial discovery members.",
              "value": "300000ms"
            },
            "dbms.security.ha_status_auth_enabled": {
              "description": "Require authorization for access to the HA status endpoints.",
              "value": "true"
            },
            "dbms.security.procedures.unrestricted": {
              "description": "A list of procedures and user defined functions (comma separated) that are allowed full access to the database. The list may contain both fully-qualified procedure names, and partial names with the wildcard '*'. Note that this enables these procedures to bypass security. Use with caution.",
              "value": "\"apoc.*,algo.*\""
            },
            "unsupported.dbms.uris.management": {
              "description": "Configuration attribute",
              "value": "/db/manage"
            },
            "ha.server_id": {
              "description": "Id for a cluster instance. Must be unique within the cluster.",
              "value": null
            },
            "causal_clustering.array_block_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of ARRAY_BLOCK IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "dbms.logs.query.rotation.size": {
              "description": "The file size in bytes at which the query log will auto-rotate. If set to zero then no rotation will occur. Accepts a binary suffix `k`, `m` or `g`.",
              "value": "20971520"
            },
            "unsupported.dbms.udc.first_delay": {
              "description": "Configuration attribute",
              "value": "600000"
            },
            "dbms.security.ldap.read_timeout": {
              "description": "The timeout for an LDAP read request (i.e. search). If the LDAP server does not respond within the given time the request will be aborted. A value of 0 means wait for a response indefinitely.",
              "value": "30000ms"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84.x.min": {
              "description": "The minimum x value for the index extents for 2D wgs-84 spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-180.0"
            },
            "unsupported.dbms.udc.interval": {
              "description": "Configuration attribute",
              "value": "86400000"
            },
            "unsupported.dbms.index.spatial.curve.max_bits": {
              "description": "The maximum number of bits to use for levels in the quad tree representing the spatial index. When creating the spatial index, we simulate a quad tree using a 2D (or 3D) to 1D mapping function. This requires that the extents of the index and the depth of the tree be defined in advance, so ensure the 2D to 1D mapping is deterministic and repeatable. This setting will define the maximum depth of any future spatial index created, calculated as max_bits / dimensions. For example 60 bits will define 30 levels in 2D and 20 levels in 3D. Existing indexes will not be changed, and need to be recreated if you wish to use the new value. For 2D indexes, a value of 30 is the largest supported. For 3D indexes 20 is the largest.",
              "value": "60"
            },
            "dbms.unmanaged_extension_classes": {
              "description": "Comma-separated list of <classname>=<mount point> for unmanaged extensions.",
              "value": "[]"
            },
            "causal_clustering.property_key_token_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of PROPERTY_KEY_TOKEN IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "32"
            },
            "dbms.auto_index.relationships.enabled": {
              "description": "Controls the auto indexing feature for relationships. Setting it to `false` shuts it down, while `true` enables it by default for properties listed in the dbms.auto_index.relationships.keys setting.",
              "value": "false"
            },
            "metrics.graphite.interval": {
              "description": "The reporting interval for Graphite. That is, how often to send updated metrics to Graphite.",
              "value": "3000ms"
            },
            "unsupported.dbms.bolt.outbound_buffer_throttle.low_watermark": {
              "description": "When the size (in bytes) of outbound network buffers, previously advertised as unwritable, gets below this value bolt channel will re-advertise itself as writable and blocked processing thread will resume execution.",
              "value": "131072"
            },
            "unsupported.tools.batch_inserter.batch_size": {
              "description": "Specifies number of operations that batch inserter will try to group into one batch before flushing data into underlying storage.",
              "value": "10000"
            },
            "causal_clustering.middleware.akka.failure_detector.acceptable_heartbeat_pause": {
              "description": "Akka cluster phi accrual failure detector. Number of potentially lost/delayed heartbeats that will be accepted before considering it to be an anomaly. This margin is important to be able to survive sudden, occasional, pauses in heartbeat arrivals, due to for example garbage collect or network drop.",
              "value": "4000ms"
            },
            "causal_clustering.leader_election_timeout": {
              "description": "The time limit within which a new leader election will occur if no messages are received.",
              "value": "7000ms"
            },
            "ha.pull_interval": {
              "description": "Interval of pulling updates from master.",
              "value": "10000ms"
            },
            "cypher.statistics_divergence_threshold": {
              "description": "The threshold when a plan is considered stale. If any of the underlying statistics used to create the plan have changed more than this value, the plan will be considered stale and will be replanned. Change is calculated as abs(a-b)/max(a,b). This means that a value of 0.75 requires the database to approximately quadruple in size. A value of 0 means replan as soon as possible, with the soonest being defined by the cypher.min_replan_interval which defaults to 10s. After this interval the divergence threshold will slowly start to decline, reaching 10% after about 7h. This will ensure that long running databases will still get query replanning on even modest changes, while not replanning frequently unless the changes are very large.",
              "value": "0.75"
            },
            "dbms.connector.https.enabled": {
              "description": "Enable this connector.",
              "value": "true"
            },
            "unsupported.dbms.query.snapshot": {
              "description": "Specifies if engine should run cypher query based on a snapshot of accessed data. Query will be restarted in case if concurrent modification of data will be detected.",
              "value": "false"
            },
            "unsupported.cypher.non_indexed_label_warning_threshold": {
              "description": "The threshold when a warning is generated if a label scan is done after a load csv where the label has no index",
              "value": "10000"
            },
            "unsupported.dbms.db.spatial.crs.cartesian.x.max": {
              "description": "The maximum x value for the index extents for 2D cartesian spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "1000000.0"
            },
            "causal_clustering.store_copy_max_retry_time_per_request": {
              "description": "Maximum retry time per request during store copy. Regular store files and indexes are downloaded in separate requests during store copy. This configures the maximum time failed requests are allowed to resend. ",
              "value": "1200000ms"
            },
            "unsupported.cypher.number_of_workers": {
              "description": "Number of threads to allocate to Cypher worker threads. If set to 0, two workers will be started for every physical core in the system.",
              "value": "0"
            },
            "unsupported.dbms.memory.pagecache.warmup.enable": {
              "description": "Page cache can be configured to perform usage sampling of loaded pages that can be used to construct active load profile. According to that profile pages can be reloaded on the restart, replication, etc. This setting allows disabling that behavior. This feature available in Neo4j Enterprise Edition.",
              "value": "true"
            },
            "dbms.active_database": {
              "description": "Name of the database to load",
              "value": "graph.db"
            },
            "dbms.tx_state.memory_allocation": {
              "description": "Defines whether memory for transaction state should be allocated on- or off-heap.",
              "value": "ON_HEAP"
            },
            "unsupported.dbms.block_size.strings": {
              "description": "Specifies the block size for storing strings. This parameter is only honored when the store is created, otherwise it is ignored. Note that each character in a string occupies two bytes, meaning that e.g a block size of 120 will hold a 60 character long string before overflowing into a second block. Also note that each block carries a ~10B of overhead so record size on disk will be slightly larger than the configured block size",
              "value": "120"
            },
            "unsupported.cypher.compiler_tracing": {
              "description": "Enable tracing of compilation in cypher.",
              "value": "false"
            },
            "dbms.connector.https.listen_address": {
              "description": "Address the connector should bind to.",
              "value": "0.0.0.0:7473"
            },
            "dbms.logs.timezone": {
              "description": "Database logs timezone.",
              "value": "UTC"
            },
            "metrics.csv.rotation.size": {
              "description": "The file size in bytes at which the csv files will auto-rotate. If set to zero then no rotation will occur. Accepts a binary suffix `k`, `m` or `g`.",
              "value": "10485760"
            },
            "causal_clustering.transaction_advertised_address": {
              "description": "Advertised hostname/IP address and port for the transaction shipping server.",
              "value": "10.142.0.5:6000"
            },
            "dbms.security.ldap.authorization.user_search_filter": {
              "description": "The LDAP search filter to search for a user principal when LDAP authorization is enabled. The filter should contain the placeholder token {0} which will be substituted for the user principal.",
              "value": "(&(objectClass=*)(uid={0}))"
            },
            "causal_clustering.id_alloc_state_size": {
              "description": "The maximum file size before the ID allocation file is rotated (in unit of entries)",
              "value": "1000"
            },
            "causal_clustering.relationship_type_token_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP_TYPE_TOKEN IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "32"
            },
            "dbms.auto_index.relationships.keys": {
              "description": "A list of property names (comma separated) that will be indexed by default. This applies to _relationships_ only.",
              "value": "[]"
            },
            "ha.leave_timeout": {
              "description": "Timeout for waiting for cluster leave to finish. Defaults to ha.broadcast_timeout.",
              "value": "30000ms"
            },
            "causal_clustering.in_flight_cache.max_bytes": {
              "description": "The maximum number of bytes in the in-flight cache.",
              "value": "2147483648"
            },
            "causal_clustering.transaction_listen_address": {
              "description": "Network interface and port for the transaction shipping server to listen on. Please note that it is also possible to run the backup client against this port so always limit access to it via the firewall and configure an ssl policy.",
              "value": "0.0.0.0:6000"
            },
            "unsupported.cypher.enable_morsel_runtime_trace": {
              "description": "Enable tracing of morsel runtime scheduler.",
              "value": "false"
            },
            "dbms.directories.plugins": {
              "description": "Location of the database plugin directory. Compiled Java JAR files that contain database procedures will be loaded if they are placed in this directory.",
              "value": "/var/lib/neo4j/plugins"
            },
            "metrics.jvm.buffers.enabled": {
              "description": "Enable reporting metrics about the buffer pools.",
              "value": "true"
            },
            "causal_clustering.server_groups": {
              "description": "A list of group names for the server used when configuring load balancing and replication policies.",
              "value": "[]"
            },
            "unsupported.dbms.wadl_generation_enabled": {
              "description": "Configuration attribute",
              "value": "false"
            },
            "causal_clustering.ssl_policy": {
              "description": "Name of the SSL policy to be used by the clustering, as defined under the dbms.ssl.policy.* settings. If no policy is configured then the communication will not be secured.",
              "value": null
            },
            "dbms.index.fulltext.default_analyzer": {
              "description": "The name of the analyzer that the fulltext indexes should use by default.",
              "value": "standard"
            },
            "dbms.backup.enabled": {
              "description": "Enable support for running online backups",
              "value": "true"
            },
            "causal_clustering.catchup_batch_size": {
              "description": "The maximum batch size when catching up (in unit of entries)",
              "value": "64"
            },
            "dbms.logs.query.rotation.keep_number": {
              "description": "Maximum number of history files for the query log.",
              "value": "7"
            },
            "causal_clustering.protocol_implementations.compression": {
              "description": "Network compression algorithms that this instance will allow in negotiation as a comma-separated list. Listed in descending order of preference for incoming connections. An empty list implies no compression. For outgoing connections this merely specifies the allowed set of algorithms and the preference of the  remote peer will be used for making the decision. Allowable values: [Gzip,Snappy,Snappy_validating,LZ4,LZ4_high_compression,LZ_validating,LZ4_high_compression_validating]",
              "value": "[]"
            },
            "dbms.read_only": {
              "description": "Only allow read operations from this Neo4j instance. This mode still requires write access to the directory for lock purposes.",
              "value": "false"
            },
            "dbms.logs.query.runtime_logging_enabled": {
              "description": "Logs which runtime that was used to run the query",
              "value": "false"
            },
            "dbms.tx_log.rotation.retention_policy": {
              "description": "Make Neo4j keep the logical transaction logs for being able to backup the database. Can be used for specifying the threshold to prune logical logs after. For example \"10 days\" will prune logical logs that only contains transactions older than 10 days from the current time, or \"100k txs\" will keep the 100k latest transactions and prune any older transactions.",
              "value": "7 days"
            },
            "dbms.security.auth_lock_time": {
              "description": "The amount of time user account should be locked after a configured number of unsuccessful authentication attempts. The locked out user will not be able to log in until the lock period expires, even if correct credentials are provided. Setting this configuration option to a low value is not recommended because it might make it easier for an attacker to brute force the password.",
              "value": "5000ms"
            },
            "dbms.logs.query.threshold": {
              "description": "If the execution of query takes more time than this threshold, the query is logged - provided query logging is enabled. Defaults to 0 seconds, that is all queries are logged.",
              "value": "0ms"
            },
            "dbms.ssl.policy.<policyname>.private_key_password": {
              "description": "The password for the private key.",
              "value": null
            },
            "dbms.windows_service_name": {
              "description": "Name of the Windows Service.",
              "value": "neo4j"
            },
            "dbms.security.procedures.roles": {
              "description": "This provides a finer level of control over which roles can execute procedures than the `dbms.security.procedures.default_allowed` setting. For example: `+dbms.security.procedures.roles=apoc.convert.*:reader;apoc.load.json*:writer;apoc.trigger.add:TriggerHappy+` will allow the role `reader` to execute all procedures in the `apoc.convert` namespace, the role `writer` to execute all procedures in the `apoc.load` namespace that starts with `json` and the role `TriggerHappy` to execute the specific procedure `apoc.trigger.add`. Procedures not matching any of these patterns will be subject to the `dbms.security.procedures.default_allowed` setting.\nDeprecated: This will be replaced by dynamic configuration in the system graph in 4.0, including a migration step for the existing setting value.",
              "value": ""
            },
            "ha.initial_hosts": {
              "description": "A comma-separated list of other members of the cluster to join.",
              "value": null
            },
            "dbms.security.plugin.authentication_enabled": {
              "description": "Enable authentication via plugin authentication providers.",
              "value": "false"
            },
            "dbms.ssl.policy.<policyname>.public_certificate": {
              "description": "X.509 certificate (chain) of this server in PEM format.",
              "value": "public.crt"
            },
            "dbms.allow_format_migration": {
              "description": "Whether to allow a store upgrade in case the current version of the database starts against an older store version. Setting this to `true` does not guarantee successful upgrade, it just allows an upgrade to be performed.",
              "value": "false"
            },
            "unsupported.dbms.udc.source": {
              "description": "Configuration attribute",
              "value": "maven"
            },
            "unsupported.dbms.db.spatial.crs.cartesian-3d.y.max": {
              "description": "The maximum y value for the index extents for 3D cartesian-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "1000000.0"
            },
            "dbms.threads.worker_count": {
              "description": "Number of Neo4j worker threads, your OS might enforce a lower limit than the maximum value specified here.",
              "value": "4"
            },
            "dbms.connector.http.enabled": {
              "description": "Enable this connector.",
              "value": "true"
            },
            "metrics.bolt.messages.enabled": {
              "description": "Enable reporting metrics about Bolt Protocol message processing.",
              "value": "true"
            },
            "dbms.mode": {
              "description": "Configure the operating mode of the database -- 'SINGLE' for stand-alone operation, 'HA' for operating as a member in an HA cluster, 'ARBITER' for a cluster member with no database in an HA cluster, 'CORE' for operating as a core member of a Causal Cluster, or 'READ_REPLICA' for operating as a read replica member of a Causal Cluster.",
              "value": "CORE"
            },
            "unsupported.dbms.executiontime_limit.time": {
              "description": "If execution time limiting is enabled in the database, this configures the maximum request execution time. Please use dbms.transaction.timeout instead.",
              "value": null
            },
            "dbms.checkpoint": {
              "description": "Configures the general policy for when check-points should occur. The default policy is the 'periodic' check-point policy, as specified by the 'dbms.checkpoint.interval.tx' and 'dbms.checkpoint.interval.time' settings. The Neo4j Enterprise Edition provides two alternative policies: The first is the 'continuous' check-point policy, which will ignore those settings and run the check-point process all the time. The second is the 'volumetric' check-point policy, which makes a best-effort at check-pointing often enough so that the database doesn't get too far behind on deleting old transaction logs in accordance with the 'dbms.tx_log.rotation.retention_policy' setting.",
              "value": "periodic"
            },
            "unsupported.dbms.security.module": {
              "description": "Configuration attribute",
              "value": "enterprise-security-module"
            },
            "dbms.index.fulltext.eventually_consistent": {
              "description": "Whether or not fulltext indexes should be eventually consistent by default or not.",
              "value": "false"
            },
            "dbms.logs.http.rotation.keep_number": {
              "description": "Number of HTTP logs to keep.",
              "value": "5"
            },
            "unsupported.dbms.console_module.engines": {
              "description": "Configuration attribute",
              "value": "[SHELL]"
            },
            "metrics.neo4j.enabled": {
              "description": "The default enablement value for all Neo4j specific support metrics. Set this to `false` to turn off all Neo4j specific metrics by default. The individual `metrics.neo4j.*` metrics can then be turned on selectively.",
              "value": "true"
            },
            "causal_clustering.raft_listen_address": {
              "description": "Network interface and port for the RAFT server to listen on.",
              "value": "0.0.0.0:7000"
            },
            "dbms.security.ldap.authentication.mechanism": {
              "description": "LDAP authentication mechanism. This is one of `simple` or a SASL mechanism supported by JNDI, for example `DIGEST-MD5`. `simple` is basic username and password authentication and SASL is used for more advanced mechanisms. See RFC 2251 LDAPv3 documentation for more details.",
              "value": "simple"
            },
            "ha.paxos_timeout": {
              "description": "Default value for all Paxos timeouts. This setting controls the default value for the ha.phase1_timeout, ha.phase2_timeout and ha.election_timeout settings. If it is not given a value it defaults to ha.default_timeout and will implicitly change if ha.default_timeout changes. This is an advanced parameter which should only be changed if specifically advised by Neo4j Professional Services.",
              "value": "5000ms"
            },
            "unsupported.dbms.db.spatial.crs.cartesian.y.max": {
              "description": "The maximum y value for the index extents for 2D cartesian spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "1000000.0"
            },
            "dbms.security.ldap.connection_timeout": {
              "description": "The timeout for establishing an LDAP connection. If a connection with the LDAP server cannot be established within the given time the attempt is aborted. A value of 0 means to use the network protocol's (i.e., TCP's) timeout value.",
              "value": "30000ms"
            },
            "dbms.record_format": {
              "description": "Database record format. Valid values: `standard`, `high_limit`. The `high_limit` formatis available for Enterprise Edition only. It is required if you have a graph that is larger than 34 billion nodes, 34 billion relationships, or 68 billion properties. A change of the record format is irreversible. Certain operations may suffer from a performance penalty of up to 10%, which is why this format is not switched on by default.",
              "value": ""
            },
            "unsupported.dbms.discoverable_bolt_routing_address": {
              "description": "Publicly discoverable bolt+routing:// URI to use for Neo4j Drivers wanting to access a cluster that this instance is a member of. Only applicable to causal clusters.",
              "value": ""
            },
            "ha.strict_initial_hosts": {
              "description": "Configuration attribute",
              "value": "false"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84-3d.x.max": {
              "description": "The maximum x value for the index extents for 3D wgs-84-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "180.0"
            },
            "ha.internal_role_switch_timeout": {
              "description": "Timeout for waiting for internal conditions during state switch, like for transactions to complete, before switching to master or slave.",
              "value": "10000ms"
            },
            "dbms.security.property_level.enabled": {
              "description": "Set to true to enable property level security.",
              "value": "false"
            },
            "causal_clustering.raft_log_rotation_size": {
              "description": "RAFT log rotation size",
              "value": "262144000"
            },
            "ha.data_chunk_size": {
              "description": "Max size of the data chunks that flows between master and slaves in HA. Bigger size may increase throughput, but may also be more sensitive to variations in bandwidth, whereas lower size increases tolerance for bandwidth variations.",
              "value": "2097152"
            },
            "causal_clustering.connect-randomly-to-server-group": {
              "description": "Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy. The connect-randomly-to-server-group strategy is used if the list of strategies (`causal_clustering.upstream_selection_strategy`) includes the value `connect-randomly-to-server-group`. ",
              "value": "[]"
            },
            "dbms.ssl.policy.<policyname>.revoked_dir": {
              "description": "Path to directory of CRLs (Certificate Revocation Lists) in PEM format.",
              "value": "revoked"
            },
            "causal_clustering.string_block_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of STRING_BLOCK IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "unsupported.dbms.directories.auth": {
              "description": "Configuration attribute",
              "value": "/var/lib/neo4j/data/dbms"
            },
            "dbms.directories.data": {
              "description": "Path of the data directory. You must not configure more than one Neo4j installation to use the same data directory.",
              "value": "/var/lib/neo4j/data"
            },
            "dbms.logs.gc.enabled": {
              "description": "Enable GC Logging",
              "value": "false"
            },
            "causal_clustering.kubernetes.address": {
              "description": "Address for Kubernetes API",
              "value": "kubernetes.default.svc:443"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84-3d.z.min": {
              "description": "The minimum z value for the index extents for 3D wgs-84-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-1000000.0"
            },
            "unsupported.dbms.edition": {
              "description": "Configuration attribute",
              "value": "enterprise"
            },
            "dbms.track_query_cpu_time": {
              "description": "Enables or disables tracking of how much time a query spends actively executing on the CPU. Calling `dbms.listQueries` will display the time. This can also be logged in the query log by using `log_queries_detailed_time_logging_enabled`.",
              "value": "false"
            },
            "dbms.ssl.policy.<policyname>.ciphers": {
              "description": "Restrict allowed ciphers.",
              "value": null
            },
            "unsupported.cypher.idp_solver_table_threshold": {
              "description": "To improve IDP query planning time, we can restrict the internal planning table size, triggering compaction of candidate plans. The smaller the threshold the faster the planning, but the higher the risk of sub-optimal plans.",
              "value": "128"
            },
            "dbms.logs.http.rotation.size": {
              "description": "Size of each HTTP log that is kept.",
              "value": "20971520"
            },
            "dbms.logs.user.rotation.keep_number": {
              "description": "Maximum number of history files for the user log.",
              "value": "7"
            },
            "causal_clustering.cluster_topology_refresh": {
              "description": "Time between scanning the cluster to refresh current server's view of topology",
              "value": "5000ms"
            },
            "dbms.security.log_successful_authentication": {
              "description": "Set to log successful authentication events to the security log. If this is set to `false` only failed authentication events will be logged, which could be useful if you find that the successful events spam the logs too much, and you do not require full auditing capability.",
              "value": "true"
            },
            "dbms.logs.query.enabled": {
              "description": "Log executed queries that take longer than the configured threshold, dbms.logs.query.threshold. Log entries are by default written to the file _query.log_ located in the Logs directory. For location of the Logs directory, see <<file-locations>>. This feature is available in the Neo4j Enterprise Edition.",
              "value": "false"
            },
            "causal_clustering.label_token_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of LABEL_TOKEN IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "32"
            },
            "dbms.security.ldap.referral": {
              "description": "The LDAP referral behavior when creating a connection. This is one of `follow`, `ignore` or `throw`.\n\n* `follow` automatically follows any referrals\n* `ignore` ignores any referrals\n* `throw` throws an exception, which will lead to authentication failure",
              "value": "follow"
            },
            "dbms.checkpoint.interval.time": {
              "description": "Configures the time interval between check-points. The database will not check-point more often than this (unless check pointing is triggered by a different event), but might check-point less often than this interval, if performing a check-point takes longer time than the configured interval. A check-point is a point in the transaction logs, from which recovery would start from. Longer check-point intervals typically means that recovery will take longer to complete in case of a crash. On the other hand, a longer check-point interval can also reduce the I/O load that the database places on the system, as each check-point implies a flushing and forcing of all the store files.",
              "value": "900000ms"
            },
            "dbms.security.http_access_control_allow_origin": {
              "description": "Value of the Access-Control-Allow-Origin header sent over any HTTP or HTTPS connector. This defaults to '*', which allows broadest compatibility. Note that any URI provided here limits HTTP/HTTPS access to that URI only.",
              "value": "*"
            },
            "unsupported.dbms.db.spatial.crs.cartesian-3d.z.min": {
              "description": "The minimum z value for the index extents for 3D cartesian-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-1000000.0"
            },
            "dbms.logs.user.path": {
              "description": "Path to the user log file.",
              "value": "/var/log/neo4j/neo4j.log"
            },
            "dbms.ssl.policy.<policyname>.allow_key_generation": {
              "description": "Allows the generation of a private key and associated self-signed certificate. Only performed when both objects cannot be found.",
              "value": "false"
            },
            "dbms.logs.user.rotation.delay": {
              "description": "Minimum time interval after last rotation of the user log before it may be rotated again.",
              "value": "300000ms"
            },
            "unsupported.cypher.task_wait": {
              "description": "Duration in milliseconds that parallel runtime waits on a task before trying another task",
              "value": "30000"
            },
            "metrics.neo4j.logrotation.enabled": {
              "description": "Enable reporting metrics about the Neo4j log rotation; when it occurs and how much time it takes to complete.",
              "value": "true"
            },
            "browser.post_connect_cmd": {
              "description": "Commands to be run when Neo4j Browser successfully connects to this server. Separate multiple commands with semi-colon.",
              "value": ""
            },
            "unsupported.vm_pause_monitor.stall_alert_threshold": {
              "description": "Configuration attribute",
              "value": "100ms"
            },
            "metrics.neo4j.causal_clustering.enabled": {
              "description": "Enable reporting metrics about Causal Clustering mode.",
              "value": "true"
            },
            "causal_clustering.node_labels_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of NODE_LABELS IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "dbms.security.ldap.authentication_enabled": {
              "description": "Enable authentication via settings configurable LDAP authentication provider.",
              "value": "false"
            },
            "dbms.logs.security.level": {
              "description": "Security log level threshold.",
              "value": "INFO"
            },
            "dbms.logs.http.enabled": {
              "description": "Enable HTTP request logging.",
              "value": "false"
            },
            "unsupported.dbms.db.spatial.crs.cartesian-3d.x.max": {
              "description": "The maximum x value for the index extents for 3D cartesian-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "1000000.0"
            },
            "dbms.tx_log.rotation.size": {
              "description": "Specifies at which file size the logical log will auto-rotate. Minimum accepted value is 1M. ",
              "value": "262144000"
            },
            "dbms.security.allow_csv_import_from_file_urls": {
              "description": "Determines if Cypher will allow using file URLs when loading data using `LOAD CSV`. Setting this value to `false` will cause Neo4j to fail `LOAD CSV` clauses that load data from the file system.",
              "value": "true"
            },
            "dbms.logs.http.path": {
              "description": "Path to HTTP request log.",
              "value": "/var/log/neo4j/http.log"
            },
            "dbms.security.ldap.use_starttls": {
              "description": "Use secure communication with the LDAP server using opportunistic TLS. First an initial insecure connection will be made with the LDAP server, and a STARTTLS command will be issued to negotiate an upgrade of the connection to TLS before initiating authentication.",
              "value": "false"
            },
            "dbms.import.csv.legacy_quote_escaping": {
              "description": "Selects whether to conform to the standard https://tools.ietf.org/html/rfc4180 for interpreting escaped quotation characters in CSV files loaded using `LOAD CSV`. Setting this to `false` will use the standard, interpreting repeated quotes '\"\"' as a single in-lined quote, while `true` will use the legacy convention originally supported in Neo4j 3.0 and 3.1, allowing a backslash to include quotes in-lined in fields.",
              "value": "true"
            },
            "unsupported.dbms.index.spatial.curve.extra_levels": {
              "description": "When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. This setting will cause the algorithm to search deeper, reducing false positives.",
              "value": "1"
            },
            "dbms.index.default_schema_provider": {
              "description": "Index provider to use for newly created schema indexes. An index provider may store different value types in separate physical indexes. lucene-1.0: Spatial and temporal value types are stored in native indexes, remaining value types in Lucene index. lucene+native-1.0: Spatial, temporal and number value types are stored in native indexes and remaining value types in Lucene index. lucene+native-2.0: Spatial, temporal, number and string value types are stored in native indexes and remaining value types in Lucene index. native-btree-1.0: All value types and arrays of all value types, even composite keys, are stored in one native index. A native index has faster updates, less heap and CPU usage compared to a Lucene index. A native index has these limitations: Index key (be it single or composite) size limit of 4039 bytes - transaction resulting in index key surpassing that will fail. Reduced performance of CONTAINS and ENDS WITH string index queries, compared to a Lucene index.",
              "value": "native-btree-1.0"
            },
            "cypher.forbid_shortestpath_common_nodes": {
              "description": "This setting is associated with performance optimization. The shortest path algorithm does not work when the start and end nodes are the same. With this setting set to `false` no path will be returned when that happens. The default value of `true` will instead throw an exception. This can happen if you perform a shortestPath search after a cartesian product that might have the same start and end nodes for some of the rows passed to shortestPath. If it is preferable to not experience this exception, and acceptable for results to be missing for those rows, then set this to `false`. If you cannot accept missing results, and really want the shortestPath between two common nodes, then re-write the query using a standard Cypher variable length pattern expression followed by ordering by path length and limiting to one result.",
              "value": "true"
            },
            "causal_clustering.load_balancing.config": {
              "description": "The configuration must be valid for the configured plugin and usually existsunder matching subkeys, e.g. ..config.server_policies.*This is just a top-level placeholder for the plugin-specific configuration.",
              "value": ""
            },
            "metrics.neo4j.checkpointing.enabled": {
              "description": "Enable reporting metrics about Neo4j check pointing; when it occurs and how much time it takes to complete.",
              "value": "true"
            },
            "causal_clustering.protocol_implementations.raft": {
              "description": "Raft protocol implementation versions that this instance will allow in negotiation as a comma-separated list. Order is not relevant: the greatest value will be preferred. An empty list will allow all supported versions",
              "value": "[]"
            },
            "causal_clustering.pull_interval": {
              "description": "Interval of pulling updates from cores.",
              "value": "1000ms"
            },
            "causal_clustering.state_machine_apply_max_batch_size": {
              "description": "The maximum number of operations to be batched during applications of operations in the state machines",
              "value": "16"
            },
            "unsupported.dbms.udc.reg": {
              "description": "Configuration attribute",
              "value": "unreg"
            },
            "ha.heartbeat_timeout": {
              "description": "How long to wait for heartbeats from other instances before marking them as suspects for failure. This value reflects considerations of network latency, expected duration of garbage collection pauses and other factors that can delay message sending and processing. Larger values will result in more stable masters but also will result in longer waits before a failover in case of master failure. This value should not be set to less than twice the ha.heartbeat_interval value otherwise there is a high risk of frequent master switches and possibly branched data occurrence.",
              "value": "40000ms"
            },
            "dbms.ids.reuse.types.override": {
              "description": "Specified names of id types (comma separated) that should be reused. Currently only 'node' and 'relationship' types are supported. ",
              "value": "[RELATIONSHIP, NODE]"
            },
            "dbms.ssl.policy.<policyname>.private_key": {
              "description": "Private PKCS#8 key in PEM format.",
              "value": "private.key"
            },
            "unsupported.dbms.memory.pagecache.pagesize": {
              "description": "Target size for pages of mapped memory. If set to 0, then a reasonable default is chosen, depending on the storage device used.",
              "value": "0"
            },
            "ha.branched_data_copying_strategy": {
              "description": "Strategy for how to order handling of branched data on slaves and copying of the store from the master. The default is copy_then_branch, which, when combined with the keep_last or keep_none branch handling strategies results in a safer branching strategy, as there is always a store present so store failure to copy a store (for example, because of network failure) does not leave the instance without a store.",
              "value": "branch_then_copy"
            },
            "metrics.neo4j.cluster.enabled": {
              "description": "Enable reporting metrics about HA cluster info.",
              "value": "true"
            },
            "causal_clustering.catch_up_client_inactivity_timeout": {
              "description": "The catch up protocol times out if the given duration elapses with no network activity. Every message received by the client from the server extends the time out duration.",
              "value": "600000ms"
            },
            "dbms.security.http_strict_transport_security": {
              "description": "Value of the HTTP Strict-Transport-Security (HSTS) response header. This header tells browsers that a webpage should only be accessed using HTTPS instead of HTTP. It is attached to every HTTPS response. Setting is not set by default so 'Strict-Transport-Security' header is not sent. Value is expected to contain dirictives like 'max-age', 'includeSubDomains' and 'preload'.",
              "value": null
            },
            "dbms.ssl.policy.<policyname>.client_auth": {
              "description": "Client authentication stance.",
              "value": "REQUIRE"
            },
            "dbms.memory.heap.max_size": {
              "description": "Maximum heap size. By default it is calculated based on available system resources.",
              "value": "4g"
            },
            "dbms.connectors.default_listen_address": {
              "description": "Default network interface to listen for incoming connections. To listen for connections on all interfaces, use \"0.0.0.0\". To bind specific connectors to a specific network interfaces, specify the +listen_address+ properties for the specific connector.",
              "value": "0.0.0.0"
            },
            "metrics.csv.rotation.keep_number": {
              "description": "Maximum number of history files for the csv files.",
              "value": "7"
            },
            "dbms.udc.enabled": {
              "description": "Enable the UDC extension.",
              "value": "true"
            },
            "unsupported.dbms.directories.database": {
              "description": "Configuration attribute",
              "value": "/var/lib/neo4j/data/databases/graph.db"
            },
            "dbms.shutdown_transaction_end_timeout": {
              "description": "The maximum amount of time to wait for running transactions to complete before allowing initiated database shutdown to continue",
              "value": "10000ms"
            },
            "causal_clustering.kubernetes.token": {
              "description": "File location of token for Kubernetes API",
              "value": "/var/run/secrets/kubernetes.io/serviceaccount/token"
            },
            "dbms.auto_index.nodes.keys": {
              "description": "A list of property names (comma separated) that will be indexed by default. This applies to _nodes_ only.",
              "value": "[]"
            },
            "causal_clustering.replicated_lock_token_state_size": {
              "description": "The maximum file size before the replicated lock token state file is rotated (in unit of entries)",
              "value": "1000"
            },
            "dbms.logs.query.page_logging_enabled": {
              "description": "Log page hits and page faults for the executed queries being logged.",
              "value": "false"
            },
            "dbms.memory.pagecache.size": {
              "description": "The amount of memory to use for mapping the store files, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g'). If Neo4j is running on a dedicated server, then it is generally recommended to leave about 2-4 gigabytes for the operating system, give the JVM enough heap to hold all your transaction state and query context, and then leave the rest for the page cache. If no page cache memory is configured, then a heuristic setting is computed based on available system resources.",
              "value": "8g"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84-3d.y.max": {
              "description": "The maximum y value for the index extents for 3D wgs-84-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "90.0"
            },
            "dbms.filewatcher.enabled": {
              "description": "Allows the enabling or disabling of the file watcher service. This is an auxiliary service but should be left enabled in almost all cases.",
              "value": "true"
            },
            "unsupported.dbms.console_module.enabled": {
              "description": "Configuration attribute",
              "value": "true"
            },
            "unsupported.cypher.runtime": {
              "description": "Set this to specify the default runtime for the default language version.",
              "value": "default"
            },
            "causal_clustering.property_key_token_name_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of PROPERTY_KEY_TOKEN_NAME IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "dbms.security.ldap.authorization.system_username": {
              "description": "An LDAP system account username to use for authorization searches when `dbms.security.ldap.authorization.use_system_account` is `true`. Note that the `dbms.security.ldap.authentication.user_dn_template` will not be applied to this username, so you may have to specify a full DN.",
              "value": null
            },
            "dbms.security.http_authorization_classes": {
              "description": "Comma-separated list of custom security rules for Neo4j to use.",
              "value": "[]"
            },
            "causal_clustering.raft_in_queue_max_batch_bytes": {
              "description": "Largest batch processed by RAFT in bytes",
              "value": "8388608"
            },
            "causal_clustering.relationship_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "unsupported.dbms.schema.release_lock_while_building_constraint": {
              "description": "Whether or not to release the exclusive schema lock is while building uniqueness constraints index",
              "value": "false"
            },
            "causal_clustering.upstream_selection_strategy": {
              "description": "An ordered list in descending preference of the strategy which read replicas use to choose the upstream server from which to pull transactional updates.",
              "value": "[default]"
            },
            "ha.tx_push_factor": {
              "description": "The amount of slaves the master will ask to replicate a committed transaction. ",
              "value": "1"
            },
            "ha.max_acceptors": {
              "description": "Maximum number of servers to involve when agreeing to membership changes. In very large clusters, the probability of half the cluster failing is low, but protecting against any arbitrary half failing is expensive. Therefore you may wish to set this parameter to a value less than the cluster size.",
              "value": "21"
            },
            "dbms.logs.security.rotation.size": {
              "description": "Threshold for rotation of the security log.",
              "value": "20971520"
            },
            "causal_clustering.enable_pre_voting": {
              "description": "Enable pre-voting extension to the Raft protocol (this is breaking and must match between the core cluster members)",
              "value": "false"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84-3d.x.min": {
              "description": "The minimum x value for the index extents for 3D wgs-84-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-180.0"
            },
            "causal_clustering.raft_in_queue_max_bytes": {
              "description": "Maximum number of bytes in the RAFT in-queue",
              "value": "2147483648"
            },
            "browser.credential_timeout": {
              "description": "Configure the Neo4j Browser to time out logged in users after this idle period. Setting this to 0 indicates no limit.",
              "value": "0ms"
            },
            "causal_clustering.expected_core_cluster_size": {
              "description": "Expected number of Core machines in the cluster before startup",
              "value": "3"
            },
            "causal_clustering.in_flight_cache.max_entries": {
              "description": "The maximum number of entries in the in-flight cache.",
              "value": "1024"
            },
            "dbms.netty.ssl.provider": {
              "description": "Netty SSL provider",
              "value": "JDK"
            },
            "unsupported.dbms.security.ldap.authorization.connection_pooling": {
              "description": "Set to true if connection pooling should be used for authorization searches using the system account.",
              "value": "true"
            },
            "dbms.backup.ssl_policy": {
              "description": "Name of the SSL policy to be used by backup, as defined under the dbms.ssl.policy.* settings. If no policy is configured then the communication will not be secured.",
              "value": null
            },
            "unsupported.dbms.max_http_response_header_size": {
              "description": "Maximum response header size",
              "value": "20480"
            },
            "causal_clustering.middleware.akka.failure_detector.max_sample_size": {
              "description": "Akka cluster phi accrual failure detector. Number of the samples of inter-heartbeat arrival times to adaptively calculate the failure timeout for connections.",
              "value": "1000"
            },
            "dbms.logs.security.path": {
              "description": "Path to the security log file.",
              "value": "/var/log/neo4j/security.log"
            },
            "causal_clustering.middleware.akka.failure_detector.expected_response_after": {
              "description": "Akka cluster phi accrual failure detector. After the heartbeat request has been sent the first failure detection will start after this period, even though no heartbeat message has been received.",
              "value": "1000ms"
            },
            "dbms.backup.address": {
              "description": "Listening server for online backups. The protocol running varies depending on deployment. In a Causal Clustering environment this is the same protocol that runs on causal_clustering.transaction_listen_address. The port range is only respected in a HA or single instance deployment. In Causal Clustering a single port should be used",
              "value": "localhost:6362"
            },
            "unsupported.dbms.block_size.labels": {
              "description": "Specifies the block size for storing labels exceeding in-lined space in node record. This parameter is only honored when the store is created, otherwise it is ignored. Also note that each block carries a ~10B of overhead so record size on disk will be slightly larger than the configured block size",
              "value": "56"
            },
            "dbms.connector.http.listen_address": {
              "description": "Address the connector should bind to.",
              "value": "0.0.0.0:7474"
            },
            "unsupported.vm_pause_monitor.measurement_duration": {
              "description": "Configuration attribute",
              "value": "100ms"
            },
            "unsupported.dbms.directories.neo4j_home": {
              "description": "Root relative to which directory settings are resolved. This is set in code and should never be configured explicitly.",
              "value": "/var/lib/neo4j"
            },
            "unsupported.dbms.tracer": {
              "description": "Configuration attribute",
              "value": null
            },
            "metrics.jvm.gc.enabled": {
              "description": "Enable reporting metrics about the duration of garbage collections",
              "value": "true"
            },
            "unsupported.dbms.kernel_id": {
              "description": "An identifier that uniquely identifies this graph database instance within this JVM. Defaults to an auto-generated number depending on how many instance are started in this JVM.",
              "value": null
            },
            "unsupported.cypher.statistics_divergence_target": {
              "description": "Large databases might change slowly, and so to prevent queries from never being replanned the divergence threshold set by cypher.statistics_divergence_threshold is configured to shrink over time. The algorithm used to manage this change is set by unsupported.cypher.replan_algorithm and will cause the threshold to reach the value set here once the time since the previous replanning has reached unsupported.cypher.target_replan_interval. Setting this value to higher than the cypher.statistics_divergence_threshold will cause the threshold to not decay over time.",
              "value": "0.1"
            },
            "ha.phase2_timeout": {
              "description": "Timeout for Paxos phase 2. If it is not given a value it defaults to ha.paxos_timeout and will implicitly change if ha.paxos_timeout changes. This is an advanced parameter which should only be changed if specifically advised by Neo4j Professional Services. ",
              "value": "5000ms"
            },
            "dbms.index.fulltext.eventually_consistent_index_update_queue_max_length": {
              "description": "The eventually_consistent mode of the fulltext indexes works by queueing up index updates to be applied later in a background thread. This setting sets an upper bound on how many index updates are allowed to be in this queue at any one point in time. When it is reached, the commit process will slow down and wait for the index update applier thread to make some more room in the queue.",
              "value": "10000"
            },
            "causal_clustering.replication_retry_timeout_base": {
              "description": "The initial timeout until replication is retried. The timeout will increase exponentially.",
              "value": "10000ms"
            },
            "unsupported.dbms.security.tls_certificate_file": {
              "description": "Path to the X.509 public certificate to be used by Neo4j for TLS connections",
              "value": "/var/lib/neo4j/certificates/neo4j.cert"
            },
            "unsupported.dbms.index.spatial.curve.top_threshold": {
              "description": "When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. When traversing the tree to this depth, we can stop early based on when the search envelope overlaps the current tile by more than a certain threshold. The threshold is calculated based on depth, from the `top_threshold` at the top of the tree to the `bottom_threshold` at the depth calculated by the area comparison. Setting the top to 0.99 and the bottom to 0.5, for example would mean that if we reached the maximum depth, and the search area overlapped the current tile by more than 50%, we would stop traversing the tree, and return the 1D range for that entire tile to the search set. If the overlap is even higher, we would stop higher in the tree. This technique reduces the number of 1D ranges passed to the underlying space filling curve index. Setting this value to zero turns off this feature.",
              "value": "0.0"
            },
            "dbms.index_sampling.update_percentage": {
              "description": "Percentage of index updates of total index size required before sampling of a given index is triggered",
              "value": "5"
            },
            "dbms.security.causal_clustering_status_auth_enabled": {
              "description": "Require authorization for access to the Causal Clustering status endpoints.",
              "value": "true"
            },
            "dbms.logs.user.rotation.size": {
              "description": "Threshold for rotation of the user log. If set to 0 log rotation is disabled.",
              "value": "0"
            },
            "dbms.index_sampling.sample_size_limit": {
              "description": "Index sampling chunk size limit",
              "value": "8388608"
            },
            "dbms.security.ldap.authentication.cache_enabled": {
              "description": "Determines if the result of authentication via the LDAP server should be cached or not. Caching is used to limit the number of LDAP requests that have to be made over the network for users that have already been authenticated successfully. A user can be authenticated against an existing cache entry (instead of via an LDAP server) as long as it is alive (see `dbms.security.auth_cache_ttl`).\nAn important consequence of setting this to `true` is that Neo4j then needs to cache a hashed version of the credentials in order to perform credentials matching. This hashing is done using a cryptographic hash function together with a random salt. Preferably a conscious decision should be made if this method is considered acceptable by the security standards of the organization in which this Neo4j instance is deployed.",
              "value": "true"
            },
            "dbms.tx_state.off_heap.max_cacheable_block_size": {
              "description": "Defines the maximum size of an off-heap memory block that can be cached to speed up allocations for transaction state data. The value must be a power of 2.",
              "value": "524288"
            },
            "db.temporal.timezone": {
              "description": "Database timezone for temporal functions. All Time and DateTime values that are created without an explicit timezone will use this configured default timezone.",
              "value": "Z"
            },
            "causal_clustering.raft_messages_log_enable": {
              "description": "Enable or disable the dump of all network messages pertaining to the RAFT protocol",
              "value": "false"
            },
            "unsupported.dbms.tx_log.fail_on_corrupted_log_files": {
              "description": "If `true`, Neo4j will abort recovery if any errors are encountered in the logical log. Setting this to `false` will allow Neo4j to restore as much as possible from the corrupted log files and ignore the rest, but, the integrity of the database might be compromised.",
              "value": "true"
            },
            "unsupported.dbms.bolt.outbound_buffer_throttle.high_watermark": {
              "description": "When the size (in bytes) of outbound network buffers, used by bolt's network layer, grows beyond this value bolt channel will advertise itself as unwritable and will block related processing thread until it becomes writable again.",
              "value": "524288"
            },
            "tools.consistency_checker.check_indexes": {
              "description": "This setting is deprecated. See commandline arguments for neoj4-admin check-consistency instead. Perform checks on indexes. Checking indexes is more expensive than checking the native stores, so it may be useful to turn off this check for very large databases.",
              "value": "true"
            },
            "unsupported.dbms.index.spatial.curve.bottom_threshold": {
              "description": "When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. When traversing the tree to this depth, we can stop early based on when the search envelope overlaps the current tile by more than a certain threshold. The threshold is calculated based on depth, from the `top_threshold` at the top of the tree to the `bottom_threshold` at the depth calculated by the area comparison. Setting the top to 0.99 and the bottom to 0.5, for example would mean that if we reached the maximum depth, and the search area overlapped the current tile by more than 50%, we would stop traversing the tree, and return the 1D range for that entire tile to the search set. If the overlap is even higher, we would stop higher in the tree. This technique reduces the number of 1D ranges passed to the underlying space filling curve index. Setting this value to zero turns off this feature.",
              "value": "0.0"
            },
            "dbms.security.native.authorization_enabled": {
              "description": "Enable authorization via native authorization provider.",
              "value": "true"
            },
            "unsupported.dbms.enable_native_schema_index": {
              "description": "Configuration attribute",
              "value": "true"
            },
            "unsupported.dbms.report_configuration": {
              "description": "Print out the effective Neo4j configuration after startup.",
              "value": "false"
            },
            "dbms.directories.tx_log": {
              "description": "Location where Neo4j keeps the logical transaction logs.",
              "value": "/var/lib/neo4j/data/databases/graph.db"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84-3d.y.min": {
              "description": "The minimum y value for the index extents for 3D wgs-84-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-90.0"
            },
            "dbms.security.auth_enabled": {
              "description": "Enable auth requirement to access Neo4j.",
              "value": "true"
            },
            "dbms.security.native.authentication_enabled": {
              "description": "Enable authentication via native authentication provider.",
              "value": "true"
            },
            "ha.election_timeout": {
              "description": "Timeout for waiting for other members to finish a role election. Defaults to ha.paxos_timeout.",
              "value": "5000ms"
            },
            "dbms.index_sampling.background_enabled": {
              "description": "Enable or disable background index sampling",
              "value": "true"
            },
            "causal_clustering.raft_advertised_address": {
              "description": "Advertised hostname/IP address and port for the RAFT server.",
              "value": "10.142.0.5:7000"
            },
            "causal_clustering.user_defined_upstream_strategy": {
              "description": "Configuration of a user-defined upstream selection strategy. The user-defined strategy is used if the list of strategies (`causal_clustering.upstream_selection_strategy`) includes the value `user_defined`. ",
              "value": ""
            },
            "causal_clustering.middleware.akka.failure_detector.heartbeat_interval": {
              "description": "Akka cluster phi accrual failure detector. How often keep-alive heartbeat messages should be sent to each connection.",
              "value": "1000ms"
            },
            "unsupported.dbms.disconnected": {
              "description": "Disable all Bolt protocol connectors. This setting is deprecated and will be removed in 4.0. Please use connector configuration instead.",
              "value": "false"
            },
            "dbms.security.ldap.host": {
              "description": "URL of LDAP server to use for authentication and authorization. The format of the setting is `<protocol>://<hostname>:<port>`, where hostname is the only required field. The supported values for protocol are `ldap` (default) and `ldaps`. The default port for `ldap` is 389 and for `ldaps` 636. For example: `ldaps://ldap.example.com:10389`.\n\nYou may want to consider using STARTTLS (`dbms.security.ldap.use_starttls`) instead of LDAPS for secure connections, in which case the correct protocol is `ldap`.",
              "value": "localhost"
            },
            "unsupported.dbms.discoverable_bolt_address": {
              "description": "Publicly discoverable bolt:// URI to use for Neo4j Drivers wanting to access the data in this particular database instance. Normally this is the same as the advertised address configured for the connector, but this allows manually overriding that default.",
              "value": ""
            },
            "causal_clustering.in_flight_cache.type": {
              "description": "Type of in-flight cache.",
              "value": "CONSECUTIVE"
            },
            "causal_clustering.discovery_implementation": {
              "description": "Select the middleware used for cluster topology discovery",
              "value": "HAZELCAST"
            },
            "ha.learn_timeout": {
              "description": "Timeout for learning values. Defaults to ha.default_timeout.",
              "value": "5000ms"
            },
            "unsupported.dbms.db.spatial.crs.cartesian-3d.z.max": {
              "description": "The maximum z value for the index extents for 3D cartesian-3d spatial index. The 3Dto 1D mapping function divides all 3Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 3Dspace. This requires that the extents of the 3Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "1000000.0"
            },
            "causal_clustering.log_shipping_max_lag": {
              "description": "The maximum lag allowed before log shipping pauses (in unit of entries)",
              "value": "256"
            },
            "causal_clustering.middleware.akka.default-parallelism": {
              "description": "Parallelism level of default dispatcher used by Akka based cluster topology discovery, including cluster, replicator, and discovery actors",
              "value": "4"
            },
            "dbms.security.ldap.authentication.use_samaccountname": {
              "description": "Perform authentication with sAMAccountName instead of DN.\nUsing this setting requires `dbms.security.ldap.authorization.system_username` and dbms.security.ldap.authorization.system_password to be used since there is no way to log in through ldap directly with the sAMAccountName, instead the login name will be resolved to a DN that will be used to log in with.",
              "value": "false"
            },
            "unsupported.cypher.replan_algorithm": {
              "description": "Large databases might change slowly, and to prevent queries from never being replanned the divergence threshold set by cypher.statistics_divergence_threshold is configured to shrink over time using the algorithm set here. This will cause the threshold to reach the value set by unsupported.cypher.statistics_divergence_target once the time since the previous replanning has reached the value set in unsupported.cypher.target_replan_interval. Setting the algorithm to 'none' will cause the threshold to not decay over time.",
              "value": "default"
            },
            "dbms.logs.security.rotation.delay": {
              "description": "Minimum time interval after last rotation of the security log before it may be rotated again.",
              "value": "300000ms"
            },
            "causal_clustering.kubernetes.namespace": {
              "description": "File location of namespace for Kubernetes API",
              "value": "/var/run/secrets/kubernetes.io/serviceaccount/namespace"
            },
            "dbms.rest.transaction.idle_timeout": {
              "description": "Timeout for idle transactions in the REST endpoint.",
              "value": "60000ms"
            },
            "ha.slave_read_timeout": {
              "description": "How long a slave will wait for response from master before giving up.",
              "value": "20000ms"
            },
            "browser.retain_connection_credentials": {
              "description": "Configure the Neo4j Browser to store or not store user credentials.",
              "value": "true"
            },
            "unsupported.dbms.bolt.outbound_buffer_throttle.max_duration": {
              "description": "When the total time outbound network buffer based throttle lock is held exceeds this value, the corresponding bolt channel will be aborted. Setting this to 0 will disable this behaviour.",
              "value": "900000ms"
            },
            "unsupported.dbms.ephemeral": {
              "description": "Configuration attribute",
              "value": "false"
            },
            "causal_clustering.global_session_tracker_state_size": {
              "description": "The maximum file size before the global session tracker state file is rotated (in unit of entries)",
              "value": "1000"
            },
            "dbms.logs.query.allocation_logging_enabled": {
              "description": "Log allocated bytes for the executed queries being logged. The logged number is cumulative over the duration of the query, i.e. for memory intense or long-running queries the value may be larger than the current memory allocation. Requires `dbms.track_query_allocation=true`",
              "value": "false"
            },
            "causal_clustering.raft_log_reader_pool_size": {
              "description": "RAFT log reader pool size",
              "value": "8"
            },
            "causal_clustering.discovery_type": {
              "description": "Configure the discovery type used for cluster name resolution",
              "value": "LIST"
            },
            "causal_clustering.raft_term_state_size": {
              "description": "The maximum file size before the term state file is rotated (in unit of entries)",
              "value": "1000"
            },
            "tools.consistency_checker.check_label_scan_store": {
              "description": "This setting is deprecated. See commandline arguments for neoj4-admin check-consistency instead. Perform checks on the label scan store. Checking this store is more expensive than checking the native stores, so it may be useful to turn off this check for very large databases.",
              "value": "true"
            },
            "causal_clustering.raft_messages_log_path": {
              "description": "Path to RAFT messages log.",
              "value": "/var/log/neo4j/raft-messages.log"
            },
            "ha.slave_lock_timeout": {
              "description": "Timeout for taking remote (write) locks on slaves. Defaults to ha.slave_read_timeout.",
              "value": "20000ms"
            },
            "metrics.neo4j.network.enabled": {
              "description": "Enable reporting metrics about the network usage.",
              "value": "true"
            },
            "causal_clustering.discovery_resolution_retry_interval": {
              "description": "The polling interval when attempting to resolve initial_discovery_members from DNS and SRV records.",
              "value": "5000ms"
            },
            "unsupported.dbms.security.auth_store.location": {
              "description": "Configuration attribute",
              "value": null
            },
            "causal_clustering.kubernetes.ca_crt": {
              "description": "File location of CA certificate for Kubernetes API",
              "value": "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
            },
            "causal_clustering.property_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of PROPERTY IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "causal_clustering.refuse_to_be_leader": {
              "description": "Prevents the current instance from volunteering to become Raft leader. Defaults to false, and should only be used in exceptional circumstances by expert users. Using this can result in reduced availability for the cluster.",
              "value": "false"
            },
            "dbms.logs.gc.rotation.size": {
              "description": "Size of each GC log that is kept.",
              "value": "20971520"
            },
            "dbms.security.auth_cache_ttl": {
              "description": "The time to live (TTL) for cached authentication and authorization info when using external auth providers (LDAP or plugin). Setting the TTL to 0 will disable auth caching. Disabling caching while using the LDAP auth provider requires the use of an LDAP system account for resolving authorization information.",
              "value": "600000ms"
            },
            "unsupported.dbms.query.snapshot.retries": {
              "description": "Specifies number or retries that query engine will do to execute query based on stable accessed data snapshot before giving up.",
              "value": "5"
            },
            "causal_clustering.cluster_routing_ttl": {
              "description": "How long drivers should cache the data from the `dbms.cluster.routing.getServers()` procedure.",
              "value": "300000ms"
            },
            "dbms.procedures.kill_query_verbose": {
              "description": "Specifies whether or not dbms.killQueries produces a verbose output, with information about which queries were not found",
              "value": "true"
            },
            "unsupported.dbms.directories.databases.root": {
              "description": "Configuration attribute",
              "value": "/var/lib/neo4j/data/databases"
            },
            "dbms.security.auth_cache_use_ttl": {
              "description": "Enable time-based eviction of the authentication and authorization info cache for external auth providers (LDAP or plugin). Disabling this setting will make the cache live forever and only be evicted when `dbms.security.auth_cache_max_capacity` is exceeded.",
              "value": "true"
            },
            "unsupported.cypher.morsel_size": {
              "description": "The size of the morsels",
              "value": "10000"
            },
            "dbms.logs.gc.rotation.keep_number": {
              "description": "Number of GC logs to keep.",
              "value": "5"
            },
            "dbms.tx_state.max_off_heap_memory": {
              "description": "The maximum amount of off-heap memory that can be used to store transaction state data; it's a total amount of memory shared across all active transactions. Zero means 'unlimited'. Used when dbms.tx_state.memory_allocation is set to 'OFF_HEAP'.",
              "value": "2147483648"
            },
            "ha.max_channels_per_slave": {
              "description": "Maximum number of connections a slave can have to the master.",
              "value": "20"
            },
            "unsupported.ha.instance_name": {
              "description": "Configuration attribute",
              "value": null
            },
            "tools.consistency_checker.check_property_owners": {
              "description": "This setting is deprecated. See commandline arguments for neoj4-admin check-consistency instead. Perform optional additional checking on property ownership. This can detect a theoretical inconsistency where a property could be owned by multiple entities. However, the check is very expensive in time and memory, so it is skipped by default.",
              "value": "false"
            },
            "causal_clustering.kubernetes.label_selector": {
              "description": "LabelSelector for Kubernetes API",
              "value": null
            },
            "cypher.planner": {
              "description": "Set this to specify the default planner for the default language version.",
              "value": "default"
            },
            "causal_clustering.initial_discovery_members": {
              "description": "A comma-separated list of other members of the cluster to join.",
              "value": "[meetup-cluster-core-vm-1:5000, meetup-cluster-core-vm-2:5000, meetup-cluster-core-vm-3:5000]"
            },
            "dbms.tx_state.off_heap.block_cache_size": {
              "description": "Defines the size of the off-heap memory blocks cache. The cache will contain this number of blocks for each block size that is power of two. Thus, maximum amount of memory used by blocks cache can be calculated as 2 * dbms.tx_state.off_heap.max_cacheable_block_size * dbms.tx_state.off_heap.block_cache_size",
              "value": "128"
            },
            "dbms.config.strict_validation": {
              "description": "A strict configuration validation will prevent the database from starting up if unknown configuration options are specified in the neo4j settings namespace (such as dbms., ha., cypher., etc). This is currently false by default but will be true by default in 4.0.",
              "value": "false"
            },
            "unsupported.dbms.lock_manager": {
              "description": "Configuration attribute",
              "value": ""
            },
            "causal_clustering.kubernetes.service_port_name": {
              "description": "Service port name for discovery for Kubernetes API",
              "value": null
            },
            "causal_clustering.node_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of NODE IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "metrics.prefix": {
              "description": "A common prefix for the reported metrics field names. By default, this is either be 'neo4j', or a computed value based on the cluster and instance names, when running in an HA configuration.",
              "value": "neo4j"
            },
            "ha.default_timeout": {
              "description": "Default timeout used for clustering timeouts. Override  specific timeout settings with proper values if necessary. This value is the default value for the ha.heartbeat_interval, ha.paxos_timeout and ha.learn_timeout settings.",
              "value": "5000ms"
            },
            "dbms.security.ldap.authentication.user_dn_template": {
              "description": "LDAP user DN template. An LDAP object is referenced by its distinguished name (DN), and a user DN is an LDAP fully-qualified unique user identifier. This setting is used to generate an LDAP DN that conforms with the LDAP directory's schema from the user principal that is submitted with the authentication token when logging in. The special token {0} is a placeholder where the user principal will be substituted into the DN string.",
              "value": "uid={0},ou=users,dc=example,dc=com"
            },
            "causal_clustering.discovery_listen_address": {
              "description": "Host and port to bind the cluster member discovery management communication.",
              "value": "0.0.0.0:5000"
            },
            "causal_clustering.middleware.akka.failure_detector.monitored_by_nr_of_members": {
              "description": "Akka cluster phi accrual failure detector. Number of member nodes that each member will send heartbeat messages to, i.e. each node will be monitored by this number of other nodes.",
              "value": "5"
            },
            "dbms.transaction.bookmark_ready_timeout": {
              "description": "The maximum amount of time to wait for the database state represented by the bookmark.",
              "value": "30000ms"
            },
            "dbms.allow_upgrade": {
              "description": "Whether to allow an upgrade in case the current version of the database starts against an older version.",
              "value": "true"
            },
            "ha.role_switch_timeout": {
              "description": "Timeout for request threads waiting for instance to become master or slave.",
              "value": "120000ms"
            },
            "dbms.logs.query.path": {
              "description": "Path to the query log file.",
              "value": "/var/log/neo4j/query.log"
            },
            "dbms.security.ldap.authorization_enabled": {
              "description": "Enable authorization via settings configurable LDAP authorization provider.",
              "value": "false"
            },
            "dbms.connectors.default_advertised_address": {
              "description": "Default hostname or IP address the server uses to advertise itself to its connectors. To advertise a specific hostname or IP address for a specific connector, specify the +advertised_address+ property for the specific connector.",
              "value": "node3.cluster.graph.center"
            },
            "dbms.logs.debug.rotation.size": {
              "description": "Threshold for rotation of the debug log.",
              "value": "20971520"
            },
            "ha.branched_data_policy": {
              "description": "Policy for how to handle branched data.",
              "value": "keep_all"
            },
            "causal_clustering.last_applied_state_size": {
              "description": "The maximum file size before the storage file is rotated (in unit of entries)",
              "value": "1000"
            },
            "causal_clustering.relationship_type_token_name_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of RELATIONSHIP_TYPE_TOKEN_NAME IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "causal_clustering.state_machine_flush_window_size": {
              "description": "The number of operations to be processed before the state machines flush to disk",
              "value": "4096"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84.y.max": {
              "description": "The maximum y value for the index extents for 2D wgs-84 spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "90.0"
            },
            "dbms.transaction.monitor.check.interval": {
              "description": "Configures the time interval between transaction monitor checks. Determines how often monitor thread will check transaction for timeout.",
              "value": "2000ms"
            },
            "causal_clustering.middleware_logging.level": {
              "description": "The level of middleware logging",
              "value": "500"
            },
            "unsupported.cypher.expression_engine": {
              "description": "Choose the expression engine. The default is to only compile expressions that are hot, if 'COMPILED' is chosen all expressions will be compiled directly and if 'INTERPRETED' is chosen expressions will never be compiled.",
              "value": "default"
            },
            "unsupported.cypher.target_replan_interval": {
              "description": "Large databases might change slowly, and to prevent queries from never being replanned the divergence threshold set by cypher.statistics_divergence_threshold is configured to shrink over time. The algorithm used to manage this change is set by unsupported.cypher.replan_algorithm and will cause the threshold to reach the value set by unsupported.cypher.statistics_divergence_target once the time since the previous replanning has reached the value set here. Setting this value to less than the value of cypher.min_replan_interval will cause the threshold to not decay over time.",
              "value": "25200000ms"
            },
            "causal_clustering.discovery_advertised_address": {
              "description": "Advertised cluster member discovery management communication.",
              "value": "node3.cluster.graph.center:5000"
            },
            "dbms.ssl.policy.<policyname>.trust_all": {
              "description": "Makes this policy trust all remote parties. Enabling this is not recommended and the trusted directory will be ignored.",
              "value": "false"
            },
            "causal_clustering.database": {
              "description": "The name of the database being hosted by this server instance. This configuration setting may be safely ignored unless deploying a multicluster. Instances may be allocated to distinct sub-clusters by assigning them distinct database names using this setting. For instance if you had 6 instances you could form 2 sub-clusters by assigning half the database name \"foo\", half the name \"bar\". The setting value must match exactly between members of the same sub-cluster. This setting is a one-off: once an instance is configured with a database name it may not be changed in future without using neo4j-admin unbind.",
              "value": "default"
            },
            "browser.remote_content_hostname_whitelist": {
              "description": "Whitelist of hosts for the Neo4j Browser to be allowed to fetch content from.",
              "value": "guides.neo4j.com,localhost"
            },
            "dbms.ssl.policy.<policyname>.tls_versions": {
              "description": "Restrict allowed TLS protocol versions.",
              "value": "[TLSv1.2]"
            },
            "causal_clustering.disable_middleware_logging": {
              "description": "Prevents the network middleware from dumping its own logs. Defaults to true.",
              "value": "true"
            },
            "unsupported.dbms.id_reuse_safe_zone": {
              "description": "Duration for which master will buffer ids and not reuse them to allow slaves read consistently. Slaves will also terminate transactions longer than this duration, when applying received transaction stream, to make sure they do not read potentially inconsistent/reused records.",
              "value": "3600000ms"
            },
            "dbms.directories.metrics": {
              "description": "The target location of the CSV files: a path to a directory wherein a CSV file per reported field  will be written.",
              "value": "/var/lib/neo4j/metrics"
            },
            "dbms.directories.logs": {
              "description": "Path of the logs directory.",
              "value": "/var/log/neo4j"
            },
            "causal_clustering.raft_vote_state_size": {
              "description": "The maximum file size before the vote state file is rotated (in unit of entries)",
              "value": "1000"
            },
            "unsupported.dbms.executiontime_limit.enabled": {
              "description": "Please use dbms.transaction.timeout instead.",
              "value": "false"
            },
            "cypher.lenient_create_relationship": {
              "description": "Set this to change the behavior for Cypher create relationship when the start or end node is missing. By default this fails the query and stops execution, but by setting this flag the create operation is simply not performed and execution continues.",
              "value": "false"
            },
            "causal_clustering.raft_log_pruning_frequency": {
              "description": "RAFT log pruning frequency",
              "value": "600000ms"
            },
            "dbms.security.ldap.authorization.system_password": {
              "description": "An LDAP system account password to use for authorization searches when `dbms.security.ldap.authorization.use_system_account` is `true`.",
              "value": null
            },
            "dbms.directories.import": {
              "description": "Sets the root directory for file URLs used with the Cypher `LOAD CSV` clause. This must be set to a single directory, restricting access to only those files within that directory and its subdirectories.",
              "value": "/var/lib/neo4j/import"
            },
            "causal_clustering.unknown_address_logging_throttle": {
              "description": "Throttle limit for logging unknown cluster member address",
              "value": "10000ms"
            },
            "dbms.security.ldap.authorization.group_to_role_mapping": {
              "description": "An authorization mapping from LDAP group names to Neo4j role names. The map should be formatted as a semicolon separated list of key-value pairs, where the key is the LDAP group name and the value is a comma separated list of corresponding role names. For example: group1=role1;group2=role2;group3=role3,role4,role5\n\nYou could also use whitespaces and quotes around group names to make this mapping more readable, for example: \n\n----\n+dbms.security.ldap.authorization.group_to_role_mapping+=\\\n         \"cn=Neo4j Read Only,cn=users,dc=example,dc=com\"      = reader;    \\\n         \"cn=Neo4j Read-Write,cn=users,dc=example,dc=com\"     = publisher; \\\n         \"cn=Neo4j Schema Manager,cn=users,dc=example,dc=com\" = architect; \\\n         \"cn=Neo4j Administrator,cn=users,dc=example,dc=com\"  = admin\n----\n\nDeprecated: This will be replaced by dynamic configuration in the system graph in 4.0, including a migration step for the existing setting value. +\n",
              "value": null
            },
            "metrics.jvm.threads.enabled": {
              "description": "Enable reporting metrics about the current number of threads running.",
              "value": "true"
            },
            "ha.slave_only": {
              "description": "Whether this instance should only participate as slave in cluster. If set to `true`, it will never be elected as master.",
              "value": "false"
            },
            "dbms.directories.run": {
              "description": "Path of the run directory. This directory holds Neo4j's runtime state, such as a pidfile when it is running in the background. The pidfile is created when starting neo4j and removed when stopping it. It may be placed on an in-memory filesystem such as tmpfs.",
              "value": "/var/run/neo4j"
            },
            "cypher.forbid_exhaustive_shortestpath": {
              "description": "This setting is associated with performance optimization. Set this to `true` in situations where it is preferable to have any queries using the 'shortestPath' function terminate as soon as possible with no answer, rather than potentially running for a long time attempting to find an answer (even if there is no path to be found). For most queries, the 'shortestPath' algorithm will return the correct answer very quickly. However there are some cases where it is possible that the fast bidirectional breadth-first search algorithm will find no results even if they exist. This can happen when the predicates in the `WHERE` clause applied to 'shortestPath' cannot be applied to each step of the traversal, and can only be applied to the entire path. When the query planner detects these special cases, it will plan to perform an exhaustive depth-first search if the fast algorithm finds no paths. However, the exhaustive search may be orders of magnitude slower than the fast algorithm. If it is critical that queries terminate as soon as possible, it is recommended that this option be set to `true`, which means that Neo4j will never consider using the exhaustive search for shortestPath queries. However, please note that if no paths are found, an error will be thrown at run time, which will need to be handled by the application.",
              "value": "false"
            },
            "dbms.directories.lib": {
              "description": "Path of the lib directory",
              "value": "/usr/share/neo4j/lib"
            },
            "unsupported.cypher.expression_recompilation_limit": {
              "description": "Number of uses before an expression is considered for compilation",
              "value": "1"
            },
            "unsupported.dbms.udc.host": {
              "description": "Configuration attribute",
              "value": "udc.neo4j.org"
            },
            "dbms.logs.security.rotation.keep_number": {
              "description": "Maximum number of history files for the security log.",
              "value": "7"
            },
            "ha.phase1_timeout": {
              "description": "Timeout for Paxos phase 1. If it is not given a value it defaults to ha.paxos_timeout and will implicitly change if ha.paxos_timeout changes. This is an advanced parameter which should only be changed if specifically advised by Neo4j Professional Services. ",
              "value": "5000ms"
            },
            "dbms.jvm.additional": {
              "description": "Additional JVM arguments. Argument order can be significant. To use a Java commercial feature, the argument to unlock commercial features must precede the argument to enable the specific feature in the config value string. For example, to use Flight Recorder, `-XX:+UnlockCommercialFeatures` must come before `-XX:+FlightRecorder`.",
              "value": "-Dunsupported.dbms.udc.source=gcloud-CORE"
            },
            "dbms.security.plugin.authorization_enabled": {
              "description": "Enable authorization via plugin authorization providers.",
              "value": "false"
            },
            "ha.tx_push_strategy": {
              "description": "Push strategy of a transaction to a slave during commit.",
              "value": "fixed_ascending"
            },
            "causal_clustering.join_catch_up_timeout": {
              "description": "Time out for a new member to catch up",
              "value": "600000ms"
            },
            "dbms.security.auth_cache_max_capacity": {
              "description": "The maximum capacity for authentication and authorization caches (respectively).",
              "value": "10000"
            },
            "unsupported.dbms.bolt.outbound_buffer_throttle": {
              "description": "Whether to apply network level outbound network buffer based throttling",
              "value": "true"
            },
            "unsupported.dbms.bolt.inbound_message_throttle.high_watermark": {
              "description": "When the number of queued inbound messages grows beyond this value, reading from underlying channel will be paused (no more inbound messages will be available) until queued number of messages drops below the configured low watermark value.",
              "value": "300"
            },
            "metrics.prometheus.enabled": {
              "description": "Set to `true` to enable the Prometheus endpoint",
              "value": "false"
            },
            "metrics.csv.interval": {
              "description": "The reporting interval for the CSV files. That is, how often new rows with numbers are appended to the CSV files.",
              "value": "3000ms"
            },
            "causal_clustering.protocol_implementations.catchup": {
              "description": "Catchup protocol implementation versions that this instance will allow in negotiation as a comma-separated list. Order is not relevant: the greatest value will be preferred. An empty list will allow all supported versions",
              "value": "[]"
            },
            "causal_clustering.raft_log_prune_strategy": {
              "description": "RAFT log pruning strategy",
              "value": "1g size"
            },
            "unsupported.dbms.db.spatial.crs.wgs-84.x.max": {
              "description": "The maximum x value for the index extents for 2D wgs-84 spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "180.0"
            },
            "causal_clustering.read_replica_transaction_applier_batch_size": {
              "description": "Maximum transaction batch size for read replicas when applying transactions pulled from core servers.",
              "value": "64"
            },
            "cypher.hints_error": {
              "description": "Set this to specify the behavior when Cypher planner or runtime hints cannot be fulfilled. If true, then non-conformance will result in an error, otherwise only a warning is generated.",
              "value": "false"
            },
            "dbms.index_searcher_cache_size": {
              "description": "The maximum number of open Lucene index searchers.",
              "value": "2147483647"
            },
            "cypher.min_replan_interval": {
              "description": "The minimum time between possible cypher query replanning events. After this time, the graph statistics will be evaluated, and if they have changed by more than the value set by cypher.statistics_divergence_threshold, the query will be replanned. If the statistics have not changed sufficiently, the same interval will need to pass before the statistics will be evaluated again. Each time they are evaluated, the divergence threshold will be reduced slightly until it reaches 10% after 7h, so that even moderately changing databases will see query replanning after a sufficiently long time interval.",
              "value": "10000ms"
            },
            "dbms.security.auth_providers": {
              "description": "A list of security authentication and authorization providers containing the users and roles. They will be queried in the given order when login is attempted.",
              "value": "[native]"
            },
            "dbms.directories.certificates": {
              "description": "Directory for storing certificates to be used by Neo4j for TLS connections",
              "value": "/var/lib/neo4j/certificates"
            },
            "dbms.ssl.policy.<policyname>.trusted_dir": {
              "description": "Path to directory of X.509 certificates in PEM format for trusted parties.",
              "value": "trusted"
            },
            "metrics.csv.enabled": {
              "description": "Set to `true` to enable exporting metrics to CSV files",
              "value": "true"
            },
            "unsupported.dbms.security.tls_key_file": {
              "description": "Path to the X.509 private key to be used by Neo4j for TLS connections",
              "value": "/var/lib/neo4j/certificates/neo4j.key"
            },
            "dbms.label_index": {
              "description": "Backend to use for label --> nodes index",
              "value": "NATIVE"
            },
            "causal_clustering.store_copy_backoff_max_wait": {
              "description": "Maximum backoff timeout for store copy requests",
              "value": "5000ms"
            },
            "causal_clustering.schema_id_allocation_size": {
              "description": "The size of the ID allocation requests Core servers will make when they run out of SCHEMA IDs. Larger values mean less frequent requests but also result in more unused IDs (and unused disk space) in the event of a crash.",
              "value": "1024"
            },
            "metrics.neo4j.counts.enabled": {
              "description": "Enable reporting metrics about approximately how many entities are in the database; nodes, relationships, properties, etc.",
              "value": "true"
            },
            "metrics.enabled": {
              "description": "The default enablement value for all the supported metrics. Set this to `false` to turn off all metrics by default. The individual settings can then be used to selectively re-enable specific metrics.",
              "value": "true"
            },
            "causal_clustering.load_balancing.plugin": {
              "description": "The load balancing plugin to use.",
              "value": "server_policies"
            },
            "dbms.logs.debug.rotation.delay": {
              "description": "Minimum time interval after last rotation of the debug log before it may be rotated again.",
              "value": "300000ms"
            },
            "ha.heartbeat_interval": {
              "description": "How often heartbeat messages should be sent. Defaults to ha.default_timeout.",
              "value": "5000ms"
            },
            "dbms.logs.debug.level": {
              "description": "Debug log level threshold.",
              "value": "INFO"
            },
            "unsupported.dbms.bolt.inbound_message_throttle.low_watermark": {
              "description": "When the number of queued inbound messages, previously reached configured high watermark value, drops below this value, reading from underlying channel will be enabled and any pending messages will start queuing again.",
              "value": "100"
            },
            "browser.allow_outgoing_connections": {
              "description": "Configure the policy for outgoing Neo4j Browser connections.",
              "value": "true"
            },
            "dbms.track_query_allocation": {
              "description": "Enables or disables tracking of how many bytes are allocated by the execution of a query. Calling `dbms.listQueries` will display the time. This can also be logged in the query log by using `log_queries_allocation_logging_enabled`.",
              "value": "false"
            },
            "unsupported.dbms.jmx_module.enabled": {
              "description": "Configuration attribute",
              "value": "true"
            },
            "dbms.index_sampling.buffer_size": {
              "description": "Size of buffer used by index sampling. This configuration setting is no longer applicable as from Neo4j 3.0.3. Please use dbms.index_sampling.sample_size_limit instead.",
              "value": "67108864"
            },
            "causal_clustering.raft_in_queue_max_batch": {
              "description": "Largest batch processed by RAFT in number of entries",
              "value": "128"
            },
            "unsupported.cypher.plan_with_minimum_cardinality_estimates": {
              "description": "Enable using minimum cardinality estimates in the Cypher cost planner, so that cardinality estimates for logical plan operators are not allowed to go below certain thresholds even when the statistics give smaller numbers. This is especially useful for large import queries that write nodes and relationships into an empty or small database, where the generated query plan needs to be able to scale beyond the initial statistics. Otherwise, when this is disabled, the statistics on an empty or tiny database may lead the cost planner to for example pick a scan over an index seek, even when an index exists, because of a lower estimated cost.",
              "value": "true"
            },
            "causal_clustering.replication_retry_timeout_limit": {
              "description": "The upper limit for the exponentially incremented retry timeout.",
              "value": "60000ms"
            },
            "ha.host.data": {
              "description": "Hostname and port to bind the HA server.",
              "value": "0.0.0.0:6001-6011"
            },
            "unsupported.dbms.db.spatial.crs.cartesian.x.min": {
              "description": "The minimum x value for the index extents for 2D cartesian spatial index. The 2Dto 1D mapping function divides all 2Dspace into discrete tiles, and orders these using a space filling curve designed to optimize the requirement that tiles that are close together in this ordered list are also close together in 2Dspace. This requires that the extents of the 2Dspace be known in advance and never changed. If you do change these settings, you need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.",
              "value": "-1000000.0"
            }
          }
        },
        {
          "name": "java.lang:name=Compressed Class Space,type=MemoryPool",
          "attributes": {
            "UsageThresholdCount": {
              "description": "UsageThresholdCount",
              "value": 0
            },
            "Usage": {
              "description": "Usage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 15945728,
                  "used": 14888664,
                  "max": 1073741824
                }
              }
            },
            "MemoryManagerNames": {
              "description": "MemoryManagerNames",
              "value": [
                "Metaspace Manager"
              ]
            },
            "UsageThresholdSupported": {
              "description": "UsageThresholdSupported",
              "value": true
            },
            "UsageThreshold": {
              "description": "UsageThreshold",
              "value": 0
            },
            "CollectionUsageThresholdCount": {
              "description": "CollectionUsageThresholdCount",
              "value": null
            },
            "PeakUsage": {
              "description": "PeakUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 0,
                  "committed": 15945728,
                  "used": 14908688,
                  "max": 1073741824
                }
              }
            },
            "UsageThresholdExceeded": {
              "description": "UsageThresholdExceeded",
              "value": false
            },
            "CollectionUsageThreshold": {
              "description": "CollectionUsageThreshold",
              "value": null
            },
            "Name": {
              "description": "Name",
              "value": "Compressed Class Space"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=Compressed Class Space,type=MemoryPool"
            },
            "Type": {
              "description": "Type",
              "value": "NON_HEAP"
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionUsageThresholdSupported": {
              "description": "CollectionUsageThresholdSupported",
              "value": false
            },
            "CollectionUsage": {
              "description": "CollectionUsage",
              "value": null
            },
            "CollectionUsageThresholdExceeded": {
              "description": "CollectionUsageThresholdExceeded",
              "value": null
            }
          }
        },
        {
          "name": "java.lang:type=Memory",
          "attributes": {
            "ObjectPendingFinalizationCount": {
              "description": "ObjectPendingFinalizationCount",
              "value": 0
            },
            "Verbose": {
              "description": "Verbose",
              "value": false
            },
            "HeapMemoryUsage": {
              "description": "HeapMemoryUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 4294967296,
                  "committed": 4294967296,
                  "used": 1657455624,
                  "max": 4294967296
                }
              }
            },
            "NonHeapMemoryUsage": {
              "description": "NonHeapMemoryUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 2555904,
                  "committed": 206974976,
                  "used": 199563352,
                  "max": -1
                }
              }
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:type=Memory"
            }
          }
        },
        {
          "name": "java.lang:name=G1 Eden Space,type=MemoryPool",
          "attributes": {
            "UsageThresholdCount": {
              "description": "UsageThresholdCount",
              "value": null
            },
            "Usage": {
              "description": "Usage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 226492416,
                  "committed": 2313158656,
                  "used": 41943040,
                  "max": -1
                }
              }
            },
            "MemoryManagerNames": {
              "description": "MemoryManagerNames",
              "value": [
                "G1 Old Generation",
                "G1 Young Generation"
              ]
            },
            "UsageThresholdSupported": {
              "description": "UsageThresholdSupported",
              "value": false
            },
            "UsageThreshold": {
              "description": "UsageThreshold",
              "value": null
            },
            "CollectionUsageThresholdCount": {
              "description": "CollectionUsageThresholdCount",
              "value": 0
            },
            "PeakUsage": {
              "description": "PeakUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 226492416,
                  "committed": 2699034624,
                  "used": 2569011200,
                  "max": -1
                }
              }
            },
            "UsageThresholdExceeded": {
              "description": "UsageThresholdExceeded",
              "value": null
            },
            "CollectionUsageThreshold": {
              "description": "CollectionUsageThreshold",
              "value": 0
            },
            "Name": {
              "description": "Name",
              "value": "G1 Eden Space"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.lang:name=G1 Eden Space,type=MemoryPool"
            },
            "Type": {
              "description": "Type",
              "value": "HEAP"
            },
            "Valid": {
              "description": "Valid",
              "value": true
            },
            "CollectionUsageThresholdSupported": {
              "description": "CollectionUsageThresholdSupported",
              "value": true
            },
            "CollectionUsage": {
              "description": "CollectionUsage",
              "value": {
                "description": "java.lang.management.MemoryUsage",
                "properties": {
                  "init": 226492416,
                  "committed": 2313158656,
                  "used": 0,
                  "max": -1
                }
              }
            },
            "CollectionUsageThresholdExceeded": {
              "description": "CollectionUsageThresholdExceeded",
              "value": false
            }
          }
        },
        {
          "name": "java.nio:name=mapped,type=BufferPool",
          "attributes": {
            "TotalCapacity": {
              "description": "TotalCapacity",
              "value": 0
            },
            "MemoryUsed": {
              "description": "MemoryUsed",
              "value": 0
            },
            "Count": {
              "description": "Count",
              "value": 0
            },
            "Name": {
              "description": "Name",
              "value": "mapped"
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "java.nio:name=mapped,type=BufferPool"
            }
          }
        },
        {
          "name": "com.sun.management:type=DiagnosticCommand",
          "attributes": {}
        },
        {
          "name": "com.sun.management:type=HotSpotDiagnostic",
          "attributes": {
            "DiagnosticOptions": {
              "description": "DiagnosticOptions",
              "value": [
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "HeapDumpBeforeFullGC",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "HeapDumpAfterFullGC",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "HeapDumpOnOutOfMemoryError",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "HeapDumpPath",
                    "writeable": true,
                    "value": "",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "CMSAbortablePrecleanWaitMillis",
                    "writeable": true,
                    "value": "100",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "CMSWaitDuration",
                    "writeable": true,
                    "value": "2000",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "CMSTriggerInterval",
                    "writeable": true,
                    "value": "-1",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintGC",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintGCDetails",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintGCDateStamps",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintGCTimeStamps",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintGCID",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintClassHistogramBeforeFullGC",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintClassHistogramAfterFullGC",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintClassHistogram",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "MinHeapFreeRatio",
                    "writeable": true,
                    "value": "40",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "MaxHeapFreeRatio",
                    "writeable": true,
                    "value": "70",
                    "origin": "DEFAULT"
                  }
                },
                {
                  "description": "com.sun.management.VMOption",
                  "properties": {
                    "name": "PrintConcurrentLocks",
                    "writeable": true,
                    "value": "false",
                    "origin": "DEFAULT"
                  }
                }
              ]
            },
            "ObjectName": {
              "description": "ObjectName",
              "value": "com.sun.management:type=HotSpotDiagnostic"
            }
          }
        }
      ],
      "configuration": {
        "bolt.ssl_policy": "default",
        "browser.allow_outgoing_connections": "true",
        "browser.credential_timeout": "0ms",
        "browser.post_connect_cmd": "",
        "browser.remote_content_hostname_whitelist": "guides.neo4j.com,localhost",
        "browser.retain_connection_credentials": "true",
        "causal_clustering.array_block_id_allocation_size": "1024",
        "causal_clustering.catch_up_client_inactivity_timeout": "600000ms",
        "causal_clustering.catchup_batch_size": "64",
        "causal_clustering.cluster_allow_reads_on_followers": "true",
        "causal_clustering.cluster_routing_ttl": "300000ms",
        "causal_clustering.cluster_topology_refresh": "5000ms",
        "causal_clustering.connect-randomly-to-server-group": "[]",
        "causal_clustering.database": "default",
        "causal_clustering.disable_middleware_logging": "true",
        "causal_clustering.discovery_advertised_address": "node3.cluster.graph.center:5000",
        "causal_clustering.discovery_listen_address": "0.0.0.0:5000",
        "causal_clustering.discovery_type": "LIST",
        "causal_clustering.enable_pre_voting": "false",
        "causal_clustering.expected_core_cluster_size": "3",
        "causal_clustering.global_session_tracker_state_size": "1000",
        "causal_clustering.handshake_timeout": "20000ms",
        "causal_clustering.id_alloc_state_size": "1000",
        "causal_clustering.in_flight_cache.max_bytes": "2147483648",
        "causal_clustering.in_flight_cache.max_entries": "1024",
        "causal_clustering.in_flight_cache.type": "CONSECUTIVE",
        "causal_clustering.initial_discovery_members": "[meetup-cluster-core-vm-1:5000, meetup-cluster-core-vm-2:5000, meetup-cluster-core-vm-3:5000]",
        "causal_clustering.join_catch_up_timeout": "600000ms",
        "causal_clustering.kubernetes.address": "kubernetes.default.svc:443",
        "causal_clustering.kubernetes.ca_crt": "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt",
        "causal_clustering.kubernetes.label_selector": "",
        "causal_clustering.kubernetes.namespace": "/var/run/secrets/kubernetes.io/serviceaccount/namespace",
        "causal_clustering.kubernetes.service_port_name": "",
        "causal_clustering.kubernetes.token": "/var/run/secrets/kubernetes.io/serviceaccount/token",
        "causal_clustering.label_token_id_allocation_size": "32",
        "causal_clustering.label_token_name_id_allocation_size": "1024",
        "causal_clustering.last_applied_state_size": "1000",
        "causal_clustering.leader_election_timeout": "7000ms",
        "causal_clustering.load_balancing.config": "",
        "causal_clustering.load_balancing.plugin": "server_policies",
        "causal_clustering.load_balancing.shuffle": "true",
        "causal_clustering.log_shipping_max_lag": "256",
        "causal_clustering.middleware_logging.level": "500",
        "causal_clustering.minimum_core_cluster_size_at_formation": "3",
        "causal_clustering.minimum_core_cluster_size_at_runtime": "3",
        "causal_clustering.multi_dc_license": "false",
        "causal_clustering.neostore_block_id_allocation_size": "1024",
        "causal_clustering.node_id_allocation_size": "1024",
        "causal_clustering.node_labels_id_allocation_size": "1024",
        "causal_clustering.property_id_allocation_size": "1024",
        "causal_clustering.property_key_token_id_allocation_size": "32",
        "causal_clustering.property_key_token_name_id_allocation_size": "1024",
        "causal_clustering.protocol_implementations.catchup": "[]",
        "causal_clustering.protocol_implementations.compression": "[]",
        "causal_clustering.protocol_implementations.raft": "[]",
        "causal_clustering.pull_interval": "1000ms",
        "causal_clustering.raft_advertised_address": "10.142.0.5:7000",
        "causal_clustering.raft_in_queue_max_batch_bytes": "8388608",
        "causal_clustering.raft_in_queue_max_bytes": "2147483648",
        "causal_clustering.raft_listen_address": "0.0.0.0:7000",
        "causal_clustering.raft_log_implementation": "SEGMENTED",
        "causal_clustering.raft_log_prune_strategy": "1g size",
        "causal_clustering.raft_log_pruning_frequency": "600000ms",
        "causal_clustering.raft_log_reader_pool_size": "8",
        "causal_clustering.raft_log_rotation_size": "262144000",
        "causal_clustering.raft_membership_state_size": "1000",
        "causal_clustering.raft_term_state_size": "1000",
        "causal_clustering.raft_vote_state_size": "1000",
        "causal_clustering.read_replica_time_to_live": "60000ms",
        "causal_clustering.refuse_to_be_leader": "false",
        "causal_clustering.relationship_group_id_allocation_size": "1024",
        "causal_clustering.relationship_id_allocation_size": "1024",
        "causal_clustering.relationship_type_token_id_allocation_size": "32",
        "causal_clustering.relationship_type_token_name_id_allocation_size": "1024",
        "causal_clustering.replicated_lock_token_state_size": "1000",
        "causal_clustering.replication_retry_timeout_base": "10000ms",
        "causal_clustering.replication_retry_timeout_limit": "60000ms",
        "causal_clustering.schema_id_allocation_size": "1024",
        "causal_clustering.server_groups": "[]",
        "causal_clustering.ssl_policy": "",
        "causal_clustering.state_machine_apply_max_batch_size": "16",
        "causal_clustering.state_machine_flush_window_size": "4096",
        "causal_clustering.store_copy_max_retry_time_per_request": "1200000ms",
        "causal_clustering.string_block_id_allocation_size": "1024",
        "causal_clustering.transaction_advertised_address": "10.142.0.5:6000",
        "causal_clustering.transaction_listen_address": "0.0.0.0:6000",
        "causal_clustering.unknown_address_logging_throttle": "10000ms",
        "causal_clustering.upstream_selection_strategy": "[default]",
        "causal_clustering.user_defined_upstream_strategy": "",
        "cypher.default_language_version": "default",
        "cypher.forbid_exhaustive_shortestpath": "false",
        "cypher.forbid_shortestpath_common_nodes": "true",
        "cypher.hints_error": "false",
        "cypher.lenient_create_relationship": "false",
        "cypher.min_replan_interval": "10000ms",
        "cypher.planner": "default",
        "cypher.statistics_divergence_threshold": "0.75",
        "db.temporal.timezone": "Z",
        "dbms.active_database": "graph.db",
        "dbms.allow_format_migration": "false",
        "dbms.allow_upgrade": "true",
        "dbms.backup.address": "localhost:6362",
        "dbms.backup.enabled": "true",
        "dbms.backup.ssl_policy": "",
        "dbms.checkpoint": "periodic",
        "dbms.checkpoint.interval.time": "900000ms",
        "dbms.checkpoint.interval.tx": "100000",
        "dbms.checkpoint.iops.limit": "300",
        "dbms.config.strict_validation": "false",
        "dbms.connector.bolt.enabled": "true",
        "dbms.connector.bolt.listen_address": "0.0.0.0:7687",
        "dbms.connector.bolt.tls_level": "REQUIRED",
        "dbms.connector.http.enabled": "true",
        "dbms.connector.http.listen_address": "0.0.0.0:7474",
        "dbms.connector.https.enabled": "true",
        "dbms.connector.https.listen_address": "0.0.0.0:7473",
        "dbms.connectors.default_advertised_address": "node3.cluster.graph.center",
        "dbms.connectors.default_listen_address": "0.0.0.0",
        "dbms.db.timezone": "UTC",
        "dbms.directories.certificates": "/var/lib/neo4j/certificates",
        "dbms.directories.data": "/var/lib/neo4j/data",
        "dbms.directories.import": "/var/lib/neo4j/import",
        "dbms.directories.lib": "/usr/share/neo4j/lib",
        "dbms.directories.logs": "/var/log/neo4j",
        "dbms.directories.metrics": "/var/lib/neo4j/metrics",
        "dbms.directories.plugins": "/var/lib/neo4j/plugins",
        "dbms.directories.run": "/var/run/neo4j",
        "dbms.directories.tx_log": "/var/lib/neo4j/data/databases/graph.db",
        "dbms.filewatcher.enabled": "true",
        "dbms.ids.reuse.types.override": "[RELATIONSHIP, NODE]",
        "dbms.import.csv.buffer_size": "2097152",
        "dbms.import.csv.legacy_quote_escaping": "true",
        "dbms.index.default_schema_provider": "native-btree-1.0",
        "dbms.index.fulltext.default_analyzer": "standard",
        "dbms.index.fulltext.eventually_consistent": "false",
        "dbms.index.fulltext.eventually_consistent_index_update_queue_max_length": "10000",
        "dbms.index_sampling.background_enabled": "true",
        "dbms.index_sampling.buffer_size": "67108864",
        "dbms.index_sampling.sample_size_limit": "8388608",
        "dbms.index_sampling.update_percentage": "5",
        "dbms.index_searcher_cache_size": "2147483647",
        "dbms.jvm.additional": "-Dunsupported.dbms.udc.source=gcloud-CORE",
        "dbms.lock.acquisition.timeout": "0ms",
        "dbms.logs.debug.level": "INFO",
        "dbms.logs.debug.path": "/var/log/neo4j/debug.log",
        "dbms.logs.debug.rotation.delay": "300000ms",
        "dbms.logs.debug.rotation.keep_number": "7",
        "dbms.logs.debug.rotation.size": "20971520",
        "dbms.logs.gc.enabled": "false",
        "dbms.logs.gc.options": "-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintPromotionFailure -XX:+PrintTenuringDistribution",
        "dbms.logs.gc.rotation.keep_number": "5",
        "dbms.logs.gc.rotation.size": "20971520",
        "dbms.logs.http.enabled": "false",
        "dbms.logs.http.path": "/var/log/neo4j/http.log",
        "dbms.logs.http.rotation.keep_number": "5",
        "dbms.logs.http.rotation.size": "20971520",
        "dbms.logs.query.allocation_logging_enabled": "false",
        "dbms.logs.query.enabled": "false",
        "dbms.logs.query.page_logging_enabled": "false",
        "dbms.logs.query.parameter_logging_enabled": "true",
        "dbms.logs.query.path": "/var/log/neo4j/query.log",
        "dbms.logs.query.rotation.keep_number": "7",
        "dbms.logs.query.rotation.size": "20971520",
        "dbms.logs.query.runtime_logging_enabled": "false",
        "dbms.logs.query.threshold": "0ms",
        "dbms.logs.query.time_logging_enabled": "false",
        "dbms.logs.security.level": "INFO",
        "dbms.logs.security.path": "/var/log/neo4j/security.log",
        "dbms.logs.security.rotation.delay": "300000ms",
        "dbms.logs.security.rotation.keep_number": "7",
        "dbms.logs.security.rotation.size": "20971520",
        "dbms.logs.timezone": "UTC",
        "dbms.logs.user.path": "/var/log/neo4j/neo4j.log",
        "dbms.logs.user.rotation.delay": "300000ms",
        "dbms.logs.user.rotation.keep_number": "7",
        "dbms.logs.user.rotation.size": "0",
        "dbms.logs.user.stdout_enabled": "true",
        "dbms.memory.heap.initial_size": "4g",
        "dbms.memory.heap.max_size": "4g",
        "dbms.memory.pagecache.size": "8g",
        "dbms.memory.pagecache.swapper": "",
        "dbms.mode": "CORE",
        "dbms.netty.ssl.provider": "JDK",
        "dbms.procedures.kill_query_verbose": "true",
        "dbms.query_cache_size": "1000",
        "dbms.read_only": "false",
        "dbms.record_format": "",
        "dbms.relationship_grouping_threshold": "50",
        "dbms.rest.transaction.idle_timeout": "60000ms",
        "dbms.security.allow_csv_import_from_file_urls": "true",
        "dbms.security.auth_cache_max_capacity": "10000",
        "dbms.security.auth_cache_ttl": "600000ms",
        "dbms.security.auth_cache_use_ttl": "true",
        "dbms.security.auth_enabled": "true",
        "dbms.security.auth_lock_time": "5000ms",
        "dbms.security.auth_max_failed_attempts": "3",
        "dbms.security.auth_provider": "native",
        "dbms.security.causal_clustering_status_auth_enabled": "true",
        "dbms.security.ha_status_auth_enabled": "true",
        "dbms.security.http_access_control_allow_origin": "*",
        "dbms.security.http_authorization_classes": "[]",
        "dbms.security.http_strict_transport_security": "",
        "dbms.security.ldap.authentication.cache_enabled": "true",
        "dbms.security.ldap.authentication.mechanism": "simple",
        "dbms.security.ldap.authentication.use_samaccountname": "false",
        "dbms.security.ldap.authentication.user_dn_template": "uid={0},ou=users,dc=example,dc=com",
        "dbms.security.ldap.authorization.group_membership_attributes": "[memberOf]",
        "dbms.security.ldap.authorization.group_to_role_mapping": "",
        "dbms.security.ldap.authorization.system_password": "",
        "dbms.security.ldap.authorization.system_username": "",
        "dbms.security.ldap.authorization.use_system_account": "false",
        "dbms.security.ldap.authorization.user_search_base": "ou=users,dc=example,dc=com",
        "dbms.security.ldap.authorization.user_search_filter": "(&(objectClass=*)(uid={0}))",
        "dbms.security.ldap.connection_timeout": "30000ms",
        "dbms.security.ldap.host": "localhost",
        "dbms.security.ldap.read_timeout": "30000ms",
        "dbms.security.ldap.referral": "follow",
        "dbms.security.ldap.use_starttls": "false",
        "dbms.security.log_successful_authentication": "true",
        "dbms.security.procedures.default_allowed": "",
        "dbms.security.procedures.roles": "",
        "dbms.security.procedures.unrestricted": "\"apoc.*,algo.*\"",
        "dbms.security.procedures.whitelist": "*",
        "dbms.security.property_level.blacklist": "",
        "dbms.security.property_level.enabled": "false",
        "dbms.shutdown_transaction_end_timeout": "10000ms",
        "dbms.ssl.policy.<policyname>.allow_key_generation": "false",
        "dbms.ssl.policy.<policyname>.base_directory": "",
        "dbms.ssl.policy.<policyname>.ciphers": "",
        "dbms.ssl.policy.<policyname>.client_auth": "REQUIRE",
        "dbms.ssl.policy.<policyname>.private_key": "private.key",
        "dbms.ssl.policy.<policyname>.public_certificate": "public.crt",
        "dbms.ssl.policy.<policyname>.revoked_dir": "revoked",
        "dbms.ssl.policy.<policyname>.tls_versions": "[TLSv1.2]",
        "dbms.ssl.policy.<policyname>.trust_all": "false",
        "dbms.ssl.policy.<policyname>.trusted_dir": "trusted",
        "dbms.ssl.policy.<policyname>.verify_hostname": "false",
        "dbms.threads.worker_count": "4",
        "dbms.track_query_allocation": "false",
        "dbms.track_query_cpu_time": "false",
        "dbms.transaction.bookmark_ready_timeout": "30000ms",
        "dbms.transaction.monitor.check.interval": "2000ms",
        "dbms.transaction.timeout": "0ms",
        "dbms.tx_log.rotation.retention_policy": "7 days",
        "dbms.tx_log.rotation.size": "262144000",
        "dbms.tx_state.max_off_heap_memory": "2147483648",
        "dbms.tx_state.memory_allocation": "ON_HEAP",
        "dbms.tx_state.off_heap.block_cache_size": "128",
        "dbms.tx_state.off_heap.max_cacheable_block_size": "524288",
        "dbms.udc.enabled": "true",
        "dbms.unmanaged_extension_classes": "[]",
        "dbms.windows_service_name": "neo4j",
        "ha.allow_init_cluster": "true",
        "ha.branched_data_copying_strategy": "branch_then_copy",
        "ha.branched_data_policy": "keep_all",
        "ha.broadcast_timeout": "30000ms",
        "ha.configuration_timeout": "1000ms",
        "ha.data_chunk_size": "2097152",
        "ha.default_timeout": "5000ms",
        "ha.election_timeout": "5000ms",
        "ha.heartbeat_interval": "5000ms",
        "ha.heartbeat_timeout": "40000ms",
        "ha.host.coordination": "0.0.0.0:5001-5099",
        "ha.host.data": "0.0.0.0:6001-6011",
        "ha.initial_hosts": "",
        "ha.internal_role_switch_timeout": "10000ms",
        "ha.join_timeout": "30000ms",
        "ha.learn_timeout": "5000ms",
        "ha.leave_timeout": "30000ms",
        "ha.max_acceptors": "21",
        "ha.max_channels_per_slave": "20",
        "ha.paxos_timeout": "5000ms",
        "ha.phase1_timeout": "5000ms",
        "ha.phase2_timeout": "5000ms",
        "ha.pull_batch_size": "100",
        "ha.pull_interval": "10000ms",
        "ha.role_switch_timeout": "120000ms",
        "ha.server_id": "",
        "ha.slave_lock_timeout": "20000ms",
        "ha.slave_only": "false",
        "ha.slave_read_timeout": "20000ms",
        "ha.tx_push_factor": "1",
        "ha.tx_push_strategy": "fixed_ascending",
        "https.ssl_policy": "legacy",
        "metrics.bolt.messages.enabled": "true",
        "metrics.csv.enabled": "true",
        "metrics.csv.interval": "3000ms",
        "metrics.csv.rotation.keep_number": "7",
        "metrics.csv.rotation.size": "10485760",
        "metrics.cypher.replanning.enabled": "true",
        "metrics.enabled": "true",
        "metrics.graphite.enabled": "false",
        "metrics.graphite.interval": "3000ms",
        "metrics.graphite.server": ":2003",
        "metrics.jvm.buffers.enabled": "true",
        "metrics.jvm.gc.enabled": "true",
        "metrics.jvm.memory.enabled": "true",
        "metrics.jvm.threads.enabled": "true",
        "metrics.neo4j.causal_clustering.enabled": "true",
        "metrics.neo4j.checkpointing.enabled": "true",
        "metrics.neo4j.cluster.enabled": "true",
        "metrics.neo4j.counts.enabled": "true",
        "metrics.neo4j.enabled": "true",
        "metrics.neo4j.logrotation.enabled": "true",
        "metrics.neo4j.network.enabled": "true",
        "metrics.neo4j.pagecache.enabled": "true",
        "metrics.neo4j.server.enabled": "true",
        "metrics.neo4j.tx.enabled": "true",
        "metrics.prefix": "neo4j",
        "metrics.prometheus.enabled": "false",
        "metrics.prometheus.endpoint": "localhost:2004",
        "tools.consistency_checker.check_graph": "true",
        "tools.consistency_checker.check_indexes": "true",
        "tools.consistency_checker.check_label_scan_store": "true",
        "tools.consistency_checker.check_property_owners": "false"
      },
      "apoc": {
        "version": "Neo4jError: Unknown function 'apoc.version' (line 1, column 8 (offset: 7))\n\"RETURN apoc.version() as value\"\n        ^"
      },
      "nodes": {
        "count": 6673172
      },
      "schema": {
        "labels": [
          "NAryTree",
          "Hub",
          "MergeNode",
          "Spoke",
          "Leaf",
          "Customer",
          "RawWriteNode",
          "Address",
          "SimpleWrite",
          "Node",
          "FatNode",
          "Test",
          "Fictional",
          "Interval",
          "ScaleInstance",
          "ChordInstance",
          "Chord",
          "Scale",
          "Tone",
          "Rando",
          "P",
          "TestNode",
          "Canary",
          "User",
          "Tweet",
          "Hashtag",
          "Source"
        ]
      },
      "algo": {
        "version": "Neo4jError: Unknown function 'algo.version' (line 1, column 8 (offset: 7))\n\"RETURN algo.version() as value\"\n        ^"
      }
    }
  ],
  "neo4jDesktop": {
    "implementation": "Halin.Neo4jDesktopStandIn",
    "global": {
      "online": true,
      "settings": {
        "allowSendReports": true,
        "allowSendStats": true,
        "allowStoreCredentials": true
      }
    },
    "projects": [
      {
        "name": "shim",
        "graphs": [
          {
            "name": "shim",
            "status": "ACTIVE",
            "databaseStatus": "RUNNING",
            "databaseType": "neo4j",
            "id": "92df61ab-60e6-4383-a2ed-5789cd659abd",
            "connection": {
              "configuration": {
                "path": ".",
                "protocols": {
                  "bolt": {
                    "host": "node1.cluster.graph.center",
                    "port": 7687,
                    "username": "neo4j",
                    "password": "********",
                    "enabled": true,
                    "tlsLevel": "REQUIRED"
                  }
                }
              }
            }
          }
        ]
      }
    ]
  }
}